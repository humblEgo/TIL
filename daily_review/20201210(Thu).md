1. 학습 날짜 // 2020-12-10(목)
2. 학습시간 // 9:00~22:00

3. 학습 범위 및 주제 // Ruby
4. 동료 학습 방법 // -
5. 학습 목표 // Ruby의 기초를 빠르게 학습한다.

---

6. 상세 학습 내용

eunhkim님의 추천에 따라 [한 눈에 끝내는 루비 기초](https://edu.goorm.io/learn/lecture/2011/한-눈에-끝내는-루비-기초) 를 빠르게 진행해서 마쳤다.

이후 [책 '퍼펙트루비'](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=55268465)을 정독하며 학습 진행하였다. 아래는 대략 정리한 내용.

# 1장 루비 개요

### 모든 것이 객체

루비는 순수 객체지향 프로그래밍 언어이다. 즉, C 계열 언어들과 달리 원시형에 해당되는 자료형이 없고 모든 것이 그야말로 '객체'이다.

그래서 아래처럼 int나 bool 값에도 메소드를 호출할 수 있다.

```ruby
ㅁp 1.t_s 							# "1"을 출력
p true.to_s						# "true"를 출력
p nil.class 					# NilClass 출력
p nilClass.ancestors 	# [NilClass, Object, Kernel, BasicObject] 출력. 호출한 클래스의 상속관계를 나타낸다.
```



### 루비는 여러 종류가 있다.

마츠모토씨가 만든 루비를 MRI(Matz' Ruby Implementation)이나 CRuby(주로 C언어로 개발됨)이라 부른다. 그 외 루비들 중 대표적인 것은 아래와 같다.

- JRuby: 자바로 개발된 루비. 자바 라이브러리도 이용할 수 있다.
- MacRuby: 맥의 코코아 프레임워크 등을 바로 사용할 수 있도록 개조한 루비
- Rubinius: 루비 자신을 이용해서 개발된 루비
- ruby: 임베디드용 경량판 루비



## 코딩스타일

루비를 쓰는(썼던) 기업들을 참고하자!

- [Ruby style guide by github](https://github.com/github/rubocop-github/blob/master/STYLEGUIDE.md)
- [Ruby style guide by Airbnb](https://github.com/airbnb/ruby#whitespace)



#### 네이밍

- 클래스, 모듈
  - 대문자로 시작 + 카멜케이스 사용
- 메소드명
  - 영문 소문자 및 구분자 '_'를 이용해서 스네이크 케이스로 작성
- boolrean 값을 반환하는 메소드명
  - 메소드명 뒤에 물음표(?)를 붙여서 기술한다.
  - `ex) Object#nil?`
- 변수명
  - 메소드명과 동일하게 영문 소문자 + 스네이크 케이스
- 코드 블록 방침
  - 여러 줄에 걸쳐 기술할 경우: `do...end`를 사용한다.
  - 한 줄에 모두 작성할 때는 `{...}`을 사용한다.
  - 단, 처리 우선순위가 달라지는 경우가 있으므로 잘 구별해서 사용하자.



# 2장 루비 기초

#### 메소드 정의

메소드 정의는 def 키워드를 이용해서 기술한다. 마치 python.

```ruby
def 메소드명(인수 ...)... end
```

문자열은 큰따옴표 `""`나 작은따옴표 `''`  모두 쓸 수 있다. 그러나  큰 따옴표의 경우 `#{...}`로 감싸는 루비 코드를 포함시킬 수 있다. 이를 '식 전개'라고 한다.

```ruby
"result: #{2+2}"는 "result:4" 이라는 문자열이 된다.
```



#### 메소드 호출과 블록

메소드 호출은 아래 형식으로 한다.

```
리시버(receiver).메소드명
```

한편 블록은 처리를 하나의 단위로 묶은 것으로, 메소드 호출 시 한 번만 지정할 수 있는 인수의 일종이다. 이런 메소드의 호출을 '블록 메소드 호출'이라고 한다. 블록을 전달받은 메소드는 임의의 시점에 블록을 실행할 수 있다. each 메소드는 배열의 요소 수만큼 블록을 실행한다.

아래 예시를 보자.

```ruby
names.each do |name|
    puts "HELLO, #{name.upcase}"
end
```

- 변수 names를 리시버로 해서 each라는 이름의 메소드를 호출하고 있다.
- 메소드 호출 직후에 코드 블록을 `메소드명(실인수...) do |변수명| ...end` 로 표현한다.

블록은 다음과 같이 '{}'로 감싸서 표현할 수 도 있다.

```ruby
names.each {|name|
	puts "HELLO, #{name.upcase}"
}
```



### 톱 레벨

클래스 정의와 모듈 정의에서 쓰는 정의식 외에는 '톱 레벨' 이라고 부른다. 톱 레벨로 정의된 메소드는 전역 서브 루틴처럼 사용할 수 있으며 다음과 같은 특징을 가진다.

- 메소드 호출 시 리시버를 기술하지 않는다.
- 함수처럼 어디서든(전역) 호출할 수 있다.(극히 일부는 제외)

리시버를 기술하지 않는 경우에도 메소드 호출 시 암묵적인 리시버가 존재한다.



### 메소드 정의와 반환 값

메소드 반환 값은 해당 메소드 내에서 마지막으로 평가되는 식의 결과 값이다. 떄문에 return을 기술하지 않아도 된다.

```ruby
def add(a, b)
	a + b
end

add(1, 1)    # => 2
```

한편 처리 도중에 메소드를 호출한 곳으로 돌아가려면 return을 기술한다. return 값을 부여한 경우에는 그 값이 반환 값이 된다.



### 줄

식과 식은 줄바꿈으로 구분한다. 하지만 여러 식을 한 줄에 기술하고 싶은 경우에는 세미콜론으로 구분한다. 물론 보통은 줄바꿈으로 구분하는 식으로 작성한다.



### 멀티바이트를 포함하는 코드

코드가 한글 등 멀티바이트 문자열을 포함할 떄는 서두에 스크립트 인코딩을 지정한다.  //TODO: 2.7버전에서도 이런지 확인해볼 것.

파일 읽기나 정규 표현 인코딩시에는 이 스크립트 인코딩이 사용된다.

```ruby
#!/bin/bash                # <== 요래 shebang(유닉스에서 해석기를 지정해주는 문구)이 있는 경우에는 그 다음 줄에 기술한다.
# coding: utf-8            # <== 여러 형식으로 적을 수 있다. encoding: utf-8  ,  -*- coding: utf-8  ,  vim: set fileencoding=utf-8:
```



### 변수와 상수

변수는 스코프에 따라 구분할 수 있다. 변수 종류에 따라 명명 규칙이 다르므로, 이름만 보고서도 어떤 종류의 변수인지 판별할 수 있다.

- 지역변수

  - 첫 글자를 소문자 영어 또는 언더바(_)를 사용해야한다. `ex) ruby _ruby`
  - 블록, 메소드 정의, 클래스/모듈 정의, 톱 레벨을 스코프로 가진다.
  - 당연하게도 블록 안이라면 블록 밖에서 정의된 지역 변수를 참조할 수 있다. 반대로 블록 안에서는 블록 밖에서 참조할 수 없다.

- 전역변수

  - 전역변수명은 `$`로 시작해야 한다.
  - 존재하지 않는 전역 변수를 참조하면 `nil`이 반환된다.
  - 역시나 원활한 관리를 위해 가능하면 사용을 자제하자.

- 상수

  - 상수명은 영문 대문자로 시작해야한다.

  - 상수는 대입식을 이용해서 정의한다.

    ```ruby
    FOO_BAR = 'bar'
    
    puts FOO_BAR   # "bar"를 출력
    ```

  - 상수 대입은 한 번만 해야 하지만, 정의가 완료된 상수에 다시 대입하는 것이 가능하긴하다. 대신 경고문이 뜨므로 가급적 피하자.

  - 메소드 안에서 상수를 정의할 수는 없다. syntax error가 발생한다.

    ```ruby
    def set_foo
    	FOO_BAR = 'bar' # dynamic constant assignment (SyntaxError)
    End
    ```

    

### 조건 분기와 진리값

루비에서는 `false`와 `nil` 이외의 모든 값은 참으로 취급한다. **즉, 0도 참이 된다.**



### 식

루비 프로그램의 대부분은 어떤 값을 반환하는 식으로 이루어진다. 변수 대입은 오른쪽 값을 반환하고, if는 마지막으로 평가한 값을 반환한다. 심지어 'Hello'나 '1234' 등도 문자나 값을 반환하는 식이다.



### 클래스

class 키워드를 사용하고 클래스명은 영문 대문자로 시작해야 한다.

```ruby
class 클래스명
end
```

클래스로부터 인스턴스는 new 구문으로 생성한다. `클래스명.new`



### 인스턴스 변수

- 인스턴스 내에서만 참조할 수 있는 변수를 뜻한다.
- 이를 통해 객체의 상태를 저장할 수 있다.
- 인스턴스 변수는 '@length'처럼 @으로 시작하는 이름을 사용한다.

```ruby
class Ruler
	def length=(val)		# 루비에서는 인스턴스 변수에 대입하는 메소드 이름 끝에 등호 '='를 붙인다. C++의 연산자오버로딩마냥.
		@length = val
	end
	
	def length
		@length
	end
end

ruler = Ruler.new

ruler.length = 30
ruler.length  				# => 30
```

일반적으로는 인스턴스 변수에 접근하기 위한 메소드로 `attr_accessor`를 이용한다. C++로 치면 자동으로 getter, setter가 만들어지는 느낌이다.

```ruby
class Ruler
	attr_accessor :length
end
```



### self

메소드 내부에서는 해당 메소드가 있는 인스턴스를 `self`라는 이름의 유사 변수를 이용해서 참조할 수 있다. python과 동일하군, C++로 치면 `this` 같은 느낌!

그리고 역시나 메소드 내부에서 리시버를 생략한 메소드를 호출할 때는 암묵적으로 `self`가 리시버가 된다.

**리시버를 생략할 수 있을 때는 그렇게 하는 것이 일반적이다.**

단, `Ruler#length=` 같은 메소드 호출의 self는 생략할 수 없다. 이를 생략하면 메소드 호출이 아닌 지역변수 대입으로 처리되기 때문이다.



### 초기화

생성자를 `initialize` 메소드를 정의해서 구현한다. `new`의 인수로 전달한 값이 `initialize` 메소드에 인수로 전달된다.



### 클래스 메소드

모든 값은 객체로 취급된다. 고로 클래스도 물론 객체다. 따라서 클래스를 대상으로 메소드를 호출할 수 있다. 이처럼 클래스를 대상으로 호출할 수 있는 메소드를 **클래스 메소드**라고 한다.

클래스 메소드는 메소드명 앞에 self를 붙여서 정의한다. 아래처럼!

```ruby
class Ruler
	attr_accessor :length
	
	def self.pair
		[Ruler.new, Ruler.new]				# 리시버를 생략해서 [new, new]로 기술할 수도 있다.
	end
end
```



### 클래스 변수

클래스와 해당 인스턴스를 스코프로 하는 변수를 클래스 변수라고 한다.

클래스 변수는 `@@`를 이름 앞에 붙여서 표기한다.

클래스 변수는 클래스 정의 안이나 클래스 메소드에서 참조할 수 있다.

```ruby
class MyClass
	@@cvar = "Hello!"
	
	def cvar_in_method
		puts @@cvar
	end
	
	def self.cvar_in_class_method
		puts @@cvar
	end
end
```



### 상속

루비는 단일 상속을 지원한다.

클래스를 상속하려면 클래스 정의시 `<` 로 슈퍼 클래스를 지정한다.

```ruby
class 서브 클래스명 < 슈퍼 클래스명
end
```

그 외엔 뭐.. C++이랑 비슷하다.

- 서브 클래스에는 슈퍼 클래스에서 정의한 메소드가 상속된다.

- 서브 클래스의 인스턴스에서 슈퍼 클래스의 인스턴스 메소드를 호출할 수 있다.

- 서브 클래스에 새로운 메소드를 정의할 수도 있다.

- 슈퍼 클래스에서 이미 정의된 메소드를 서브 클래스에서 다시 정의하는 식으로 오버라이드도 가능하다.



아무것도 상속하지 않은 클래스를 정의할 수는 없다. 클래스 정의시에 슈퍼 클래스를 지정하지 않으면, Object 클래스를 상속한 클래스가 정의된다. 이 Object 클래스에는 객체의 기본적인 동작이 정의되어 있다.



### 모듈

루비에는 모듈이라는 클래스와 비슷한 구조가 있다. **모듈은 '인스턴스화 할 수 없는 클래스 같은 것'이라고 이해하면 된다.**

모듈은 module 키워드를 사용해서 정의한다.

```ruby
module ahebfaud
end
```

모듈 정의 안에는 다른 모듈이나 클래스 정의를 기술할 수 있어서 네임스페이스로 이용할 수 있다. C++처럼 `::` 을 이용해서 참조할 수 있다.

모듈 정의 내에서도 메소드를 정의할 수 있으나, 클래스에 정의한 메소드와는 다른 세가지 용도로 사용된다.

- 특정 메소드를 인스턴스 메소드로 포함
- 특정 객체의 메소드로 포함
- 모듈 함수로 사용

자세한건 4-2장을 참고하자.



### 주요 내장 클래스

루비가 표준으로 가지고 있는 대표적인 클래스를 확인해보자.

- 수치

  - Numeric 클래스를 상속한 몇 가지 서브 클래스(Fixnum, Bignum, Float)에 수치 표기방법이 정의되어있다.
    - 부동소수점 수는 e 뒤에 지수부를 기술할 수 있다.
    - 2진수(0b), 8진수(0 or 0o), 16진수(0x)를 표기할 수 있다.
    - `1_000_000` 큰 수치에 세 자리마다 구분해서 가독성을 높일 수 있다. `1__00`처럼 연달하 기술하거나 수치 값의 맨 앞이나 0x 등 접두사 바로 뒤에 기술할 수는 없다.

- 문자열

  - 여러 줄의 문자열을 표현하려면 `<< 식별자`를 사용해서 히어 도큐먼트(heredoc)로 만들면 된다.

  - 히어 도큐먼트 시작 식별자를 작은 따옴표로 감싸면 식 전개나 백슬래시 기법을 무효화할 수 있다.

    ```ruby
    str = << 'EOS'
    #{foo}\t#{bar}\t#{baz}
    EOS
    
    # 식전개를 하지 않고 백슬래시 기법도 무시된다.
    puts str    # => "#{foo}\t#{bar}\t#{baz}" 출력됨
    ```

  - 그 외에 문자열 내에서 따옴표를 많이 사용해야하는 경우에는 `%d(It's rainy)`처럼 기술하면 일일이 백슬래시를 붙이지 않아도 된다. 이를 퍼센티지(%) 기법이라고 한다.



### 심볼

앞에 콜론(:)을 붙인 문자열을 심볼(symbol)이라고 한다. 

음.. 문자열과 뭐가 다른거지? 식별자나 키워드로 활용할 때 더 빠르고 간편하다고는 하는데 왜 그런걸까? 
책 설명이 빈약하여 [Ruby의 심볼(SYMBOL)과 문자열(STRING)은 서로 어떻게 다른가?](http://guruble.com/루비-온-레일스ruby-on-rails-면접에는-어떤-질문들이-나올까/)를 참고해보았다.

- 심볼은 문자열과 달리 '변경이 불가능(immutable)'한 객체이다. 즉, 심볼은 한번 값이 assign 되고나면 값을 변경하는 것이 불가능하다 . 또한 Java에서 final 선언된 변수와 달리 덮어쓰기는 할 수 있다는 의미이다.

- 문자열은 mutable 하기 때문에, 루비 인터프리터는 실제 문자열이 어떤 값을 가지고 있는지 실행시점까지 알 수가 없다. 이것은 다시말해, 우리가 보기에는 동일한 문자열도 서로 다른 메모리 공간에 할당되어있다는 의미이다.

- 반면, 심볼은 Immutable 하기 때문에 한번 heap 메모리상에 생성되고 나면 해당 심볼은 동일한 객체로 재사용이 가능하다. 좀 더 자세히 알아보면, 루비에서 심볼은 단순히 동일한 heap 메모리를 재사용할 뿐만 아니라, `Symbol dictionary`를 통해 관리된다. irb에서 아래처럼 명령어를 실행하면 `Symbol dictionary`에 존재하는 심볼 목록을 확인할 수 있다.

  ```ruby
  > symbol.all_symbols.inspect
  ```

- 이런 특징 때문에 루비에서 대부분의 경우 심볼을 사용하는 것이 문자열을 사용하는 것보다 **메모리 효율성이나 성능 측면에서 유리**하며, hash의 키 등으로 문자열을 사용하는 것보다 심볼을 사용하는 것이 좋다.

심볼에는 상수나 변수, 메소드 이름으로 이용할 수 있는 글자를 사용 가능하다. 그 외의 문자열은 `:'foo-bar'`처럼 따옴표로 감싸 주어야한다.



### 배열

배열은 다수의 객체를 순서대로 나열한 컨테이너 객체이다. 

C++과 달리 하나의 배열에 형이 다른 객체를 넣을 수 있다. 

배열안에 배열을 넣어서 다차원 배열도 만들 수 있다. 마치 파이썬!

요소가 존재하지 않는 인덱스를 지정한 경우에는 'nil'이 반환된다.

인덱스로 마이너스 값을 지정하면 뒤에서부터 역순으로 세서 요소를 반환한다. 마치 파이썬!



문자열이나 심볼 배열은 퍼센티지 기법을 사용하면 간단하게 기술할 수 있다.

```ruby
%w(Alice bob carol)  #=> ["Alice", "bob", "carol"]
%i(red green blue)   #=> [:red, :green, :blue] # 루비 2.0 이후에 유효
```

요소가 공백을 포함할 때는 백슬래시로 이스케이프 처리를 해줘야한다.

```ruby
%w(foo\ bar hoge\ piyo)		# => ["foo bar", "hoge piyo"]
```



### 해시

연상 배열이라고도 한다. 첨자로 문자열이나 심볼 등 임의 객체를 사용할 수 있따.

해시 첨자는 키(key)라고도 불린다.

```ruby
{키 => 요소}
```

`colors['blue']`와 같이 키를 지정한다. 존재하지 않는 키를 지정하면 nil이 반환된다.

키가 심볼이면 다음과 같이 간단하게 기술할 수 있다.

```ruby
{red: 'ff000', green: '00ff00', blue: '0000ff'}
```



### 범위

루비에는 범위를 표현하는 범위 객체가 존재한다.

범위 구문은 두 객체 사이에 마침표를 배열해서 표현하며, 마침표 수에 따라 마지막 값을 범위에 포함할지가 결정된다.

`1..5` : 마지막 5를 범위에 포함함.

`1...5` : 마지막 5를 포함하지 않는다.

날짜나 문자열 범위 예제는 아래와 같다.

```ruby
vacation = Time.at(1343746800)..Time.at(1346425199)
```



### 정규 표현

문자열에서 특정 패턴과 일치하는 부분을 찾아내거나 유무를 확인한다. 형식은 아래와 같다.

```ruby
#  /pattern/ 기본형식이다.


pattern = /[0-9]+/

# 일치 여부를 진릿값으로 반환
pattern === 'HAL 9000'   		# => true
pattern === 'Hello world'  	# => false

# 최초로 일치한 위치를 정수로 반환
pattern =~ 'HAL 9000'				# => 4
pattern =~ 'Hello world'		# => nil
```



### 퍼센티지 기법의 괄호

퍼센티지 기법에 사용하는 괄호는 다른 괄호 종류나 기호를 사용해도 된다. 문자열이나 정규 표현 등에는 '()'을 자주 사용하기 때문에 '{}' 등의 다른 괄호를 사용해야 할 때가 있다.

```ruby
%q{paren(and paren)}		# => "paren(and paren)"
%r{/usr/(bin|lib)/}			# => /\/usr\/(bin|lib)\//
```

'{}' 이외의 괄호 종류도 사용할 수 있다. 임의의 기호를 이용할 수 있으며, 이때는 양쪽 단에 같은 기호를 사용한다.

```ruby
# 괄호 종류
%q<content>
%q[content]

# 임의의 기호
%q |content|
%q!content!
%q*content*
```



### 블록 객체

블록 객체(Proc)는 함수를 객체로 표현한 것이다. 참고로 Proc은 절차, Procedure의 줄임말이다. 

Proc.new에 블록을 지정하면 블록 객체를 생성할 수 있다. Proc.new 메서드는 블록으로 절차(루비 표현식들)를 넘겨 받는다. 가인수는 '|name|'처럼 파이프 기호를 이용해 기술한다.

```ruby
greeter = Proc.new {|name|
	puts "Hello, #{name}!"
}
```



`Kernel#proc` 메서드도 있다. 이 메서드는 `Proc.new`와 같다.

```ruby
p = proc { puts 'Hello, world!'}
p.call() 			# Hello, world!
```



Proc#call을 호출하면 처리가 실행된다. call에 지정한 인수는 블록의 가인수에 대입된다.

```ruby
greeter.call 'Proc'     # "Hello, Proc!" 출력
```

Proc#call의 반환 값은 블록 내에서 마지막으로 평가된 값이다.

```ruby
format = Proc.new {|name|
	name = name.capitalize
	
	"Hello, #{name}!"
}

format.call('alice')				# => "Hello, Alice!"
```



흥미롭고 혼란스럽게도 블록 객체는 proc 메소드나 lambda 메소드를 사용해서도 기술할 수 있다. 또한 `->`가 자주 사용된다. 이 기법에서는 가인수가 있는 경우에는 `->(name)`처럼 기술한다.

```ruby
by_proc    = proc {|name| puts "Hello, #{name}!" }
by_lambda  = lambda {|name| puts "Hello, #{name}!" }
by_literal = ->(name) { puts "Hello, #{name}!" }
```



후.. 비슷한게 너무 많다. 헷갈리지 않는가? [블록 vs 블록 객체 (Proc 객체) vs lambda](https://www.44bits.io/ko/post/ruby-proc-and-lambda) 글에 잘 정리되어있다! 정독 추천!



### 다중 대입

파이썬처럼 다중 대입이 가능하다.

```ruby
a, b = 1, 2

a, b = [1, 2, 3]			# 배열을 사용한 다중 대입(오른쪽에 남은 3은 무시된다.)

a, b, c = [1, 2]			# 대응하는 요소가 없는 c에는 nil이 대입된다.

a, *b = [1, 2, 3]     # *가 있는 b는 오른쪽에서 남은 요소를 배열로 인식해서 대입한다.

a # => 1
b # => [2, 3]
```



 ### 예외

`begin~rescue` 절로 처리한다.

```ruby
begin
	1 / 0
rescue ZeroDivisionError
	puts "어떤 문제가 발생했다."
	
	# 예외 처리
end
```



### 외부 파일 읽기

다른 파일에 있는 프로그램을 읽으려면 require를 이용한다. require는 지정된 파일을 읽어서 실행한다.

require에는 상대경로도 사용 가능하다. 상대 경로를 지정하면 내장 함수가 `$LOAD_PATH`에 등록된 디렉터리에서 파일을 찾는다.

경로가 `./`나 `../`로 시작하는 경우 루비가 실행되고 있는 디렉터리를 기점으로 파일을 찾는다. 또한 파일 확장자는 생략할 수 있다.



### 예약어

루비에는 41개의 키워드가 있다. 이 키워드들은 변수의 이름이나 톱 레벨 상수명으로 사용할 수 없다.

![image-20201209205357716](/Users/humblego/Documents/dev/TIL/Language/Ruby/image1.png)

인스턴스 변수, 클래스 변수, 전역 변수에는 각각 @, @@, $ 등의 접두사가 붙는데, 이 경우에는 예약어를 명칭으로 사용할 수 있다. 하지만 혼란을 초래할 수 있으므로 일부러 사용하지는 말자.



### 내장 변수 및 상수

#### 유사 변수(pseudo variable)

- true, false, nil 이외의 유사 변수는 위치나 구문에 따라 참조하는 값이 달라진다.
- 유사 변수에는 값을 대입할 수 없다.
- 유사 변수 목록은 아래와 같다.
  - `self`: 자신을 가리킨다. 리시버 없이 메소드를 호출할 때는 self가 리시버가 된다.
  - `true`: TrueClass의 유일 인스턴스
  - `false`: FalseClass의 유일 인스턴스
  - `nil`: NilClass의 유일 인스턴스
  - `__FILE__`: 현재 실행 중인 소스 파일
  - `__LINE__`: 현재 실행 중인 행 번호
  - `__ENCODING__`: 현재 소스의 스크립트 인코딩



#### 내장변수

내장 변수는 어디에서든 참조할 수 있지만 실제 스코프가 매우 좁고 참조 위치에 따라서 다른 값을 참조하는 경우가 있다.

아래는 대표적인 루비 내장 변수

- 전역내장변수
  - `$stdout, $>` : 표준 출력. 초기값은 STDOUT
  - `$stderr`: 표준 에러 출력, 초깃값은 STDERR
  - `$stdin`: 표준 입력. 초깃값은 STDIN
  - `$*`: 루비 스크립트에 부여된 인수의 배열 ARGV와 같음.
  - `$/, $-0`: 기본 입력의 줄바꿈 구분을 나타내는 문자열. 기본 값은 \n
  - `$:, $LOAD_PATH, $-I`: 라이브러리를 읽어올 때 탐색 대상이 되는 경로의 배열
  - `$DEBUG`: 해석기가 -d 옵션으로 실행됐고 디버그 모드라면 참 값
  - `$VERBOSE`: 이중화 메시지 플래그. nil이면 경고를 출력하지 않는다. false면 중요 경고만 출력하고 true면 모든 경고를 출력
  - `$PROGRAM_NAME`: 실행 중인 스크립트명
  - `$<`: 루비 스크립트에 부여된 인수 또는 표준 입력으로 구성된 가상 파일. ARGFdhk ehddlf
  - `$FILENAME`: 가상 파일 ARGF의 파일명
- 지역내장변수
  - `$SAFE`: 현재 스레드의 세이프 레벨을 표시하는 정수
  - `$!`: 마지막에 발생한 예외 객체
  - `$@`: 마지막에 발생한 예외의 Backtrace를 표시하는 배열
  - `$$`: 실행 중인 루비 프로세스의 프로세스 아이디
  - `$?`: 마지막으로 종료된 프로세스의 종료 상태
  - `$~`: 마지막으로 성공한 정규 표현 일치에 관한 정보(MatchData 객체)
  - `$1, $2, $n ...`: 마지막으로 성공한 정규 표현 일치에서 n번째 괄호에 있는 일치하는 값(n은 양의 정수)
  - `$+`: 마지막으로 성공한 정규 표현 일치에서 마지막 괄호에 일치하는 값




---

7. 학습 내용에 대한 개인적인 총평

루비. 42seoul 아니었다면 학습해봤을까 싶은 언어입니다. 자바, 자바스크립트 & 타입스크립트 같은 언어에 비해 한국에서의 취업과 조금 거리가 있다고 생각하기 때문이죠. 42seoul 덕분에 이런 '취업가성비'를 생각하지 않고 언어를 학습해볼 기회가 생겼다고 생각하고 잘 학습해봐야겠습니다. 관심가는 당근마켓에서 썼다고 했을 때부터 한번 배워보고 싶긴했어요.

확실히 '인간 중심으로 설계된 언어'여서인지 영어 구어 같은 표현이 되게 많은게 흥미롭습니다ㅎㅎ

---

다음 학습 계획

- 퍼펙트루비 책 정독

