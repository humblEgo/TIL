1. 학습 날짜 // 2020-08-17(월)

2. 학습시간 // 9:00~22:00

3. 학습 범위 및 주제 // C++ 

4. 동료 학습 방법 // -

5. 학습 목표 // C++ module00 진행에 필요한 지식을 얻는다.

---

6. 상세 학습 내용

# CPP Module00

키워드: 클래스, private vs public, 기본입출력

---

### 정적 멤버 변수

정적멤버변수는 클래스 내에서의 전역변수 개념이라고 생각하면 된다. 즉, 하나의 정적멤버변수는 같은 클래스 내의 모든 객체가 공용으로 사용할 수 있다.

정적멤버변수는 해당 클래스명으로 접근해야하며, private 정적멤버변수는 정적멤버함수로 접근한다.

[참고](https://m.blog.naver.com/PostView.nhn?blogId=star7sss&logNo=220809716792&proxyReferer=https:%2F%2Fwww.google.com%2F)

# CPP Module01

키워드: 스트링스트림, const, 참조변수

---


메모리 구조에 대해 간단복습.

프로그램을 만들고 실행을 하면 메모리에 코드들이 올라가 실행된다.

메모리는 아래 두 가지로 나눌 수 있다.

- 물리적 메모리
  - RAM이다. 
  - OS는 프로그램을 실행할 때 필요한 최소정보만 RAM에 저장한다. 이를 Woking set이라고 한다.
  - 주소 데이터들을 일정한 크기의 '블록'으로 쪼개 놓은 것을 **프레임(Frame)**이라고 한다.
- 가상 메모리
  - HDD의 용량에서 가져와서 사용한다.
  - 일반적으로 코드를 실행하면 가상메모리에 적재된다.
  - 주소 데이터들을 일정한 크기의 '블록'으로 쪼개 놓은것을 **페이지(Page)**라고 한다.

프로그램을 실행하면 필요한 데이터 정보를 가상 메모리에서 가져와서 상황에 맞게 물리적 메모리에 맵핑하고, 맵핑을 해제하기를 반복한다. 이를 **페이징 기법**이라고 한다. 페이징 기법으로 맵핑할 때는 같은 크기의 프레임과 페이지를 대응해서 맵핑한다. 너무 작은 데이터 단위로 페이징 기법이 작동하면 CPU에 부담을 주기 때문이다.

![image](https://user-images.githubusercontent.com/54612343/90375774-60231800-e0b0-11ea-83a3-242f2cdf3730.png)

기본 메모리 구조는 위와 같은데, 스택 영역에 적재되는 메모리는 큰 주소값을 시작으로 주소값이 작아지는 식으로 작동하고, 힙 영역에 적재되는 메모리는 작은 주소값을 시작으로 주소값을 증가시키는 식으로 작동한다. 요건 커널 영역에 '버퍼오버플로우'하여 데이터를 조작하는 것을 막기 위함이다. *왜 스택은 아래로, 버퍼는 위로 자라나는가 궁금했는데 요런 이유가 있었다.*

[참고](https://hwan-shell.tistory.com/13)

## stringStream

스트림은 입출력을 추상화해서 나타낸 것이다. 그럼 스트링스트림은? 문자열과 스트림의 기능이 동시에 존재하는 것이라고 보면 편하다.

> 스트림에서 cin(istream)은 사용자로부터 입력받고, ifstream은 파일로부터 입력을 받았다면, 이 stringstream은 문자열로부터 입력을 받는 것이다. 그리고  iostream 클래스를 상속받았기 떄문에, iostream에 있는 모든 함수나 연산자를 다 쓸 수 가 있다. 

이 [링크](https://m.blog.naver.com/kks227/220245263973)를 참고하자.



# const

C++에서도 C와 마찬가지로, const는  상수라는 의미이다. 즉, 데이터의 초기화가 이뤄지면 그 값을 바꿀 수 없도록 해준다. const를 선언한 변수는 '데이터 영역'에 들어가게 되며 컴파일과 동시에 데이터 영역 메모리로 올라가 버린다.

const 함수의 초기화는 1) 선언과 동시에 초기화 해주거나 2) 멤버 이니셜라이저 를 통해 가능하다.

헷갈릴 수 있는 부분을 정리하자면 아래와 같다.

#### 포인터에 쓰일 때 상수화되는 범위

1. `const int *ptr` : ptr 변경 가능, ptr이 가리키는 데이터는 변경 불가
2. `int const *ptr`:  ptr 변경 가능, ptr이 가리키는 데이터는 변경 불가
3. `int *const ptr`: ptr 변경 불가, ptr이 가리키는 데이터는 변경 가능
4. `const int const *ptr` : ptr 변경 불가, ptr이 가리키는 데이터도 변경 불가

#### 함수 파라미터에서 const 참조

함수 안에서 변경을 절대 하지 않겠다는 의미. 혹시 const 없이 &참조만 하면 함수안에서 원본과 같이 변경될 수 있으므로 주의하자.

#### 클래스 메서드 const

메서드를 const로 선언한다면 그 함수 안에서는 mutable로 선언된 변수를 제외하고 아무것도 변경할 수 없다. 보통 get함수 구현할 때 많이 사용한다.

! const 선언여부도 함수 오버로딩의 조건에 해당된다.

---    
    
7. 학습 내용에 대한 개인적인 총평 

C++에서는 C를 이용한 프로그래밍과 다른 점이 많아서 흥미롭습니다. 특히 데이터에 접근하고 수정하는 권한을 다루는 개념이 많은 것이, '객체지향'을 다루는 언어라는 점이 실감납니다. 음미해보면 데이터와 코드를 재사용하면 효율이 늘어나지만, 그만큼 '다양한 시공간'에서 데이터와 코드에 접근하므로 적절히 제한하는 방법이 필수였겠다는 생각이듭니다.

---

다음 학습 계획

- CPP Module01 구현시작