#### 1. 학습 날짜 // 2020-05-07(목)

#### 2. 학습시간 // 13:00~22:00

#### 3. 학습 범위 및 주제 // heroku 배포,

#### 4. 동료 학습 방법 // 슬랙콜, 팀뷰어를 통한 원격 페어 프로그래밍

#### 5. 학습 목표 // 42mate 배포

---

#### 6. 상세 학습 내용

- 클래스 by 클린코드

  - 자료추상화
  - 절차지향적 클래스 vs 객체지향적 클래스
    - (자료 구조를 사용하는) 절차적인 코드
      - 기존 자료 구조를 변경하지 않으면서 **새 함수를 추가하기 쉽다.**
      - **새로운 자료 구조를 추가하기 어렵다.** 이를 위해선 모든 함수를 고쳐야한다.
      - 새로운 자료 타입이 아니라 새로운 함수가 필요한 경우에 더 유리하다.
    - 객체 지향 코드

      - 기존 함수를 변경하지 않으면서 **새 클래스를 추가하기 쉽다.**
      - **새로운 클래스를 추가하기 어렵다.** 그러기 위해선 모든 클래스를 고쳐햐한다.
      - 새로운 함수보다는 새로운 자료 타입이 필요한 경우에 더 유리하다.
  - 디미터 법칙
    - 디미터 법칙은 잘 알려진 휴리스틱으로, 모듈은 자신이 조작하는 객체의 내부 구조를 알면 안된다는 법칙이다.
    - 클래스 C의 메서드 f는 아래 객체의 메서드만 호출해야한다.
      - 클래스 C
      - f가 생성한 객체
      - f 인수로 넘어온 객체
      - C 인스턴스 변수에 저장된 객체

- 오류처리 by 클린코드

  - 오류 코드보다 예외를 사용하라.
    - 여기서 예외란 **프로그램 실행 중에 정상적인 프로그램의 흐름에 어긋나는 이벤트**를 뜻한다.
    - C에서는 if문을 통해 함수를 호출한 즉시 오류를 확인하는 방법을 사용해왔다. 하지만 이 단계는 잊어버리기 쉽고, 호출자 코드가 복잡해진다는 단점이 있다.
    - 이런 이유에서 예외를 지원하는 언어에서는 오류가 발생하면 예외를 던지도록 만드는 편이 났다. 이 경우 함수를 작동시키는 알고리즘과 오류를 처리하는 알고리즘을 분리할 수 있어서 코드 품질까지 더 나아진다.
  - Try-Catch-Finally 문부터 작성하라.
    - try 블록에서 무슨 일이 생기든지 catch 블록은 프로그램 상태를 일관성 있게 유지해야한다.
    - try-catch-finally 문을 시작으로 코드를 짜면 호출자가 기대하는 상태를 정의하기 쉬워진다.
  - 미확인(unchecked) 예외를 사용하라.
    - 여기서 *미확인 예외*는 런타임시 잘못 구현된 코드로 인해 발생하는 예외이다. 명시적인 처리를 강제하지 않는다.
    - Java의 경우 RuntimeException에 포함된 예외들이며, 이외의 예외들은 컴파일 단계에서 확인되는 *확인된(checked) 예외*들이다.
    - 확인된 예외의 단점?
      - 아니, 확인된 예외를 적극 활용하여 런타임 전에 오류를 발견하여 예외를 처리하는 것이 더 바람직하지 않나? 밥아저씨 가라사대, 미확인된 예외를 활용해서도 충분히 안정적인 어플리케이션을 만들 수 있거니와 Java에서 *확인된 예외*는 OCP(Open Closed Principle)를 위반하여 의존성 문제를 야기시키기 때문에 일반적인 어플리케이션에서는 비용이 너무 크다고 한다.
      - 메서드를 선언할 때 메서드가 반환될 예외를 모두 열거해야 하기 때문에 메서드 유형의 일부가 되는 것이 문제다. 때문에 함수 구조상 하위에 속한 함수에서 새로운 예외를 던졌을 때 catch 문이 있는 함수가 상위 3단계쯤 위에 있다면, 그 사이의 모든 함수에 새로운 예외를 정의해줘야하는 문제가 발생한다.
  - 예외에 의미를 제공하라
    - 실패한 연산 이름과 실패 유형도 언급할 것.
  - 호출자를 고려해 예외 클래스를 정의하라.
    - 예외를 분류하는 방법은 많지만 결국 **오류를 잡아내는 방법**에 따라 예외를 정의해야한다.
    - 가령 라이브러리를 호출하는 상황에서 API를 감싸면서 예외 유형 하나를 반환하면 아래와 같은 장점이 생긴다.
      - 예외에 대응하는 방식이 예외 유형과 무관하게 거의 동일해지므로 **처리가 간결해진다.**
      - 프로그램 테스트할 때 API 호출하는 대신 테스트 코드를 넣어주는 방법으로 **프로그램을 테스트하기도 쉬워진다.**
      - 해당 라이브러리와 프로그램 사이의 의존성이 크게 줄어든다.
        - 해당 라이브러리의 설계 방식에 의존하지 않아도 된다.
        - 나중에 다른 라이브러리로 갈아타기도 쉽다.
  - 정상 흐름을 정의하라
    - 클래스나 객체가 예외적인 상황을 캡슐화해서 처리하여 클라이언트 코드가 예외적인 상황을 처리할 필요가 없도록 할 수 있다.
  - null을 반환하지 마라

    - 호출자가 null을 체크할 의무를 주고, null 체크를 빼먹으면 쉽게 NullPointerException이 발생하기 쉽다.
    - 차라리 예외나 *특수사례 객체*를 반환하는 것이 좋다!
      ex)

    ```Java
    List<Employee> employees = getEmployees();
    if (employees != null) {
      for (Employee e : employees) {
        totalPay += e.getPay();
      }
    }
    ```

    getEmployees가 null도 반환할 수 있게 구현되어있어서 null을 체크할 필요가 있었다. 하지만 아래와 같이 getEmployees가 빈 리스트를 반환한다면 코드가 훨씬 깔끔해진다.

    ```Java
    List<Employee> employees = getEmployees();
    for (Employee e : employees) {
      totalPay += e.getPay();
    }

    public List<Employee> getEmployees() {
      if (...직원이 없다면...)
          return Collections.emptyList();
    }
    ```

  - null을 전달하지 마라

**결론: 오류처리를 프로그램 논리와 분리하면 독립적인 추론이 가능해지며 코드 유지보수성도 크게 높아진다.**

---

#### 학습 내용에 대한 개인적인 총평

본과정을 주로 C언어를 사용하다보니 예외를 처리할 때 if문으로 처리해왔습니다. 그러다보니 다른 언어에서 더 나은 방식이 있음에도 기존의 방식을 고수했던 것 같습니다. 클린코드에서 에러처리에 대한 부분을 보았더니 1) 현재 42mate 코드가 객체지향적으로 만들어지지 않은 것 같고 2) 에러처리도 미비한 것을 느낍니다. 이 부분에 대해서는 객체지향에 대해 공부해서 코드에 적용하는 식으로 도전해봐야겠습니다. 42mate 앱을 배포하는데 시간이 많이 걸렸습니다. 많은 것을 자동화해주는 heroku를 이용했는데도 이렇게 어려웠던 것은 database에 대한 개념이 부족해서인데, 이 또한 공부해야겠다는 것을 뼈저리게 느꼈습니다.

---

#### 다음 학습 계획

- 클린코드 한 챕터
- database modeling 공부
