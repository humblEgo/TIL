1. 학습 날짜 // 2020-08-08(토)

2. 학습시간 // 9:00~22:00

3. 학습 범위 및 주제 // mutex_destroy

4. 동료 학습 방법 // -

5. 학습 목표 // mutex_destroy가 undefined behavior를 보이지 않도록 코딩한다. philo_two 코딩도 시작한다.

---

6. 상세 학습 내용

#### 문제) 종료시점에 따라 unlock된 후 destroy되어야할 mutex가 달라진다. 그러나 지금은 그 처리가 되어있지 않다.
#### 해결) 종료시점에 따라 다른 인자를 전달하여 destroy할 mutex 수를 조정한다.

먼저 이걸해야하나 말아야하나 고민이 되었다. 다른 동료들은 이 부분을 신경쓰지 않았기도 하고, 실제로 가시적으로 시스템에 크리티컬하게 영향을 끼치지는 않기 때문이다.
그러나 한번 도전해보고 싶다는 마음에 귀찮음을 무릅쓰고 도전해보았다.

우선 문제상황은 종료시점에 따라 unlock해야할 mutex가 다르다는 점이었고, 이를 잘 파악하는 것부터 시작하였다. 아래처럼 구조화하려했다.

1. arg가 유효하지 않은 경우
    - 뮤텍스가 없음.
2. init_ph_info 실패로 종료되는 경우
    - ensure_unlock_m
    - msg_m
    - finish_dining_m (unlock 후 destroy해야함.)
3. 식사횟수를 체크하는 모니터 쓰레드를 생성하다가 에러가 발생하는 경우
    - ensure_unlock_m
    - msg_m
    - finish_dining_m (unlock 후 destroy해야함.)
4. 철학자 쓰레드가 죽는지 여부를 확인하는 모니터 쓰레드를 생성하다가 에러가 발생하는 경우
    - ensure_unlock_m
    - msg_m
    - finish_dining_m (unlock 후 destroy해야함.)
    - ensure_monitor_unlock_m (**에러가 발생하기 전까지 생성된 생사여부 모니터 쓰레드들에 속한 mutex 모두 unlock하고 destroy해야함.**)
    - 그리고.. 생성된 철학자 쓰레드 수만큼 생성된 여러 mutex들을 모두 unlock한 상태로 만들어야함.
5. 철학자 쓰레드를 생성하다가 에러가 발생하는 경우
    - ensure_unlock_m
    - msg_m
    - finish_dining_m (unlock 후 destroy해야함.)
    - ensure_monitor_unlock_m (**에러가 발생하기 전까지 생성된 모니터 쓰레드들에 속한 mutex 모두 unlock하고 destroy해야함.**)
    - 그리고.. 생성된 철학자 쓰레드 수만큼 생성된 여러 mutex들을 모두 unlock한 상태로 만들어야함.(생성된 모니터 쓰레드 수보다 하나 적음.)
6. died or ate_enough로 정상종료됟 경우
    - 모든 뮤텍스가 닫힐 때까지 기다린다음 destroy를 시작한다.

1,2,3번 케이스는 쉽게 해결했는데, 4,5번이 조금 골치아팠다. 케이스에 따라 생성된 쓰레드 수가 달랐기 때문에 닫아줘야하는 쓰레드 수도 달라졌기 떄문이다.

결국 이를 해결하려면 생사여부 쓰레드를 생성하다가 에러가 발생한 경우와 철학자 쓰레드를 생성하다가 에러가 발생한 경우에 따라 달리 mutex를 닫도록 만들어야했다.
이에 종료 원인이 된 에러유형을 넘버링하여 리턴하는 것을 넘어서, 쓰레드 생성 숫자도 에러유형에 담아서 리턴하도록 하였다. 
가령 -20000~-10000 사이의 에러넘버가 리턴된다면, 해당 에러유형은 'CREATE_MONITOR_PH' 이고, 생성한 쓰레드 숫자는 '에러넘버 - 20000'을 한 값을 통해 구할 수 있도록 하는 식..!
모니터 쓰레드를 생성하다가 에러가 발생하는 경우와 철학자 쓰레드를 생성하다가 에러가 발생하는 경우에 쓰레드 생성 숫자를 달리 구하도록 신경쓰는 것이 좀 귀찮았지만, 그럭저럭 만들 수 있었다.
문제는 코드를 한창 만들고 보니, 너무 코드가 복잡해졌다는 것이다.

이에 다시 코드 구조를 근본부터 바꿀 수 있는지 재검증하였고, 기존에 만들어 놓은 모든 mutex가 닫히도록 wait해주는 함수를 수정하여, 전달한 철학자 쓰레드 수와 모니터 쓰레드 수만큼 mutex가 닫혔는지 확인하도록 만들었다.

---    
    
7. 학습 내용에 대한 개인적인 총평 

mutex를 destroy할 때 unlock한 상태여야한다는 제한을 지키는게 동료평가를 통과하는데는 그리 유의미하지 않으나, 스스로 제한을 걸고 프로그래밍 하는 과정이 재밌었습니다. 다른 동료들의 코드보다 안정성이 있는 코드를 만든 것 같아서 좀 뿌듯하기도 하구요.
특히 에러를 프로그램 전체에 전파시켜서 적절하게 종료하도록 하는 것이 C언어에서는 여간 불편한 것이 아니네요. java나 python에서 에러를 throw하는 기능이 왜 있는지, 그게 얼마나 편리한 것인지 새삼 깨닫게 되었습니다.
하지만 이 과정에서 시간을 너무 많이 쓴 만큼 나머지 진도는 속도를 내서 진행해야겠습니다. 어차피 세마포어할 때는 이때까지 만든 것들을 뜯어고쳐야겠죠..ㅠ

---

다음 학습 계획

- philosopher two, three 구현