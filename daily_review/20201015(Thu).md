1. 학습 날짜 // 2020-10-15(목)
2. 학습시간 // 9:00~22:00

3. 학습 범위 및 주제 // response 클래스 설계
4. 동료 학습 방법 // sanam, yohlee님과 설계하다가 막히는 부분에 대해서 의견을 나눔.
5. 학습 목표 // response 클래스 설계를 위해 response에 대해 학습한다.

---

6. 상세 학습 내용

아래처럼 RFC 내용을 정리하였다.

한번 서버가 리소스를 식별하면, 서버는 요청 메서드로 서술되는 동작을 수행한 뒤 응답 메시지를 반환한다.

응답 메시지는 하단을 포함한다.

1. 응답 상태 코드

2. 응답 헤더

3. 응답 본문(생성되었다면)

## Entity body 와 Message body 의 차이점

> The message-body differs from the entity-body only when a transfer-coding has been applied, as indicated by the Transfer-Encoding header field

기본적으로 둘을 동일하지만 Transfer-encoding을 쓸 경우엔 Entity body의 내용이 변하기 때문에 Message body와 달라진다.

[참고1](<[https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html](https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html)>)

[참고2](<[https://velog.io/@koseungbin/HTTP-Message](https://velog.io/@koseungbin/HTTP-Message)>)

## 응답 엔터티

만약 트랜잭션이 응답 본문을 생성한다면, 그 내용을 응답 메시지와 함께 돌려보낸다. 만약 본문이 있다면, 응답 메시지는 주로 다음을 포함한다.

- 응답 본문의 MIME 타입을 서술하는 Content-Type 헤더

  [MIME란?](<[https://server-talk.tistory.com/183](https://server-talk.tistory.com/183)>)

- 응답 본문의 길이를 서술하는 Content-Length 헤더
- 실제 응답 본문의 내용

## MIME 타입 결정하기

웹 서버에게는 응답 본문의 MIME 타입을 결정해야 하는 책임이 있다. 다음은 MIME 타입과 리소스를 연결하는 여러 가지 방법이다.

### mime.types

파일의 확장자에 대응되는 mime 타입들을 정리한 표로 mime타입을 연결한다. 가장 일반적으로 쓰임.

### 매직 타이핑(magic typing)

파일의 내용을 검사해서 '매직패턴'에 해당되는 패턴이 있다면 그에 대응되는 mime 타입을 연결한다. 느리지만 확장자가 없어도 쓸 수 있다는 장점이 있다.

### 유형 명시(Explicit typing)

특정 파일이나 디렉터리 안의 파일들이 파일 확장자나 내용에 상관없이 어떤 mime 타입을 갖도록 웹 서버를 설정할 수 있다.

### 유형 협상(Typing negotiation)

어떤 웹 서버는 한 리소스가 여러 종류의 문서 형식에 속하도록 설정할 수 있다. 이 때 웹 서버가 사용자와의 협상 과정을 통해 사용하기 가장 좋은 형식(그리고 대응하는 mime 타입)을 판별할 것인지의 여부도 설정할 수 있다.

## 리다이렉션

웹 서버는 종종 성공 메시지 대신 리다이렉션 응답을 반환한다.

웹 서버는 요청을 수행하기 위해 브라우저가 다른 곳으로 가도록 리다이렉트 할 수 있다.

리다이렉션 응답은 3XX 상태코드로 지칭된다.

Location 응답 헤더는 콘텐츠의 새로운 혹은 선호하는 위치에 대한 URI를 포함한다.

1. 영구히 리소스가 옮겨진 경우

   웹 서버는 클라이언트에게 리소스의 이름이 바뀌었으므로, 클라이언트가 북마크를 갱신하거나 할 수 있다고 말해줄 수 있다. 301 상태코드가 이럴 때 쓰임.

2. 임시로 리소스가 옮겨진 경우
   웹 서버가 클라이언트로하여금 새 위치로 리다이렉트하라고 한다. 하지만 리소스 변경이 일시적이므로, 클라이언트가 나중에는 원래 URL로 찾아오고 북마크도 갱신하지 않기를 원한다. 이 경우에 303 See other와 307 Temporary Redirect 상태 코드가 쓰인다.
3. URL 증강
   서버는 종종 문맥 정보를 포함시키기 위해 재 작성된 URL로 리다이렉트한다. 요청이 도착했을 때, 서버는 상태 정보를 내포한 새 URL을 생성하고 사용자를 이 새 URL로 리다이렉트한다. 이렇게 상태 정보가 추가된 URL은 흔히 'fat URL'이라고 한다.
   클라이언트는 리다이렉트를 따라가서, 이번엔 상태정보가 추가된 완전한 URL을 포함한 요청을 다시 보낸다. 303, 307 상태코드가 쓰인다.
4. 부하 균형
   과부화된 서버가 요청을 받으면, 서버는 클라이언트를 좀 덜 과부화된 서버로 리다이렉트 시킬 수 있다. 요건 303, 307 상태코드가 쓰인다.
5. 친밀한 다른 서버가 있을 때
   웹 서버는 어떤 사용자에 대한 정보를 가질 수 있다. 서버는 클라이언트를 그 클라이언트에 대한 정보를 갖고 있는 다른 서버로 리다이렉트할 수 있다. 이런 종류의 리다이렉트를 위해 303, 307 상태 코드를 사용한다.
6. 디렉터리 이름 정규화
   클라이언트가 디렉터리 이름에 대한 URI를 요청하는데 끝에 빗금(/)을 빠뜨렸다면, 대부분의 웹 서버는 상대경로가 정상적으로 동작할 수 있도록 클라이언트를 슬래시를 추가한 URI로 리다이렉트한다.

https://docs.google.com/spreadsheets/d/1GNUoCfloWzp0r27ZsayIxHRwFWTl2l4ZfWlXcVARf98/edit#gid=1684315155

---

7. 학습 내용에 대한 개인적인 총평

너무 완벽하게 모든 흐름을 설계하고 구현하려하다보니 진도가 나가지 않는 것을 느낍니다.
좀 더 애자일하게 구현해보려고 노력해야겠습니다.

---

다음 학습 계획

- response 함수 개발하기
