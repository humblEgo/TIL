1. 학습 날짜 // 2020-09-16(수)
2. 학습시간 // 9:00~22:00

3. 학습 범위 및 주제 // container

4. 동료 학습 방법 // sanam에게 궁금한 점을 물어보며 진행함.
5. 학습 목표 // ft container 과제를 수행하기 위해 필요한 지식을 익힌다.

---

6. 상세 학습 내용

#### 문제: 처음에 begin()을 통해 얻은 첫번째 iterator가 vector에 새로운 인자를 insert를 할 때마다 유효하지 않게 된다

#### 해결:

우선 vector의 동작 방식을 이해할 필요가 있다. vector는 가변배열이긴하지만 인자가 추가될 때마다 새로 공간을 할당해서 그 공간에 값을 채워넣는 식으로 동작하지 않는다. 이런식으로 동작하면 인자가 잦게 추가되는 경우마다 공간을 할당하고 값을 채워넣어야하므로 매우 비효율적이다. 그럼 어떻게 해야 효율적으로 처리할 수 있을까? vector는 미리 일정한 메모리공간을 할당해두고, 인자가 추가되었을 때 미리 할당해둔 메모리에 값을 넣는 전략을 쓴다. 물론 이 경우에도 잦은 insert 등으로 미리 할당해둔 메모리를 넘는 사이즈로 vector가 확장되었을 경우엔, 메모리에 재할당하고 그 메모리에 기존 vector의 데이터들을 복사하는 식으로 작동할 수 밖에 없다.

자 그럼 위 문제는 왜 일어난 것일까? 바로 내가 구현해둔 코드에서는 아래처럼 새로 추가된 인자의 사이즈만큼만 메모리를 할당해서 쓰도록 구현되어있었기 때문이다. 이 경우 insert할 때마다 메모리 전체의 재할당 및 복사가 이뤄지고 결국 기존에 iterator가 가리키고 있던 메모리주소는 유효하지 않은 메모리 주소가 된다.

```cpp
if (new_size > _cap)
      reserve(new_size);
```

아래처럼 코드를 수정하여 미리 더 많은 공간을 할당해둘 수 있도록 하였다.

```cpp
if (new_size > _cap)
  {
  		if (new_size < cap * 2)
					reserve(cap*2);
			else
					reserve(new_size);
  }
```

---

7. 학습 내용에 대한 개인적인 총평

참고할 동료들의 코드를 여러건 비교하다보니 정말 각자의 스타일대로, 각자 원하는만큼 Vector를 구현한 것을 확인할 수 있었습니다. 가령 Vector에서 Allocator를 두번째 인자로 받는 경우를 상정하지 않은 코드가 있는 반면, 꼼꼼하게 그 케이스까지 상정해서 구현한 경우가 있고, 표준라이브러리에서 가져다쓰는 코드의 범위도 다르네요 정말. 제가 원하는 조건대로 A-Z 까지 구현된 코드를 찾을 수 없었고, 필요한 부분은 적당히 응용해서 만들어야하는 상황이 되었다보니 기초가 중요한 이유를 실감했습니다. 다행히 sanam씨가 좋은 깃헙레포를 알려줘서 잘 진행할 수 있을 것 같습니다.

---

다음 학습 계획

- vector 구현 완료
