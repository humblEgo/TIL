#### 1. 학습 날짜 // 2020-06-08(월)

#### 2. 학습시간 // 10:00~22:00

#### 3. 학습 범위 및 주제 // assembly

#### 4. 동료 학습 방법 // sanam씨와 libasm 프로젝트 진행에 도움되는 학습자료링크를 공유함.

#### 5. 학습 목표 // assembly 언어에 대해 이해하고 libasm을 구현한다.

---

#### 6. 상세 학습 내용

**assembly어의 개요에 대해 학습함**

우선 assembly에 대해 감을 잡기 위해 [간단한 예제영상강의](https://www.youtube.com/watch?v=uOIq-P2eQXs&list=PLRx0vPvlEmdAXwJnNtKIVeC27UmwljRYA&index=3)를 참고하여 hello world 예제를 만들었다.

또한 Libasm 과제에 나온 처음보는 용어들에 대해 아래와 같이 정리하였다.

### Assembly_language

어셈블리어(Assembler language)는 [기계어](https://github.com/humblEgo/TIL/blob/master/Language/Assembly/assembly_language.md#%EA%B8%B0%EA%B3%84%EC%96%B4)와 1:1 대응이 되는 컴퓨터 프로그래밍의 저급언어(low-level programming language)이다.
컴퓨터 구조에 따라 사용하는 기계어가 달라지므로, 1:1 대응이 되는 어셈블리어도 각각 다르게 된다.

어셈블리 언어는 오래된 언어이고 잘 쓰이지 않을 것 같지만 두 가지 관점에서 여전히 살아있는 언어이다. 첫째는 보안이라는 관점에서 볼 때 소스가 공개되지 않는 프로그램을 바이너리수준에서 분석하고 이해해야 한다면 디스어셈블 된 코드를 읽어야 하는데, 이때 어셈블리 언어에 대한 이해가 없다면 불가능하다. 둘째는 하드웨어를 직접 제어 하는 부분(드라이버나 운영체제 커널의 특별한 모듈)은 여전히 그 간결성과 편의성 때문에 어셈블리 언어로 코딩을 할 수밖에 없다. 예를 들어 운영체제 소스를 분석해 보면 여전히 소스 중 일정비율은 어셈블리 언어로 코딩되어 있다.

어셈블리 언어는 정해진 표준이 없다. AT&T 방식과 Intel 방식이 대표적으로 쓰인다. 둘 모두 opcode(명령어)와 operand(인자값, 피연산자)로 이루어져있다는 공통점이 있다. 차이점은 아래 표와 같으며 서로 호환되지 않는다.
|항목|AT&T|Intel|
|----|----|----|
|접두사 규칙|레지스터는 `%`, 값은 `$`|16진수 데이터는 `h`, 2진수 데이터는 `b`|
|operands 위치 차이|destination operands가 뒤, source operands가 앞|dest operands가 앞, src operands가 뒤|
|memory operands|`(`와 `)` 사이에 놓음|`[`와 `]` 사이에 놓음|
|접미사 규칙|operands size 등 고유의미가진 접미사 존재|접미사 사용않고 의미있는 문장을 그대로 사용함.|

## 개념

#### 어셈블러

어셈블러(assembler)는 [니모닉 기호(mnemonics)]()를 opcode로 변환하고 메모리 위치와 기타 존재물에 따라 식별자를 다시 분석함으로써 목적 코드를 만들어낸다.

#### 니모닉 기호(mnemonic)

mnemonic의 사전적 의미는 **어떤 것을 기억하는 데 쉽게 하도록 도움을 주는 것, 또는 쉽게 기억되는 성질**이다. 그 어원은 아래와 같다.

> mnemonic 의 어원은 그리스 신화의 기억의 여신 므네모시네(Mnemosyne) 에서 유래 되었습니다. 므네모시네의 자녀인 뮤즈(Muses)는 올림포스 산의 신들의 축제에서 아폴론을 도와 음악을 연주 하였는데, 악보가 없는 세계라 기억력에 의존하여 연주할 수 있었다고 합니다.

어원에서 알 수 있듯이 mnemonic 자체는 꼭 어셈블리어에 대해서가 아니라 기억하기 어려운 것을 기억하기 쉽도록 만드는 모든 개념을 뜻한 것이라고 할 수 있다. 어셈블리어를 설명할 때 쓰이는 mnemonic 기호는 기계어로된 일련의 숫자를 인간이 알아보기 쉽게 영어로 바꾸어준 것을 뜻한다.

#### 패스의 수

어셈블러에는 두 가지 종류가 있다. 실행 프로그램을 만들기 위해 얼마나 많은 패스가 소스를 거치는지에 따라 다르다.

- 1패스(one-pass) 어셈블러: 소스 코드를 한번만 거친다.
- 다중 패스(multi-pass) 어셈블러: 처음 패스들에서 모든 기호와 관련 값들이 포함된 테이블 하나를 만들고 나중 패스들에서 테이블을 이용하여 코드를 만들어낸다.

#### 기계어

기계어는 특별한 변환 과정 없이 컴퓨터가 직접 처리할 수 있는 유일한 언어이다.
아래는 n번째 피보나치 수를 계산하는 32비트 x86 기계어를 표현한 16진 기능의 예이다.

```C
8B542408 83FA0077 06B80000 0000C383
FA027706 B8010000 00C353BB 01000000
C9010000 008D0419 83FA0376 078BD98B
B84AEBF1 5BC3
```

#### 레지스터(Register)

레지스터는 CPU 바로 안에 있는 고속 저장 장소이며 일반 메모리보다 훨씬 빠른 속도로 접근할 수 있다. 프로그램이 실행되면 실행 파일이 메모리에 상주하면서 동작에 필요한 일부 데이터들이 CPU로 전달되게 되는데, 이 때 그 데이터들이 저장되는 곳이 레지스터이다.

기본적인 프로그램 실행 레지스터는 8개의 범용 레지스터와 6개의 세그먼트 레지스터, 프로세서 상태 플래그 레지스터와 명령어 포인터가 있다. 아래는 linux, FreeBSD, macOS 등에 적용되는 [System V AMD64 ABI의 호출규칙](https://en.wikipedia.org/wiki/X86_calling_conventions#x86-64_Calling_Conventions)에 따른 분류이다.

- RSP: 스택 포인터 레지스터. 스택에 push할 경우 -4h, pop할 경우 +4h로 값이 바뀐다(스택은 큰 수의 메모리주소에서 작은 수로 자라나므로 push할 때 빼지고 pop할 때 더해진다고 생각하면 쉽다.)
- RBP: 베이스 포인터 레지스터. RSP에 보조적으로 사용되는 포인터 레지스터이다. 스택을 가리키는데 RSP 하나로도 충분하지만, 프로그램의 오류로 중요한 스택 공간이 망가지는 일을 어느정도 방지하기 위해 쓰인다.
- RSI: source index 레지스터
- RDI: destination index 레지스터

64비트 이전에는 그냥 parameter를 전달했지만, 64비트 체제에서는 레지스터리를 이용해서 parameter를 전달한다. 64비트 체제에서 parameter 전달 방식은 운영체제에 따라 나누어진다. 그 중 리눅스의 경우 아래와 같다.

- RDI: 첫번째 인자
- RSI: 두번째 인자
- RDX: 세번째 인자
- RCX: 네번째 인자
- R8: 다섯번째 인자
- R9: 여섯번째 인자

- RAX: 산술(덧셈, 곱셈, 나눗셈 등), 논리 연산을 수행하며 **함수의 반환값**이 이 레지스터에 저장된다.
- RBX: ESI 레지스터나 EDI 레지스터와 결합될 수 있으며, 메모리 주소를 저장하기 위한 용도로 사용된다.
- RCX: 카운터 레지스터. 주로 반복 명령어 사용시 반복 카운터로 사용된다.
- RDX: EAX와 같이 쓰이고 부호 확장 명령 등에 쓰인다. 큰 수의 곱셈 또는 나눗셈 등의 연산이 이루어질 때, EDX 레지스터가 사용되어 EAX 레지스터와 함께 쓰인다.

---

#### 학습 내용에 대한 개인적인 총평

정보처리기사 필기시험은 겨우 일주일남짓, 마지막 2일 제외하고는 틈나는 시간에 잠깐씩 공부했을 뿐인데 너무 쉽게 합격했습니다; 기초상식을 쌓고, 뭔가 이슈가 있을 때 어떤 개념을 검토해야할지 감을 잡기위해 도전했었는데, 궁금했던 데이터베이스, 협업에 관한 부분을 제외하고는 크게 도움이 되지는 않았네요. 제 역량에 이바지되는 지식이 아니면 과감하게 쳐내야겠다는 다짐을 다시 했습니다.

그런 의미에서 이번 assembly 학습의 경우 또 몰입하다가 너무 깊게 들어가지 않도록 경계해야겠다는 생각이 듭니다. 재밌긴한데 각을 봐서 원하는 학습 범위를 넘는다싶으면 그냥 보너스까지만 구현하고 다음 프로젝트로 넘어가야겠습니다.

---

#### 다음 학습 계획

- libasm 학습
