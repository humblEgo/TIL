1. 학습 날짜 // 2020-09-02(수)
   수
2. 학습시간 // 9:00~22:00

3. 학습 범위 및 주제 // 파이썬 문제풀이
   이
4. 동료 학습 방법 // -
   로
5. 학습 목표 // 파이썬으로 알고리즘 문제풀이를 공부한다.

---

6. 상세 학습 내용

우선 C나 C++과는 정말정말 다르다. 포인터가 없으니 덜 직관적으로 느껴질 수 있지만, 익숙해지면 이것만큼 편한 언어가 없을 것 같다.

[파이썬에서 가장 쉽게 범할 수 있는 10가지 실수들](https://hamait.tistory.com/851?category=79136) 을 보고 시작하면 시행착오를 줄일 수 있다.

# 시간복잡도

파이썬은 언어에 강력한 기능이 내장되어있다. 이런 기능을 가져다쓰기만하면 된다! 42에서는 하나하나 다 구현하느라 얼마나 힘들었는가.. 대신 내가 구현 안하는 대신, 내부동작을 모르기 쉽고, 결과적으로 시간복잡도를 예측하기 어려울 수 있다.

### list 시간 복잡도

| 연산           | 시간복잡도                                                                   |
| -------------- | ---------------------------------------------------------------------------- |
| len(a)         | O(1)                                                                         |
| a[i]           | O(1)                                                                         |
| a[i:j]         | O(k) (i와 j 사이의 요소길이 k만큼)                                           |
| elem in a      | O(n)                                                                         |
| a.count(elem)  | O(n)                                                                         |
| a.index(elem)  | O(n)                                                                         |
| a.append(elem) | O(1)                                                                         |
| a.pop()        | O(1)                                                                         |
| a.pop(0)       | O(n)<br />요런 큐 연산은 느리다. <br />큐 연산 필요하면 deque를 쓰는게 좋다. |
| del a[i]       | O(n)<br />i에 따라 다른데 최악의 경우 O(n)                                   |
| a.sort()       | O(nlogn)<br />최선의 경우 O(n)                                               |
| min(a), max(a) | O(n)                                                                         |
| a.reverse()    | O(n)                                                                         |

### 딕셔너리

| 연산           | 시간복잡도 |
| -------------- | ---------- |
| len(a)         | O(1)       |
| a[key]         | O(1)       |
| a[key] = value | O(1)       |
| key in a       | O(1)       |

### 문자열

슬라이싱이 생각보다 빠르다. 위치를 지정하면 해당 위치의 배열 포인터를 얻게 되며 이를 통해 연결된 객체를 찾아 실제 값을 찾아내는데, 이 과정이 매우 빠르게 진행되므로 대부분의 문자열을 조작할 때는 항상 슬라이싱을 우선으로 사용하는 편이 속도 개선에 유리하다고 한다.

### 정렬

파이썬의 `sorted()`는 팀소트(Timsort)를 사용한다.

팀소트는 '실제 데이터는 대부분 이미 정렬되어 있을 것'이라고 가정하고 실제 데이터에서 고성능을 낼 수 있도록 설계한 알고리즘이다. 개별적인 단일 알고리즘이 아니라 삽입 정렬과 병합 정렬을 휴리스틱하게 적절히 조합해 사용한다.

대부분의 경우 파이썬의 정렬 함수를 사용하는 편이 가장 빠르다. 그 이유는 실제 데이터에 적합한 팀소트를 사용하면서도 CPython으로 신중하게 작성되었기 떄문이다.

| 알고리즘  | 최선               | 평균             | 최악       |
| --------- | ------------------ | ---------------- | ---------- |
| 퀵 정렬   | 빅오메가 (n log n) | 빅세타 (n log n) | O(n^2)     |
| 병합 정렬 | 빅오메가 (n log n) | 빅세타 (n log n) | O(n log n) |
| 팀소트    | 빅오메가 (n)       | 빅세타 (n log n) | O(n log n) |

알고리즘간에 비교를 해보면 팀소트의 장점이 더 돋보인다.빅오메가가 n 복잡도 달성하는게 가능한 이유는 팀소트에서는 이미 정렬되어 있는 경우 비교를 건너뛰기 때문이다.

# 함수 메모

- `string.isalpha()`
  - 문자열이 문자인지 판단
  - ret: bool
- `string.isdigit()`
  - 문자열이 숫자인지 판단
  - ret: bool
- `list = string.split()`
  - **문자열을 쪼개서 list로**. 인자가 비어있으면 공백문자 기준으로 split
  - ret: List
- `string = ''.join(list)`

  - **리스트에서 문자열로 변환**할 때 주로 쓰는 스킬

- `list.sort(key="lambda x : condition1, condition2")`
  - sort에 key 매개변수로 함수주소를 넘겨주면 각 인자에 함수를 적용시킨 데이터를 비교하여 sort한다. lambda 익명함수로 condition1을 만들어서 인자에 적용시키고, 그 결과값이 같으면 condition2를 적용하도록 할 수도 있다.

---

7. 학습 내용에 대한 개인적인 총평

잊을만하면 다시 파이썬을 복습하는데, 이번에는 돈을 아끼지 않고 좋은 책을 사서 학습해보았습니다.
C의 경우 직접 내부동작을 구현해보며 대략 어떤 시간복잡도가 예상되는지 감이 있었습니다.
반면 파이썬에는 내부동작을 추측만하고 있다보니 len 함수라던지, list comprehension이나 string slicing 등의 시간복잡도가 예상되지 않아서 답답했었습니다.
그런데 '파이썬 알고리즘 인터뷰' 책에 자세하게 설명이 되어있어서 앞으로는 좀 더 효율적인 코드를 짤 수 있을 것 같습니다. 역시 좋은 학습자료에는 돈을 아끼지 않는 것이 진리인듯 합니다! :)

---

다음 학습 계획

- 파이썬 알고리즘 공부
