1. 학습 날짜 // 2020-09-14(월)
2. 학습시간 // 9:00~22:00

3. 학습 범위 및 주제 // container

4. 동료 학습 방법 // -
5. 학습 목표 // ft container 과제를 수행하기 위해 필요한 지식을 익힌다.

---

6. 상세 학습 내용

### 디폴트 템플릿 매개변수

템플릿에 디폴트로 매개변수를 줄 수 있다. 기본적인 사용법은 다음과 같다.
`template <typename T, typename Alloc = std::allocator<T> >`
덕분에 만약 allocator가 인자로 들어오지 않았을 때는 기본적으로 표준라이브러리의 allocator를 대입해서 쓸 수 있다.

그냥 `Vector<T> test(10, 20);` 뭐 이런 식으로 쓸 수 있다는 것이다.
만약 다음처럼 모든 템플릿 자료형에 디폴트 형식이 지정되어있다면?
`template <typename T = int, typename Alloc = std::allocator<T> >`
다음처럼 그냥 꺽쇠만쓰면 디폴트 자료형을 사용하게 된다.
`template <>`

### 비타입 템플릿 매개변수

[이 링크](https://m.blog.naver.com/PostView.nhn?blogId=justkukaro&logNo=220989569244&proxyReferer=https:%2F%2Fwww.google.com%2F)에 좋은 예시가 있다.

```C++
template<typename T, int rate>
class Circle
{
    private:
        T r;
    public:
        Circle(T r) : r(r + rate) {}

        T getR() { return r; }
        float getArea() { return r*r*3.14F; }
};

int main(void)
{
    Circle<float, 5> c1(5);
    ...
}

```

비타입 매개변수는 일종의 변수처럼 사용이 가능하다. 디폴트 매개변수를 사용할 수 있다. 다만, 아래 조건들이 충족되어야한다.

1. int, bool만 가능
2. 상수(literal)만 된다. (const도 불가!)

### 인스턴스화와 전문화

템플릿은 컴파일러가 상황에 맞춰서 특정 함수 혹은 클래스를 인스턴스화 시킨다.

> 인스턴스란? 클래스의 정의를 통해 만들어진 객체를 의미한다. 객체랑 인스턴스가 비슷하게 쓰이는데, 엄밀히 말하면 다른 개념으로 받아들여진다. 객체지향 프로그래밍의 관점에서 객체는 클래스 타입으로 선언되었을 때를 의미하는 것이고, 그 객체가 메모리 할당되어 실제 사용될 때를 인스턴스라고 한다.

과거에는 template가 묵시적 인스턴스화를 하지 못하였고 프로그래머가 일일이 명시적으로 해줘야했지만, 지금은 모두 타입추론이 가능하므로 명시적 인스턴스화를 할 필요가 없다.

한편 들어온 특정 타입에 대해서 특별한 경우에 다른 결과를 내고 싶을 경우엔 아래처럼 처리할 수 있다.

```
// 함수 전문화
template<>  // 반드시 빈꺽쇠여야한다.
type name(type a, ...)
{
    syntax;
}

// 클래스 템플릿 전문화
template<>   // 반드시 빈꺽쇠여야한다.
class name(type a, ...)
{
    syntax;
}
```

Vector의 경우엔 이를 통해 생성자 인자를 입력받을 때, allocator가 두번째 인자로왔는지 아니면 int가 두번째 인자로 왔는지 여부를 확인하도록 구현해보았다.

### Template Meta Programing (TMP)

일종의 코딩패러다임 중 하나이다. 컨셉은 template의 생성물은 컴파일 시간에 결정나는 점을 이용하여 미리 계산을 마치고, 항상 시간복잡도를 O(1)로 유지하는 것이다!

하지만 다음 단점들을 가지고 있다.

1. 컴파일 시간에 처리되므로 동적 프로그래밍에 써먹을 순 없다.
2. 연산이 오래걸리는 작업을 선행해야하므로 컴파일이 오래걸린다.
3. 모든 실행과정이 코드에 들어가므로 바이너리 용량이 쉽게 늘어난다.
4. 코드의 가독성이 크게 떨어진다.

---

7. 학습 내용에 대한 개인적인 총평

템플릿을 계속 다루는데 특히 전문화 관련해서 헷갈리는 점이 있어서 복습해봤습니다.
Vector하나만 해도 언제 다 구현할지 감이 잘 안잡히네요.
nakim님를 찾아뵙고 수다를 했는데, 어서 본과정을 패스하고 여러 서비스를 만들어봐야겠다는 생각이 강해집니다. 좀 더 박차를 가해야겠습니다.

---

다음 학습 계획

- vector 구현 완료
