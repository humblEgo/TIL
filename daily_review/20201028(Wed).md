1. 학습 날짜 // 2020-10-28(수)
2. 학습시간 // 9:00~22:00

3. 학습 범위 및 주제 // webserv receiveRequest
4. 동료 학습 방법 // sanam, yohai 님과 토의함
5. 학습 목표 // webserv ReceiveRequest 구현을 완료한다.

---

6. 상세 학습 내용

기존 방식에 readbuffer를 비워내는 경우의 수를 따로 처리해야함을 인지하여 관련 함수를 추가 구현하였다.

결과적으로 아래와 같은 흐름을 가지게 되었다.

1. Client fd로부터 송신 받은 응답을 소켓 Read Buffer로부터 '요청라인부터 헤더들의 끝까지' 읽어낸다.
2. 만약 헤더들을 검사했을 때 바디를 추가로 읽을 필요가 없다면, `MUST_CLEAR` 로 Request 객체의 상태를 바꾼다.
3. 이후 client와의 소켓의 Read buffer를 다 빌 때까지 읽어서 정리한다.
4. 만약 헤더들을 검사했을 때 바디를 추가로 읽을 필요가 있다면, URI이 static_resource를 요청하는 것인지, CGI의 결과값을 요청하는 것인지를 확인한다.



---

7. 학습 내용에 대한 개인적인 총평

협업에 대해서 새삼 깨달은 것이 있습니다. 

**바로 무슨 함수든 예시를 함께 공유할 필요가 있다!** 는 것입니다.

기존에도 팀원들이 프로그램 흐름과 각 함수의 역할, 리턴값 등을 동일하게 이해하도록 하기 위해 신경을 많이 써왔습니다. 이를 위한 일환으로 구글스프레드 시트에 클래스명세서를 작성하고, 함수를 추가로 개발했다면 꼭 기입하기로 협의했죠. 이 과정에서 리턴자료형과 그 내용이 공유됩니다. 그런데 **이것만으로는 부족하다는 것을 깨달았습니다.**

애초에 요청 URI를 파싱해서 route를 특정한 결과 값을 `std::string`으로 하여 주고받기로 sanam과 협의했었습니다. 그러나 슬래시(/)로 시작하는지, 아니면 그 슬래시를 제거하는지에 대해서 명확하게 커뮤니케이션을 하지 않았다보니 이 부분에서 오류가 생겼습니다. 

만약 예시를 들어서 커뮤니케이션했다면 각자의 머릿속에 똑같은 기능이 박혔을 것인데 아쉽습니다. 예시를 드는 것이 조금 귀찮긴 하지만 협업할 때 커뮤니케이션을 줄여내는 가장 좋은 방법인 것을 잊지말아야겠습니다.

---

다음 학습 계획

- receiveRequest 함수 구현 완료

