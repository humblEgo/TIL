1. 학습 날짜 // 2020-12-09(수)
2. 학습시간 // 9:00~22:00

3. 학습 범위 및 주제 // SQL
4. 동료 학습 방법 // eunhkim, sanam, yohai, jujeong님과 팀 회의 및 학습경험 공유
5. 학습 목표 // SQL 첫걸음 독파

---

6. 상세 학습 내용

하단은 'SQL 첫걸음' 책을 읽으며 36장까지 간단하게 메모한 것이다.

[팀 미팅](https://humblego.tistory.com/8)은 링크 내용대로 진행하였다.

## 19장 물리삭제와 논리삭제

데이터베이스에서 데이터를 삭제할 때는 물리삭제와 논리삭제의 두 가지 방법을 고려할 수 있다.

1. 물리삭제: SQL의 DELETE 명령을 사용해 직접 데이터를 삭제하자는 사고 방식.
2. 논리삭제: 테이블에 '삭제플래그'와 같은 열을 미리 준비해두고 삭제할 때 이 삭제플래그를 '삭제'로 만들고, 데이터를 남겨둔다. SELECT 명령을 실행하더라도 '삭제플레그'가 '삭제'로 설정된 행은 제외하고 SELECT 명령을 실행한다.
   - 장점: 데이터를 삭제하지 않기 때문에 삭제되기 전의 상태로 간단히 되돌릴 수 있다.
   - 단점: 삭제해도 데이터 베이스의 저장공간이 늘어나지 않는다. 그리고 데이터베이스의 크기가 증가함에 따라 검색속도가 떨어진다.



## 20장 행 개수 구하기 - COUNT

집계함수는 아래 5개가 대표적이다.

- COUNT(집합)
- SUM(집합)
- AVG(집합)
- MIN(집합)
- MAX(집합)



DISTINCT로 열 내의 중복값을 제거할 수 있다. 중복 여부는 SELECT 구에 지정된 모든 열을 비교하여 판단한다.

ex) `SELECT COUNT(ALL name), COUNT(DISTINCT name), FROM sample1;`

#### 메모

- 집계함수 중 `*`을 인수로 사용할 수 있는 것은 COUNT 함수 뿐이다.

- 집계함수는 집합 안에 NULL 값이 있을 겨우 무시한다.



## 21장 COUNT 이외의 집계함수

..은 별 내용 없으니 생략



## 22장 그룹화 - GROUP BY

집계함수로 넘겨줄 집합을 그룹으로 나눌 수 있다.

ex) `SELECT name, COUNT(name), SUM(quantity) FROM sample1 GROUP BY name;`



한편 내부처리 순서 때문에 아래처럼 WHERE 구에서는 집계함수를 쓸 경우 에러가 발생한다.

`SELECT name, COUNT(name) FROM sample1 WHERE COUNT(name) = 1 GROUP BY name;`

아래처럼 HAVING 구를 쓰자. 그럼 WHERE로 검색하고 HAVING 조건으로 검색하는 2단 구조가 된다.

`SELECT name, COUNT(name) FROM sample1 GROUP BY name HAVING COUNT(name) = 1;`



#### 메모

- 집계함수를 사용할 경우 HAVING 구로 검색조건을 지정한다.
- GROUP BY에 지정한 열 이외의 열은 집계함수를 사용하지 않은 채 SELECT 구에 기술할 수 없다.



## 23강 서브쿼리

서브쿼리는 SELECT 명령에 의한 데이터 질의로, 상부가 아닌 하부의 부수적인 질의를 의미한다.

서브쿼리는 WHERE 구에서 주로 사용된다.

가령 최솟값을 가지는 행을 삭제하고자한다면, 아래처럼 SELECT와 DELETE를 결합시킬 수 있다.

`DELETE FROM sample1 WHERE a = (SELECT a FROM (SELECT MIN(a) FROM sample1) AS x);`



SELECT 는 테이블을 반환하는데 아래 4가지 패턴이 있다.

1. 하나의 값을 반환하는 패턴  --> 요게 스칼라.
2. 복수의 행이 반환되지만 열은 하나인 패턴
3. 하나의 행이 반환되지만 열이 복수인 패턴
4. 복수의 행, 복수의 열이 반환되는 패턴





#### 메모

- SELECT 명령이 하나의 값만 반환하는 것을 '스칼라 값을 반환한다'고 한다. 왜 따로 스칼라 값을 반환하는 SELECT 명령을 특별취급하냐면 서브쿼리로 사용하기 쉽기 떄문이다!
- = 연산자를 사용하여 비교할  경우에는 스칼라 값끼리 비교할 필요가 있다.



## 24강 상관 서브쿼리

부모 명령과 자식인 서브쿼리가 특정 관계를 맺는 것을 '상관 서브쿼리'라고 한다.

```
UPDATE sample1 SET a = '있음' WHERE
  EXISTS (SELECT * FROM sample 552 WHERE no2 = no);
```



## 25강 데이터베이스 객체

데이터베이스 객체(이하 객체)는 데이터베이스 내에 실체를 가지는 어떤 것을 말한다.

객체는 이름을 가진다. 이 때 아래와 같은 제약 사항을 따른다.

- 기존 이름이나 예약어와 중복하지 않는다.
- 숫자로 시작할 수 없다.
- 언더스코어(_) 이외의 기호는 사용할 수 없다.
- 한글을 사용할 때는 더블쿼트(MySQL에서는 백쿼트)로 둘러싼다.
- 시스템이 허용하는 길이를 초과하지 않는다.

#### 스키마

데이터베이스 객체는 스카마라는 그릇 안에 만들어진다. 따라서 객체의 이름이 같아도 스키마가 서로 다르다면 상관없다.

테이블과 스키마는 무엇인가를 담는 그릇 역할을 한다는 점에서 비슷하고, 테이블 안에는 열을 정의할 수 있고, 스키마 안에는 테이블을 정의할 수 있다. 각각의 그릇 안에서는 중복하지 않도록 이름을 지정한다. 이처럼 이름이 충돌하지 않도록 기능하는 그릇을 '네임스페이스'라고 부르기도 한다.

## 26강 테이블 작성, 삭제, 변경

DDL은 데이터를 정의하는 명령으로, 스키마 내의 객체를 관리할 때 사용한다.

#### CREATE로 작성

```
CREATE TABLE 테이블명 (
  열 정의1,
  열 정의2,
  ...
)
```

#### DROP으로 삭제



#### ALTER로 변경

- 시스템을 운용하다 보면 처음에는 한 자리로 충분했던 용량이 부족해질 수 있다. 이 경우 열의 최대길이를 늘려서 대응할 수 있다. `ALTER TABLE sample MODIFY col VARCHAR(30)` 처럼!
- 단, 열의 길이를 줄이는 일은 잘 없다. 기존 데이터의 일부가 잘리며 에러가 생길 수 있고, 열의 최대길이를 줄였다고 해서 실제 저장공간이 늘어나는 경우도 적기 때문이다.
- 열을 추가할 경우 시스템에 별 영향을 안줄 것 같아도 테이블 정의가 바뀌어버리는 일인만큼 꽤 영향을 준다. 적어도 변경한 테이블에 행을 추가하는 INSERT 명령은 확인해야 한다.



## 27강 제약

제약은 테이블에 설정하는 것이다.

#### 메모

- 기본키 제약이 설정된 열에는 중복된 값을 저장할 수 없다.



## 28강 인덱스 구조

인덱스는 데이터베이스 객체 중 하나이다. 

인덱스의 역할은 검색속도의 향상이다. 일반적으로 테이블에 인덱스를 작성하면 테이블 데이터와 별개로 인덱스용 데이터가 저장장치에 만들어진다. 이 때 이진트리로 저장된다. 이진 트리에 중복하는 값을 등록할 수 없어야 이진 검색이 가능하므로, 기본키 제약은 이진 트리로 인덱스를 작성하는 데이터베이스가 많다.



## 29강 인덱스 작성과 삭제

EXPLAN 명령으로 인덱스 사용을 확인할 수 있다. 

SELECT 명령을 실행할 때 인덱스의 사용 여부를 선택한다. 이는 데이터베이스 내부의 최적화에 의해 처리되는 부분이다.



## 30강 뷰 작성과 삭제

#### 뷰

뷰는 테이블과 같은 부류의 데이터베이스 객체 중 하나이다. SELECT 명령은 본래 데이터베이스 객체로 등록할 수 없는데 이를 객체로서 이름을 붙여 관리할 수 있도록 한 것이 뷰이다.

뷰는 테이블처럼 취급할 수 있지만 실체가 존재하지 않는다는 의미로 가상 테이블이라 불리기도 한다.따라서 데이터를 쓰거나 지울 수 있는 저장공간을 따로 가지지 않는다. 고로 SELECT 명령에서만 사용하는 것이 권장된다. INSERT나 UPDATE, DELETE 명령에서도 조건이 맞으면 가능하지만 사용에 주의할 필요가 있다.

한편 뷰는 저장공간 자원을 쓰지 않는 대신 CPU 자원을 사용한다. 즉, 뷰를 조회할 때마다 SELECT문을 실행시킨다.

머터리얼라이즈드 뷰(Materialized View)의 경우 테이블처럼 저장장치에 저장해두고 사용한다. 다만 뷰에 지정된 테이블의 데이터가 변경된 경우에는 SELECT 명령을 재실행하여 데이터를 다시 저장한다.



## 31강 집합연산

UNION: (중복을 제거한) 합집합

- 열 구성이 다른 테이블을 UNION으로 엮을 순 없다. 열을 따로 지정해서 각 SELECT 명령에서 집합의 요소가 될 데이터를 서로 맞춰주면 UNION으로 실행할 수 있는 쿼리가 된다.
- UNION을 쓸 때 ORDER BY는 마지막 SELECT 명령에 지정할 수 있다. 이 경우 ORDER BY 구에 지정하는 열은 별명을 붙여 이름을 일치시킨다.

UNION ALL: (중복을 제거하지 않은) 합집합

INTERSECT: 교집합

EXCEPT: 차집합 (Oracle은 MINUS)



## 32강 테이블 결합

FROM 구에 복수의 테이블을 지정하면 교차결합을 한다. 그럼 곱집합이 구해진다.

이렇게 교차결합으로 계산된 곱집합에서 WHERE문 등으로 원하는 조합을 검색하는 것을 '내부결합(Inner Join)'이라 부른다.

이걸 한번에 해결하는 것이 INNER JOIN 문이다.

`SELECT * FROM 테이블명1 INNER JOIN 테이블명2 ON 결합조건;`

한편 외부결합은 내부결합처럼 교차결합으로 결합 조건을 지정하여 검색한다는 기본적인 컨셉은 같다. 이 때 '어느 한쪽에만 존재하는 데이터행을 어떻게 다룰지'를 변경하는 것이 외부결합이다. LEFT JOIN, RIGHT JOIN이 외부결합에 속한다.



## 33강 관계형 모델

SQL은 관계형 모델에 의해 구축된 데이터베이스를 조작하는 체계적인 명령의 집합이다.

관계형 모델의 용어를 몰라도 딱히 상관은 없다고 하는데, 훑어보자.

1. Relation: SQL의 테이블을 뜻한다.
2. Attribute: SQL에서 말하는 열을 듯한다.
3. Tuple: SQL의 행을 뜻한다.
4. 관계대수: 릴레이션은 튜플의 집합이며 릴레이션에 대한 연산이 집합에 대한 연산에 대응된다는 이론



## 34강 데이터베이스 설계

데이터베이스 설계는 데이터베이스의 스키마 내에 테이블, 인덱스, 뷰 등의 데이터베이스 객체를 정의하는 것을 말한다.

테이블 정의서로 열명,자료형, NULLABLE, 기본값, 논리명 등을 정의하자.

ER 다이어그램으로 관계성을 나타내자.

#### 메모

- 큰 자료형은 LOB(Large object) 형으로 저장가능하다.
- AUTO_INCREMENT를 지정하여 자동증가 열을 만들 수 있따. 이는 PRIMARY_KEY 또는 UNIQUE로 유일성을 지정해야한다.



## 35강 정규화

정규화는 테이블을 올바른 형태로 변경하고 분할하는 것을 뜻한다. 여기서 올바른 형태는 주관적 기준이다.

정규화는 보통 데이터베이스의 설계 단계에서 행해지며 잘 활용하면 효율적인 데이터베이스를 설계할 수 있다.

정규화는 **하나의 데이터는 한 곳에 있어야 한다.**는 규칙에 근거한다. 하나의 데이터가 반드시 한 곳에만 저장되어 있다면 데이터를 변경하더라도 한 곳만 변경하는 것으로 끝낼 수 있다.

일반적인 정규화 순서는 아래와 같다.

1. 제1정규형

   - 반복되는 데이터를 가로(열 방향)가 아닌 세로(행 방향)로 늘리는 것.
   - 중복을 제거하는 방향으로 테이블 분할도 진행한다.
   - 분할한 테이블을 다시 합칠 수 있도록 기본키 지정도 진행한다.

2. 제2정규형

   - 기본키에 의해 특정되는 열과 그렇지 않은 열을 나눈다. 즉, 함수종속성을 찾아내서 테이블을 분할하는 것!

   > 함수종속성: 키 값을 이용해 데이터를 특정지을 수 있는 것

3. 제3정규형

   - 기본키 이외의 부분에서 중복이 없는지 조회한다.



## 36강 트랜잭션

```
START TRANSACTION
COMMIT
ROLLBACK
```

SQL로 여러개의 테이블에 insert하다가 어느 한곳에서 에러가 나고, 이를 취소하기 위해 insert가 성공한 테이블 하나하나에 접근하여 다시 delete하는 상황을 가정해보자. 너무 번거롭지 않은가.

트랜잭션을 사용해서 데이터를 추가한다면 에러가 발생해도 트랜잭션을 롤백해서 종료할 수 있다. 그럼 트랜잭션 내에서 행해진 모든 변경사항을 없었던 것으로 할 수 있다. 아무런 에러가 발생하지 않는다면 변경사항을 적용하고 트랜잭션을 종료하는데, 이 때 커밋을 사용한다.

세트로 실행하고 싶은 SQL 명령은 트랜잭션 내에서 실행시키자.


---

7. 학습 내용에 대한 개인적인 총평

팀 회의를 하며 학습 경험을 공유하는 과정에서 역시나 '내가 몰랐는데 안다고 착각했던 부분'과 '내가 몰랐는데 그 사실을 몰랐던 부분'을 발견할 수 있어서 나름 만족스러웠습니다.

이런게 제가 기대했던 팀 학습의 시너지죠ㅎㅎ 팀원들의 의견이 잘 오가도록 조절해서 끝까지 시너지를 내보고 싶습니다.

---

다음 학습 계획

- SQL 책 독파

