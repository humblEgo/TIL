### JAVA에 대해 알게된 것 기록
소프트웨어 장인을 목표로 하는데 도움이 되는 패턴을 모아둔 책인 '프로그래머의 길, 멘토에게 묻다'에 적혀있는 '잔을 비우다'>'첫번째 언어' 패턴을 실천하기 위해, JAVA의 정석을 정독하고 기억해둘 만한 내용을 적습니다.
'무지를 드러내자'는 생각으로 애매하면 그냥 다 적을 것.

 - [변수](#변수)
 - [연산자](#연산자)
 - [조건문과 반복문](#조건문과-반복문)
 - [배열](#배열)
 - [객체지향언어](#객체지향언어)
 
 ----
 ### 변수
 
  - 상수와 리터럴(constant & literal)
    - 리터럴의 타입과 접미사  
  
    |종류|리터럴|접미사|
    |----|----|----|
    |논리형|false, true|없음|
    |정수형|123, 0b0101, 077, 0xFF, 100L|long 타입이면 L, **int 타입이면 생략(byte와 short타입 리터럴은 없어서 int타입 리터럴 사용)**|
    |실수형| 3.14, 3.0e8, 1.4f, 0x1.0p-1|float타입이면 f, double 타입이면 d(**생략가능**)|
    |문자형|'a','1','\n'|없음|
    |문자열|"ABC","123","A","true"|없음|
    
      리터럴의 접두사와 접미사는 대소문자를 구별하지 않는다. 리터럴에 소수점이나 10의 제고븡ㄹ 나타내는 기호 E 또는 e가 포함되어있어도 실수형 리터럴도 간주된다.
  
      기호 p를 이용하면 실수 리터럴을 16진 지수형태로 표현할 수 있다.
      `ex) 0xp1 = (1*16^0)*2^1 =1.0*2 = 2.0`
    
    - 문자 리터럴과 문자열 리터럴
    
      문자 리터럴은 반드시 ''안에 하나의 문자가 있어야한다. 문자열 리터럴은 ""처럼 공백표시 가능.
   
      원래 String은 클래스이므로 아래와 같이 객체를 생성하는 연산자 new를 사용해야 하지만 특별히 그냥 new없이 정의할 수도 있다. 전자의 경우 일반적인 클래스와 같이 heap 내에 객체 레퍼런스 주소를 가진다. 후자의 경우 heap 내의 string constant pool에 저장된다.
   
      **tip: 덧셈 연산자의 경우, 피연산자 중 어느 한 쪽이 String이면 나머지 한 쪽을 먼저 String으로 변환한 다음 두 Stirng을 결합한다. 문자열 변환할 때 편하다.**
    
    - 정수형
    
      정수형의 선택기준으로 정수값의 범위에 따라 정수형을 선택하여 메모리를 절약할 수도 있지만 이는 선택할 문제다. 
      byte와 short는 표현가능한 크기가 작아서 범위를 넘을 위험에 더 쉽게 노출되고, JVM의 피연산자 스택이 피연산자를 4 byte 단위로 저장하기 떄문에 크기가 4 byte보다 작은 자료형의 값을 계산할 때는 4 byte로 변환하여 연산이 수행된다. 
      따라서 오히려 int를 사용하는 것이 더 효율적이다. **웬만하면 정수쓸 때 int쓰고, int의 표현범위를 넘거나 메모리가 부족할 때 다른 정수형을 선택하자.**      
    
    - 실수형
    
      실수형에서 오버플로우될 경우, 변수의 값은 무한대가 된다, 또한 정수형과 달리 언더플로우(underflow)가 있는데, 이는 실수형으로 표현할 수 없는 양의 최소간보다 작은 값이 되는 경우로, 변수의 값이 0이 된다.
      정밀도 이슈가 있으므로 연산속도의 향상이나 메모리를 절약하려면 float를 선택하고, 더 큰 값의 범위나 더 높은 정밀도가 필요하면 double을 선택하자.
    
   
    - 형변환
      형변형 연산자는 그저 피연산자의 값을 읽어서 지정된 타입으로 형변환하고 그 결과를 반환할 뿐이므로, 피연산자인 변수 d의 값은 형변환 후에도 아무런 변화가 없다.
     
      정수형 --> 실수형으로 변환시
      실수형이 정수형보다 훨씬 큰 저장범위를 갖기 때문에, 정수형을 실수형으로 변환하는 것은 별 무리가 없다. 단, int는 최대 10자리의 정밀도를 요구하는데 반면 float는 10진수로 약 7자리의 정밀도만을 제공하므로, int에서 float로 변환할 때는 정밀도 차이에 의한 오차가 발생할 수 있다. 이럴 땐 double을 쓰자.
     
      실수형 --> 정수형으로 변환시
      소수점이 다 버려짐.
     
      자동형변환(산술변환)
      따로 형변환 지정안했을 때, 컴파일러가 기존의 값을 최대한 보존할 수 있는 타입으로 형변환을 자동적으로 추가하는 것. 값 손실 날 경우 에러 메세지로 알린다.
   
   
----
### 연산자

 - 연산자의 우선순위와 결합규칙
 
   - 산술변환(usual arithmetic conversion)
     두 피연산자의 타입이 일치해야 연산이 가능하다. 컴파일러가 연산 전에 피연산자 타입의 일치를 위해 자동 형변환하는 것을 '산술 변환'이라고 한다.        이 때, 두 피연산자의 타입을 같게 일치시키는 것 외에도 피연산자의 타입이 int보다 작은 타입이면 int로 변환하는 규칙이 적용된다. 이유는 정수형        처리시 int가 효율적이고 오버플로우가 발생할 확률이 낮기 때문이다.
   
 - 산술연산자
 
   - 사칙연산자: `char c1 = 'a' + 1;`의 경우, 리터럴 간의 연산이기 때문에 int로 산술변환되지 않고 char형을 유지한다. 유니코드상에서 소문자를 대문      자로 변경하려면 32를 더하면 된다.
     한편, int간의 나눗셈을 수행하면 결과가 int이므로 소수점이하 값들은 버려진다. 이를 이용하면 실수의 소수점 n번째자리까지만 추출하거나 n번째까지      만 추출하되 n+1번째에서 반올림하도록 처리 가능하다.
     ```
     ex) double pi = 3.141592;
     double shortPi = (int)(pi*1000 + 0.5) / 1000.0;
     ```
   - 나머지 연산자 %: 피연산자로 정수만 허용한다.
   
 - 비교 연산자
 
   - 문자열의 비교
     두 문자열의 **내용**을 비교할 때는, 비교 연산자 '=='대신 equals()라는 메서드를 사용해야 한다. 서로 다른 객체라도 내용이 같으면 equals()는        true를 반환한다. 한편 내용이 같더라도 서로다른 객체라면 '=='로 비교시 false가 나온다.
     대문자 소문자 구분않고 비교할 땐, equalsIgnoreCase() 메서드 활용할 것.
     
 - 논리 연산자
 
   - 논리 연산자 &&, ||, !
     문자는 'a'부터 'z'까지, 'A'부터 'Z'까지도 연속적으로 배치되어 있으므로, 논리 연산자를 통해 문자 ch는 대문자 또는 소문자라는 것을 판별하려면        아래와 같이 연산해서 판별가능하다. 소문자 여부부터 판별하는 것은, 사용자로부터 문자를 입력받을 때 사용자가 대문자보다 소문자를 입력할 확률이        높다고 판단했기 때문.
     `('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z')`
     
   - 대입 연산자 =, op=
     대입 연산자는 연산자들 중에서 가장 낮은 우선순위를 가지고 있기 떄문에 식에서 제일 나중에 수행된다. 연산 진행 방향이 오른쪽에서 왼쪽이다.
     
     대입 연산자의 왼쪽 피연산자를 'lvalue'라고 하고, 오른쪽 피연산자를 'rvalue'라고 한다. rvalue는 변수뿐만 아니라 식이나 상수 등이 모두 가능한      반면, lvalue는 반드시 변수처럼 값을 변경할 수 있는 것이어야 한다.
   
   
----     
### 조건문과 반복문

   - switch-case문
   
     switch 조건식의 결과는 정수 또는 문자열이어야하고, case문의 값은 정수 상수만 가능하며, 중복되지 않아야 한다.
     로그인한 사용자의 등급(level)을 체크하여, 등급에 맞는 권한을 부여하는 방식으로 응용할 수 있다.
     
     tip: 특정 범위의 난수를 구할 경우, `Math.random()` 값을 사용하는데, 이 메서드는 0.0과 1.0 사이의 범위에 속하는 double 값을 하나 반환하므        로, Math.random()에 n을 곱하고, int로 형변환 하면 된다. 
   
   - 반복문
   
     JDK1.5부터 **배열과 컬렉션**에 저장된 요소에 접근할 때 `for( 타입 변수명 : 배열 또는 컬렉션) {}` 형식으로 for문 작성이 가능해졌다. 다만, 이      경우엔 일반적인 for문과 달리 배열이나 컬렉션에 저장된 요소들을 읽어오는 용도로만 사용할 수 있다는 제약이 있다.
     
   - continue문
   
     continue문은 반복문 내에서만 사용될 수 있으며, 반복이 진행되는 도중에 continue문을 만나면 반복문의 끝으로 이동하여, for문의 경우 증감식으로,      while문과 do-while문은 조건식으로 이동한다.
     
   - 이름 붙은 반복문
   
     반복문에 이름을 붙이고, break문에 이름을 지정해 줌으로써 하나 이상의 반복문을 벗어나거나 반복을 건너뛸 수 있다.
     
----
### 배열

   - 배열이란?
   
     Java에서의 배열은 **같은 타입**의 여러 변수를 하나의 묶음으로 다루는 것이다. 여러개의 변수를 선언하는 것과 달리 인덱스에 따른 각 저장공간이        연속적으로 배치된다.
     
   - 배열의 길이와 인덱스
   
     배열의 길이는 0이나 int범위의 양의 정수이어야 한다.
     
     **자바에서는 JVM이 모든 배열의 길이를 별도로 관리**하며, '배열이름.length'를 통해서 배열의 길이에 대한 정보를 얻을 수 있다. 배열은 한번 생      성하면 길이를 변경할 수 없기 때문에, 이미 생성된 배열의 길이는 변하지 않는다. 따라서 '배열이름.length'는 상수다. 즉, 값을 읽을 수만 있을 뿐        변경할 수 없다.
     
     배열의 길이를 변경하는 것은 1) 변경하고자 하는 길이의 배열을 새로 생성하고, 2) 기존 배열의 내용을 새로운 배열에 복사하는 식으로 이루어진다.
     
   - 배열의 초기화
   
     배열 인덱스별로 값을 초기화해주거나, for문으로 초기화하는 방법 외에도 아래처럼 간편하게 초기화 가능하다.
     ```int[] score = new int[]{100, 99, 98, 100, 100}; // 배열의 생성과 초기화를 간편하게!
      int[] score = {100, 99, 98, 100, 100}; // 배열의 선언과 정의를 동시에하는 경우에는 new int[]를 생략 가능! 따로하면 생략 불가```
     괄호 {}안에 아무것도 안넣으면, 길이가 0인 배열이 생성된다.
     
   - 배열의 출력
   
     배열의 모든 요소를 출력하고 싶을 때, print와 for문의 조합으로 출력하는 방법 외에도 Arrays.toStirng()을 사용하면, 해당 배열의 모든 요소를 출      력 가능하다. 단 java.util을 import해와야한다.
     
     한편 C언어에서와 달리, 배열이름을 그대로 출력하더라도 '배열의 주소'가 출력되는 것이 아니라, '타입@내부주소'가 출력된다. 내부주소는 실제주소와      다르므로 딱히 의미있는 정보가 아니다.
     
     예외적으로 char배열은 println 메서드로 출력하면 각 요소가 구분자 없이 그대로 출력된다. println이 원래 그렇게 설계되었기 때문.
     
   - 배열의 복사
   
     방법 1. for문을 통한 복사
     
     1) 새로운 배열을 생성 2) for문 통해 인덱스별 값을 복사 3) 피복사대상 배열의 참조변수에 새로 생성한 배열의 참조변수를 저장한다. 그럼 피복사대      상 배열의 참조변수는 새로 생성한 배열을 가리키게 되고, 기존에 가리키고 있던 피복사대상 배열은 JVM의 가바지 컬렉터에 의해서 자동적으로 메모리에      서 삭제된다. 배열은 참조변수를 통해서만 접근할 수 있기 떄문에, 자신을 가리키는 참조변수가 없는 배열은 사용할 수 없기 때문이다.
     
     방법 2. system.arraycopy()를 이용한 복사.
     
 - String 배열
 
   문자열을 char배열로 다루는 C언어와 달리, Java에는 String클래스를 활용하여 문자열처리를 하는게 보통이다. String 배열은 char배열에 여러 가지 기    능(메서드)을 추가하여 확장한 것이다. 이건 Java가 객체지향개념이 나오고 나서의 언어이다보니, 데이터와 그에 관련된 기능을 하나의 클래스에 묶어서      다룰 수 있게 한 것이라고 볼 수 있다.
   
   char 배열과 String 클래스의 큰 차이 중 하나는 String 객체(문자열)는 읽을 수만 있을 뿐 내용을 변경할 수 없다는 것이다. 변경 가능한 문자열을 다    루려면, StringBuffer 클래스를 사용하면 된다.
   
   한편, Scanner클래스의 nextLine()외에도 커맨드라인을 통해 사용자로부터 값을 입력받을 수 있다.
   
 - 다차원 배열
 
   2차원 배열도 괄호{}를 사용해서 생성과 초기화를 동시에 할 수 있다. 예시는 아래와 같다.
   ```
       int[][] score = {
           {100, 100, 100}
           , {20, 20, 20}
           , {30, 30, 30}
           , {40, 40, 40}
           , {50, 50, 50}
       }
   ```
   이 때, `score.length`는 score가 참조하고 있는 배열의 길이이므로 5이다. 'score[0].length'는 score[0]이 참조하는 배열의 길이이므로 3이다.

 - 가변 배열
 
   2차원 이상의 다차원 배열을 생성할 때 전체 배열 차수 중 마지막 차수의 길이를 지정하지 않고, 추후에 각기 다른 길이의 배열을 생성하여 유동적인 가변 배열을 구성할 수 있다.
   `int[][] score = new int[5][];` 처럼 선언 및 정의하고, 각 행마다 다른 길이의 배열을 생성할 수 있는 것이다.
   
----
### 객체지향언어

 - 객체와 인스턴스
 
   클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화(instantiate)라고 하며, 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스(instance)라    고 한다. 객체는 **속성(멤버변수, 특성, 필드, 상태)**과 **기능(메서드, 함수, 행위)**의 집합이라고 할 수 있고, 클래스는 객체를 정의한 것    이다.
   
 - 인스턴스의 생성과 사용
   
   ```
   Tv t;
   t = new Tv();
   ```
   위 예시처럼 생성할 경우, 다음 단계를 거친다. 
   
   1) 메모리에 참조변수 t를 위한 공간이 마련되고,    
   2) 연산자 new에 의해 Tv클래스의 인스턴스가 메모리의 빈 공간에 생성되고, 동시에 멤버변수는 각 자료형에 해당하는 기본값으로 초기화 된다. 
   3) 이후 대입연산자(=)에 의해서 생성된 객체의 주소값이 참조변수 t에 저장된다. 이때부터 참조변수 t를 통해 Tv인스턴스에 접근할 수 있다.
   
 - 객체 배열
 
   객체도 배열로 다루는 것이 가능하며, 이 때 객체 배열안에는 각 객체의 주소가 저장된다. 이 때 배열과 동일하게 같은 타입의 인스턴스만 저장가능하다.
   
 - 클래스의 또 다른 정의
 
   - 데이터 저장개념은 아래 순서대로 발전해왔다.
   
     1. 변수: 하나의 데이터를 저장할 수 있는 공간
     2. 배열: 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
     3. 구조체: 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
     4. 클래스: 데이터와 함수의 결합(구조체+함수), 변수(데이터)와 함수를 하나의 클래스에 정의하여 서로 관계가 깊은 변수와 함수들을 함께 다룰 수 있      게 했다.
     
   - 사용자정의 타입
   
     Java에서는 클래스가 곧 사용자정의 타입이다. 

 - 변수와 메서드
 
   변수는 **선언된 위치**에 따라 클래스변수, 인스턴스변수, 지역변수의 세 종류로 나뉜다. 클래스 영역에 선언된 멤버변수 중 static이 붙은 것은 클래    스 변수, 붙지 않은 것은 인스턴스변수이다. 멤버변수를 제외한 나머지 변수들은 모두 지역변수이다.
   
   - 인스턴스변수: 클래스 영역에 선언되며 클래스의 인스턴스를 생성할 때 만들어진다. 따라서 인스턴스를 생성해야 사용할 수 있다.
   - 클래스변수: 클래스가 메모리에 올라갈 때 만들어지며 프로그램이 종료될 때까지 유지된다. 따라서 인스턴스를 생성하지 않고도 
     '클래스이름.클래스변수'와 같은 방식으로 사용할 수 있다. 
     만약 public을 앞에 붙이면 같은 프로그램 내에서 어디서나 접근할 수 있는 전역변수의 성격을 가지게 된다.
   - 지역변수: 스코프 내에서만 사용가능하며 스코프를 벗어나면 소멸된다.
   
 - 메서드의 호출
 
   - 메서드의 실행흐름
   
     같은 클래스 내의 메서드끼리는 참조변수를 사용하지 않고도 서로 호출이 가능하지만, static메서드는 같은 클래스 내의 인스턴스 메서드를 호출할 수      없다.
     
 - return문
 
   return문은 현재 실행중인 메서드를 종료하고 호출한 메서드로 되돌아간다. 메서드의 반환타입이 void가 아닌 경우, 반환값이 반드시 필요하며, 조건문을    썼을 때는 조건이 true가 아닌 경우에도 MECE하게 return값이 설정되어있어야 한다.
   
 - JVM의 메모리 구조
 
   응용 프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고 JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어    관리한다. 그 중 주요 영역 3가지를 꼽아보자면 아래와 같다.
   
   1. 메서드 영역(method area)
   
      프로그램 실행 중 클래스가 사용되면 JVM은 해당 클래스의 클래스파일(\*.class)을 읽고 분석하여 클래스에 대한 정보(클래스 데이터)를 이 곳에 저장       한다. 이 때, 그 클래스의 클래스변수도 이 영역에 함께 생성된다.
      
   2. 힙(heap)
   
      인스턴스가 생성되는 공간. 즉, 인스턴스 변수들이 생성되는 공간이다. 
      
   3. 호출스택(call stack 또는 execution stack)
   
      메서드의 작업에 필요한 메모리 공간을 제공한다. 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당되며, 이 메모리는 메서드가 작       업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용된다. 그리고 메서드가 작업을 마치면 할당되었던 메모리공간       은 반환되어 비워진다.
 
 - 기본형 매개변수와 참조형 매개변수
 
   메서드를 호출할 때 매개변수로 지정한 값을 메서드의 매개변수에 복사해서 넘겨준다. 기본형 매개변수는 변수의 값을 읽어올 수 있지만, 참조형 매개    변수는 값이 저장된 곳의 주소를 알 수 있기 떄문에 값을 읽어오는 것은 물론 값을 변경하는 것도 가능하다.
 
   반환타입이 참조형일 경우, 메서드가 '객체의 주소'를 반환하는 것을 말한다.
   
 - 재귀호출(recursive call)
   
   재귀호출은 메서드의 내부에서 메서드 자신을 다시 호출하는 것을 말하며 대부분 반복문으로 구현 가능하다. 반복문에 비해 '매개변수 복사'와 '종료 후 복귀할 주소저장' 등이 추가로 필요하기 때문에 수행시간이 더 걸린다는 단점을 가지고 있지만, 논리적으로 간결하기 때문에 쓰인다.
   
 - 클래스 메서드와 인스턴스 메서드
 
   메서드의 작업내용 중에서 인스턴스변수를 필요로 한다면, static을 붙일 수 없다. 반대로 인스턴스변수를 필요로 하지 않는다면 static을 붙이는 것이 바람직하다. 메서드 호출시간이 짧아지므로 성능이 향상되기 떄문이다. 
   
   같은 클래스에 속한 멤버들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조 또는 호출이 가능하다. 단, 클래스멤버가 인스턴스 멤버를 참조 또는 호출하고자 하는 경우에는 인스턴스를 생성해야한다. (인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만, 클래스멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수도 있기 때문이다.)
   
 - 오버로딩
 
 **한 클래스 내**에 같은 이름의 메서드를 여러 개 정의하는 것이며, 1) 메서드 이름이 같고 2) 매개변수의 개수 또는 타입이 달라야한다. 안그러면 중복 정의로 간주되어 컴파일 에러가 발생한다. 오버로딩된 메서드들 간에는 넘겨주는 매개변수 값의 타입에 따라 하나가 선택되어 실행된다. 
 
 - 가변인자
 
 메서드의 매개변수 개수가 고정적이지 않은 경우를 가변인자라고 한다. 가변인자는 '타입... 변수명'과 같은 형식으로 선언하며, 가변인자 외에도 매개변수가 더 있다면, 가변인자를 매개변수 중에서 제일 마지막에 선언해야한다. 가변인자는 내부적으로 배열을 이용하는 것이므로, 가변인자가 선언된 메서드를 호출할 때마다 배열이 새로 생성된다는 비효율이 있다. 한편 가변인자를 선언한 메서드를 오버로딩하면, 메서드를 호출했을 때 두 오버로딩된 메서드가 구분되지 않아서 컴파일에러가 발생하기 쉽다.
 
 - 생성자
 
 인스턴스변수들의 초기화에 사용되는 조금 특별한 메서드이다. 인스턴스가 생성될 때 호출되어 인스턴스변수들을 초기화할 때 주로 쓰이며, 인스턴스 생성 시에 실행되어야 할 작업을 위해서도 사용된다. 생성자도 메서드처럼 클래스 내에 선언되며, 구조도 메서드와 유사하지만, **리턴값이 없다는 점이 다르다.** 생성자의 조건은 다음과 같다. **1) 생성자의 이름은 클래스의 이름과 같아야 한다. 2) 생성자는 리턴 값이 없다.** 생성자도 메서드이기 떄문에 리턴값이 없다는 의미의 void를 붙여야 하지만, 모든 생성자가 리턴값이 없으므로 void를 생성할 수 있게 한 것이다. 인스턴스를 생성하기위해 사용하는 `클래스이름()`이 바로 생성자인 것!
 
 - 기본 생성자
 
 사실 모든 클래스에는 반드시 하나 이상의 생성자가 정의되어 있어야 하지만, 클래스에 생성자를 정의하지 않고도 인스턴스를 생성할 수 있는 이유는 컴파일러가 제공하는 '기본 생성자' 덕분이다. 컴파일 할 때 소스파일(\*.java)의 클래스내에 **생성자가 하나도 정의되어 있지 않은 경우** 컴파일러는 자동적으로 `클래스이름() { }`과 같은 내용의 기본 생성자를 추가하여 컴파일 한다. (클래스의 접근 제어자가 public인 경우에는 기본 생성자로 `public 클래스이름() { }`이 추가된다.
 
 다음 조건을 만족할 경우, 같은 클래스의 멤버들 간에 서로 호출할 수 있는 것처럼 생성자 간에도 서로 호출이 가능하다.
 ```
 1) 생성자의 이름으로 클래스 이름 대신 this를 사용한다.
 2) 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.
 ```
 2)의 이유는 생성자 내에서 초기화 작업도중에 다른 생성자를 호출하게 되면, 호추뢴 다른 생성자 내에서도 멤버변수들의 값을 초기화 할 것이므로 다른 생성자를 호출하기 이전의 초기화 작업이 무의미해질 수 있기 때문이다. 'this'는 참조변수로 인스턴스 자신을 가리키고, 인스턴스멤버만 사용할 수 있다. 클래스메서드에서는 인스턴스 멤버들을 사용할 수 없는 것처럼, 'this' 역시 사용할 수 없다.
 
 - 생성자를 이용한 인스턴스의 복사
 
 현재 사용하고 있는 인스턴스와 같은 상태를 갖는(두 인스턴스의 모든 인스터스변수가 동일한 값을 갖고 있는) 인스턴스를 하나 더 만들고자 할 때 생성자를 
이용할 수 있다.

 - 변수의 초기화

멤버변수(클래스변수와 인스턴스변수)와 배열은 초기화하지 않아도 자동적으로 변수의 자료형에 맞는 기본값으로 초기화가 된다. 따라서 멤버변수의 초기화는 선택적이다. 하지만 지역변수는 자동초기화되지 않으므로, 초기화가 필수적이다.


 
 
 
 
 
 
