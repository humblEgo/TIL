1. 학습 날짜 // 2020-08-26(수)

2. 학습시간 // 9:00~22:00

3. 학습 범위 및 주제 // C++

4. 동료 학습 방법 // -

5. 학습 목표 // C++ module05를 끝낸다.

---

6. 상세 학습 내용

# CPP Module 05

키워드: try-catch

---

#### ex00

invalid한 점수로 Bureaucrat를 생성하면 `Bureaucrat::GradeTooHighException` , `Bureaucrat::GradeTooLowException` 예외를 던져야한다.

Bureaucrat 네임스페이스에 클래스가 선언되어있다는 말이고, 제출파일에 예외처리 클래스를 만들어둘 별도 파일이 포함되어있지 않으므로, 클래스안에 클래스를 만들어야한다.(중첩클래스)

거기다가 아래 블록에서 예외를 `catchable`하게 만들어야한다. 즉, try문에서 throw하는 예외가 `std::exception `타입의 참조자여야하는 것이다!

```c++
try
{
}
catch (std::exception& e)
{
}
```

아하 그럼 결국 Bureaucrat 클래스에 exception 클래스를 상속한 중첩클래스를 만들어야겠다!

*실제로 C++ 표준에서는 throw 문의 피연산자로 std::exception에서 파생되는 예외 타입을 사용하도록 권장하고 있다고 한다.*

#### exception 클래스?

여러 예외 클래스의 기초 클래스로 사용할 수 있는 exception 클래스를 제공한다. exception 클래스는 시스템에 따라 하나의 문자열 포인터를 반환하는 `what()`이라는 가상 멤버 함수를 제공한다. 가상함수니까 exception 클래스로부터의 유도클래스 내에서 재정의해서 쓸 수 있다ㅎㅎ



#### 생성자 예외검사 시점은?

생성자에서 예외를 throw하도록 만들고자 할 때, 예외검사 시점을 선택해야했다.

1. 멤버 이니셜라이저를 통해 초기화를 하고 멤버변수의 유효성을 검사하여 예외를 throw 하는 방법
2. 인자로 들어온 멤버변수의 유효성을 검사하고 유효하면 멤버변수에 `=`연산자로 값을 대입, 유효하지 않다면 예외를 throw해버리는 방법

처음 구현할 때는 '조기에 유효성을 검사하여 초기화하기도 전에 예외를 throw'하는 것이 가독성, 효율성 측면에서 좋을 것이고, 왠지 멤버이니셜라이저가 다 실행되고 나서 body를 실행하는 단계에서 에러를 throw하는 것이 '잘못하면 좀비객체를 만들 수도 있는거 아닌가?!' 하는 막연한 두려움이 들어서 2번 방법을 선택했다.

그러나 **1번 방법을 추천한다!** 이유는 ex01부터는 `const`멤버변수를 써야하고, 얘네는 선언과 동시에 정의해줘야한다는 특성상 어차피 **멤버이니셜라이저**를 통해서 초기화를 해줘야하기 때문이다. *이니셜라이저를 이용하면 선언과 동시에 초기화가 이뤄지는 형태로 바이너리 코드가 생성되기 때문!* 

그리고 '좀비객체를 만들 수도 있는거 아닌가?!'하는 막연한 두려움은 좀 더 알아보니 기우에 불과했다. 객체 생성이 자체가 아래 세 과정을 정상적으로 완료해야되는데, **3번이 완료되지 않아서 객체가 생성되지 않기 때문이다.**

1. 메모리 공간 할당
2. 이니셜라이저를 이용한 멤버변수(객체)의 초기화
3. 생성자의 몸체부분 실행

아 물론 이니셜라이저 실행시 heap 할당을 한다던가..하는 식으로 설계를 해놓았다면 3번에서 에러가 나더라도 이를 잘 반환하도록 코드를 설계해둬야 메모리릭을 방지할 수 있을 것이다.



#### ex01

- 지금까지는 assign 연산자 오버로딩시에 모든 멤버변수들을 복사시켜줬었는데, 이제는 `const`멤버변수가 포함되어있으므로 불가하다. (*복사생성자에서는 멤버이니셜라이저를 활용해왔으므로 기존방식대로 적용이 가능하다.*) 왜냐면, 처음 선언&정의 이후 변하지 않는 것.. 그것이 const니까!
  assign 연산자 오버로딩시에는 const변수를 제외하고 복사하는걸로  하자.

- signForm 함수에서 실행시키는 beSigned 함수에서 발생한 에러객체를 main함수까지 그대로 throw하고 싶다면? signForm 함수에 구현한 catch구문에서 인자 없이 `throw;`를 해버리면 된다.

#### ex02

- 특별히 새로운 개념은 없고 예외리턴을 고려한 객체설계 관련해서 고민해볼 수 있는 과제이다.
- `ShrubberyCreationForm` 클래스 , `RobotomyRequestForm` 클래스, `PresidentialPardon` 클래스간에 공통된 execute 함수의 예외체크 기능과 예외객체를 `Form`클래스에 구현해버리고, 이를 상속시켜버리자!

#### ex03

- 들어오는 인자에 따라 객체를 만들어리턴하는 `makeForm` 함수를 만들어야한다. 

- 문제는 지금까지는 1차원적으로 **if, else if, else if, else로 이어지는 조건제어문 branching**로 분기를 했지만 `makeForm `함수를 구현할 땐 **이게 금지되어있다**는 것이다. 쓰더라도 if문까지만 쓰고 else if나 else를 쓰면 안된다. 오호 그럼 어떻게 해야할까?🤔

- 객체를 생성하는 함수의 주소를 가지고 있는 '함수포인터배열'을 만들어서 활용하는 것이 좋을 것 같다. if문을 한번 써서 입력된 인자가 함수포인터배열의 어느 인덱스에 위치한 함수주소와 대응되는지 파악하면, 그 함수를 실행하며 결과값을 리턴하도록 하면 된다. *다른 동료들도 비슷하게들 접근했더라*

- 함수포인터 활용의 장점

  - 코드유연성 증가
    - 사용자가 인자, 리턴값을 맞춰서 함수를 정의하여 활용할 수 있도록 하기 때문.
  - 코드의 길이 감소

- 함수포인터 활용의 단점

  - 선언이 복잡하여 가독성이 떨어지기 쉽다.
  - C++의 장점인 inline화 코드가 안된다고 한다.
    - inline화란? 함수를 코드로 직접 대체하는 행위이고, 덕분에 함수 호출 비용이 없어진다. 여러 시점에 inline화가 이뤄지는데 자세한 건 [이 글](https://www.ikpil.com/821)을 참고하자.

  [참고](https://hwan-shell.tistory.com/87)

- 음? 그런데 더 공부해보니 함수객체와 lambda로 함수포인터의 단점을 개선할 수 있는 것 같다. 특히 lambda는 과제에서 금지되어있으니 과제가 끝난 다음에 써보자.

  [참고2](https://hwan-shell.tistory.com/86?category=703822)



---    
    
7. 학습 내용에 대한 개인적인 총평 

이함수포인터를 쓰는 것을 시도하면서, 정확한 숙지없이 클래스 개념과 기존 개념을 합치려고 드니 컴파일에러가 너무 많이 뜨는 것을 경험했습니다.
이런건 확실히 남의 코드를 보고, 책을 보면서 유형을 익히는 것이 빠른 학습법인 것 같네요.
이번 과제는 코드량이 많았고 중간에 구조를 바꾸기도하여서 시간이 좀 걸렸지만, 다음부터는 더 빠르게 과제수행할 수 있을 것 같습니다.

---

다음 학습 계획

- CPP Module06 구현완료