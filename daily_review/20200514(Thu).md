#### 1. 학습 날짜 // 2020-05-14(목)

#### 2. 학습시간 // 10:00~22:00

#### 3. 학습 범위 및 주제 // 스택, 큐 문제 풀이, 클린코드, DB

#### 4. 동료 학습 방법 // -

#### 5. 학습 목표 // 정보처리기사 DB파트 완독, 스택\_큐 문제풀이, 클린코드 1챕터 이상

---

#### 6. 상세 학습 내용

**경계 by 클린코드**

시스템에 들어가는 모든 소프트웨어를 직접 개발하는 경우는 드물다. 아래 예시처럼 외부코드를 사용하기 마련이다.

- 패키지 구매
- 오픈 소스를 이용
- 사내 다른 팀이 제공하는 컴포넌트 사용

따라서 어떤 식으로든 '외부 코드'를 내부 코드에 깔끔하게 통합해야한다.
이 장에서는 *소프트웨어 경계*를 깔끔하게 처리하는 기법과 기교를 설명한다.

#### 외부 코드 사용하기

- *인터페이스 제공자*와 *인터페이스 사용자*의 입장차

  - 제공자: 적용성을 최대한 넓히려 애쓴다. 더 많은 환경에서 돌아가야 더 많은 고객이 구매하니까.
  - 사용자: 자신의 요구에 집중하는 인터페이스를 바란다.

위 입장차 때문에 문제가 생길 소지가 있다.

ex) Java의 java.util.Map은 굉장히 다양한 인터페이스로 수많은 기능을 제공한다. 인터페이스 제공자 입장에서는 기능성과 유연성을 보장해주고 싶었을 것이다. 그런데 인터페이스 사용자 입장에서는 문제가 생길 소지가 있다. 1) 누군가가 Map의 clear() 메서드로 내요을 지울 수 있다. 2) Map에 특정 객체 유형만 저장했더라도, Map은 객체 유형을 제한하지 않으므로, 마음만 먹으면 임의의 Map 사용자가 어떤 객체 유형도 추가할 수 있다. 물론 아래 예시처럼 제네릭스를 사용할 수 있지만, **"Map<String, Sensor>가 사용자에게 필요하지 않는 기능까지 제공한다."**는 문제를 해결하지는 못한다.
`java Map<String, Sensor> sensors = new HashMap<Sensor>(); ... Sensor s = sensors.get(sensorId);` 3) 'Map<String, Sensor>' 인스턴스가 여기저기로 넘겨진다면, Map 인터페이스가 변할 경우 수정할 코드가 상당히 많아진다.

따라서 아래처럼 **경계 인터페이스인 Map을 Sensors 안으로 숨기는 것이 좋다.** 이 경우 제네릭스의 사용 여부는 Sensors 안에서 결정한다. Sensors 사용자는 외부 라이브러리르 어떤 식으로 사용하는지 신경쓰지 않아도 되고, 필요하지 않는 인터페이스를 제공하지 않을 수 있다.

```Java
public class Sensors {
    private Map sensors = new HashMap();

    public Sensor getById(String id) {
        return (Sensor) sensors.get(id);
    }
    ...
}
```

핵심은 Map을 사용할 때마다 캡슐화하는 것이 아니라, **Map 같은 경계 인터페이스를 여기저기 넘기지 않는 것**이다. 공개 API의 인수로 넘기거나 반환값으로 사용하지 않도록 주의하자.

#### 경계 살피고 익히기

사용법이 분명하지 않은 외부 코드를 사용할 때는 아래 두 과정이 필요하다.

1. 외부 코드를 익힘
2. 외부 코드를 통합

이를 위해 보통 아래 3가지 과정을 반복한다.

1. 문서를 읽으며 사용법을 결정하고
2. 우리 쪽 코드를 작성해서 외부 코드가 예상대로 동작하는지 확인한 뒤
3. 우리 버그인지 외부 코드 버그인지 찾아내며 고통 받는다..

그러지 말고 **학습 테스트**를 진행하자! 외부 코드를 사용할 때는 위 3가지 과정을 진행하기 전에 먼저 간단한 테스트 케이스를 작성해서 외부 코드를 익히는 것이다.

프로그램에서 사용하려는 방식대로 외부 API를 호출해보는 것이 포인트이다. 이후 외부코드를 학습 테스트하며 얻은 지식을 바탕으로 필요한 기능을 캡슐화한 뒤 활용하면 된다.

#### 학습 테스트는 공짜 이상이다

이렇게 학습테스트를 진행하면 아래 이점이 생긴다.

- 외부코드가 예상대로 작동하는지 검증 가능
- 통합 이후에도 주기적으로 검증 가능
  - 외부코드의 새 버전이 나오면 학습테스트만 돌려서 차이를 확인하여 호환여부 확인이 가능하다.
  - 호환이 되지 않는다면 코드를 변경할 수 있다.
  - 때문에 낡은 버전을 고집하지 않고 새 버전으로 변경하는 것도 쉬워진다.

> 결론: 경계를 깔끔하게 유지하면 변경 등의 상황에서 비용이 줄어들 수 있다.

- 경계에 위치하는 코드는 깔끔하게 분리하여 관리!
- 기대치를 정의하는 테스트 케이스 작성하여 관리!

---

#### 학습 내용에 대한 개인적인 총평

프로그래머스 사이트에서 문제풀이를 시작했습니다. 우선 재귀 등으로 친숙한 스택을 활용한 문제를 풀었습니다. 익숙한 C 대신 파이썬을 이용해서 문제를 푸니 어색했지만 금방 익숙해지는걸보니 역시 파이썬.. 넘나 쉽고 재밌는 언어입니다. 파이쏘닉한 방법을 남발하다보면 필요이상으로 시간이 소요되는 경우가 있는 것 같아서 관련하여 내용을 정리해둘 필요를 느꼈습니다.
좀 더 체계적으로 글쓰는 습관을 들이기 위해 노션을 활용한 블로깅을 연구해보았습니다. 결과적으로 노션은 개인 노트로 이용하고 블로깅은 깃헙페이지를 통해 진행하기로 결정했습니다. 글쓰기를 통한 성장을 위해 계속 글감을 준비해둘 생각입니다.

---

#### 다음 학습 계획

- 스프링 1강 이상
