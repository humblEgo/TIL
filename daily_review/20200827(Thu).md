1. 학습 날짜 // 2020-08-27(목)

2. 학습시간 // 9:00~22:00

3. 학습 범위 및 주제 // C++

4. 동료 학습 방법 // -

5. 학습 목표 // C++ module06을 끝낸다.

---

6. 상세 학습 내용
   
# CPP Module 06

키워드: 타입변환 연산자

---

기존의 C스타일 형변환은 사용하기 쉽고, 강력한 대신, '의도에 맞지 않는 잘못된 형변환'을 컴파일단에서 잡아줄 수 없다는 문제가 있었다. 
가령 기초클래스의 포인터를 무작정 유도클래스의 포인터로 형변환하는 것이 가능한데, 그 포인터가 참조하는 객체가 기초클래스로 생성된 객체라면 유도클래스에만 있는 멤버함수를 실행하려는 순간 '정의되지 않은 동작'을 할 것이다. 이처럼 문법적으로 오류만 없으면 그냥 컴파일러가 형변환을 해버리니까 런타임에 에러가 발생할 확률이 높아진다. 이런 기존 C스타일 형변환의 문제점을 개선하기 위해 C++에서는 네가지 타입변환 연산자를 제공한다.

## C++의 네가지 타입변환 연산자

C++은 용도에 따라 네가지 타입의 연산자를 제공한다. 이제 개발자는 자신의 의도에 맞는 형 변환 연산자의 사용을 할 수 있고, 컴파일러는 요구한 형 변환이 적절치 않으면(의도에 맞지 않으면) 컴파일에러를 낼 수 있게 되었다!

#### 1. dynamic_cast

상속관계에서의 안전한 형 변환을 뜻한다. 상속관계에 놓여 있는 두 클래스 사이에서, **유도 클래스의 포인터 및 참조형 데이터를 기초 클래스의 포인터 및 참조형 데이터로 형 변환**하는 경우 쓰인다. 

단, 기초 클래스가 **Polymorphic 클래스**인 경우엔 기초 클래스의 포인터 및 참조형 데이터도 유도 클래스의 포인터 및 참조형 데이터로 형 변환하는 것도 가능하다. Polymorphic 클래스는 하나 이상의 가상함수를 지니는 클래스를 뜻한다.

또한 런타임에 안정성을 검사하도록 컴파일러가 바이너리 코드를 추가로 작성한다. 그래서 실행속도가 조금 느려진다.

-  형태: `dynamic_cast<T>(expr)` 
   - T: 변환하고자 하는 자료형의 이름, 객체의 포인터 또는 참조형이 와야함. 
   - expr: 변환대상

#### 2. static_cast

dynamic_cast에서 허용하는 형 변환과 더불어 **기초 클래스의 포인터 및 참조형 데이터도 유도 클래스의 포인터 및 참조형 데이터로 형 변환**할 때와 **기본 자료형 간의 형 변환**에 쓰인다. 물론 이에 따른 책임은 개발자가 진다. dynamic_cast보다 static_cast가 연산속도가 빨라서 둘 다 쓸 수 있는 상황에서 일부러 후자를 쓰는 경우도 많다고 한다.

- 형태: `static_cast<T>(expr)`

#### 3. const_cast

const 선언된 참조자, 포인터의 const 성향을 삭제하는 용도로 쓰인다. const 선언의 의미가 값이 바뀌지 않는 것을 보장해주는 것이었는데 이 연산자 때문에 의미가 반감되는 느낌이다. 특별히 꼭 필요한 경우가 아니면 쓰지 않는 것이 좋다고 한다. 또한 컴파일러 최적화를 제한하는 validate 성향도 제거할 수 있다고 하는데, 이 부분은 솔직히 잘 모르겠다. 쓸 일이 생기면 더 자세하게 파보기로..

- 형태: `const_cast<T>(expr)`

#### 4. reinterpret_cast

전혀 상관없는 자료형으로 형 변환시에 사용된다. **포인터와 관련있는 모든 유형의 형 변환을 허용한다.**

- 형태: `reinterpret_cast<T>(expr)`



## Tips

### ex00

#### 제약사항

- C++ literal value(char, int, float, double)를 표현한 'string'을 인자로 받는 프로그램을 작성해야 한다.
- 프로그램은 1) 리터럴의 유형을 감지하고 2) 올바른 유형의 리터럴을 acquire한 다음**(이 시점에서 더 이상 문자열이 아니게된다.)** 3) char, int, float, double 네가지 유형으로 **명시적으로** 형변환한 뒤 그 결과를 출력하라.
- 10진법만 사용된다.
- char literal value의 경우, non displayble이면 이에 대한 notification을 출력해야한다.
- float literal value의 경우, -inff, +inff, nanf 같은 'pseudo literals'도 처리할 수 있어야한다.
  - Inf: 무한대
  - NaN: Not a number(숫자가 아님)의 약어. 실수나 복소수가 아닌 값을 나타냄.
- double literal value의 경우, -inf, +inf, nan 같은 'pseudo literals'도 처리할 수 있어야한다. 
- **각 cast situation 구현은 'specific cast'를 이용해서 해결되어야한다.**

#### 구현

- 문제 조건을 잘 보면 **1) 리터럴 유형을 감지하고, 올바른 유형의 리터럴 변수에 저장해야한다.** 이 때 오버플로우 에러를 검사하여 flag도 만들어주자.
- 이후에는 **2) 리터럴 변수에 저장해둔 데이터를 다른 리터럴 변수로 변환시켜야한다.** 즉, 최초에 프로그램에 넘겨준 인자의 type에 따라 char에서 다른 자료형들로, int에서 다른 자료형들로, float에서 다른 자료형들로, 그리고 double에서 다른 자료형들로 변환시키는 것이다. charToOther 같은 함수를 만들면 구현이 쉽고 빠를 것 같다.
- **3) 이제 변환하며 생긴 예외들, +-, inf, inff, nan, nanf 등을 신경쓰며 출력해주자. ** 
- char
  - ascii의 non-printable인 경우와 아닌 경우를 주의하자.
  - 처음에는 프로그램에 인자로 `'1'`을 전달하는 경우에 문자 '1'로 인식하여 `char: 1 ` 이런 식으로 출력시켜야한다고 생각했는데, bash/zsh에서 프로그램에 인자를 전달하는 방식 자체를 바꿔야하는 것이므로 패스하였다.
- int
  - 제일 먼저 구현시작. 최초 인자로 받아온 string value를 int로 형 변환해본다. 문제는 static_cast로는 기본자료형간에 형 변환만 지원한다는 것이다. 
  - **`std::stoi()`는 C++11에 추가된 함수여서 사용이 금지되어있다.** 아.. 이런 멀쩡히 있는 함수를 못쓰는거 정말 싫은데.. 하나하나 C++11에 추가된 함수인지 확인하는 것도 귀찮다. 그냥 `std::stringstream`을 이용하거나 c언어에서 문자열->literal 형변환에 쓰이는 함수들을 써버리자.
- float
  - overflow를 확인하려고 아래처럼 코딩했었는데, input으로 들어온 문자가 'char'형이면 바로 double로 변환되지 않아서 에러가 생겼었다. 못생겼지만.. int로 캐스팅했다가 double로 캐스팅하자.
  - 그리고.. float 최소값을 체크하기 위해 `std::numeric_limits<float>::min()`을 쓰면 한없이 0에 가까운 **양수값**이 나온다. 최소값을 찾으려면 **lowest함수를 써야한다.** 이제사 알게되어 좀 부끄러운걸? [참고](https://aker.tistory.com/596)
  - inf, inff, nan, nanf를 모두 받아야하는데, float 변수에 담을 수 있는 값은 아닌 것 같아서 예외로 처리했다.
- double
  - float이랑 거의 동일하다 복붙하고 세세한 것만 바꿔주자.

엄.. 개인적으로 이거 구현하다가 맘이 급해져서 막 코딩해버린 감이 있어서 아쉽다. 좀 더 여유를 가지고 아키텍처를 생각하고 코딩을 시작해야겠다.

### ex01

#### 요구사항

자 딱 봐도 쉬워보이는 과제가 나왔다.

- `void *serialize(void)` : 랜덤한 8개의 알파벳으로 이뤄진 s1, 랜덤한 8개의 숫자로 이뤄진 n, 그리고 다시 랜덤한 8개의 알파벳으로 이뤄진 s2를 heap에 할당하여 그 주소를 반환한다. 이 때 s1, n, s2가 연속된 메모리에 위치해야한다.
- `Data *deserialize(void *raw)` raw에 저장된 serialized data를 세 종류로 나누어서 아래 구조체에 저장한 후 그 주소를 반환한다. `struct Data {std::string s1, int n; std::string s2;}`

#### 구현방향

1. 우선 s1, n, s2를 한번에 저장할 수 있게끔 heap을 할당한다.
2. 할당한 주소에 랜덤한 값을 요구사항에 맞게 넣고, 그 주소를 리턴하여 `void *raw`에 넣는다. 
   - reinterpret_cast를 쓰자!
3. 이후 deserialize에 인자로 `void *raw`를 받아와서 적절히 형 변환하여 data에 넣자.
   - [std::string 생성자](https://modoocode.com/237)를 참고하자.

### ex02

dynamic_cast를 쓰자. dynamic_cast가 성공했을 때와 실패했을 때를 어떻게 구별할지만 찾아보고 맞춰서 구현하면 된다.

---    
    
7. 학습 내용에 대한 개인적인 총평 

ex00을 다른 사람들에 비해 어렵게 접근해서 시간을 너무 많이 써버린 것 같습니다. 과제에서 요구한 것은 1) 인자의 자료형을 탐지해서 그 자료형에 맞게 인자를 저장하고, 2) 다른 자료형으로 그 인자를 변환해서 3) 프린트하라. 는 것이었는데, 괜히 1) 인자의 자료형을 탐지해서 그 자료형에 맞게 인자를 저장하고, 2) 원하는 자료형으로 그 인자를 변환해서 3) 원하는 인자만 프린트하도록 만드는 바람에 시간이 엄청 많이 걸린 것이 원인이었습니다. 다음부터는 좀 더 효율적으로, 과제 요구사항에 맞게 MVP처럼 만들어봐야겠습니다.


---

다음 학습 계획

- CPP Module07 구현완료