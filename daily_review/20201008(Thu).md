1. 학습 날짜 // 2020-10-08(목)
2. 학습시간 // 9:00~22:00

3. 학습 범위 및 주제 // Select함수와 I/O 멀티플랙싱,

4. 동료 학습 방법 // sanam, yohlee님과 팀 회의를 진행함. 학습범위를 나누어 학습 후 서로에게 알려줌.
5. 학습 목표 // 우리가 활용해야할 함수들을 학습한다.

---

6. 상세 학습 내용

## 입출력 다중화(I/O Multiplexing)

멀티 스레드 프로그래밍은 여러 개의 스레드를 만들고, 이들 스레드 간의 문맥을 교환하면서 병렬적으로 데이터를 처리한다. 즉, 작업 교환 단위가 문맥이다. 반면 입출력 다중화는 이 작업 교환 단위를 문맥이 아닌 '파일의 입출력'으로 한 것이다. 네트워크 프로그램의 핵심은 파일(소켓)로부터 읽고 쓰는 것이니, 작업의 교환 단위를 파일 입출력으로 한다고 해서 문제가 되지는 않는다. 입출력을 관리해야 할 파일에 데이터가 있는지를 확인해서, 데이터가 있는 파일을 처리하면 된다.

> 입출력 다중화는 동시처리가 아니다. 멀티 프로세스나 멀티 스레드와 달리 하나의 입력에 대한 응답이 끝날 때까지 다른 입력은 대기해야한다.

구현 방식은 아래와 같다.

1. 입출력을 관리하고자 하는 파일 지정번호의 그룹을 만든다.
2. 관리 파일 그룹에 있는 파일 중 읽을 데이터가 있는 파일이 있는지를 확인해서 반환한다. **운영체제는 관리 파일 그룹에 있는 파일에 데이터 변화가 발생하면 이를 체크해둔다.**
3. 만약 읽을 데이터가 있는 파일이 있다면, 읽기 함수로 데이터를 읽어서 처리한다.
4. 처리 후에는 2번으로 이동해서 2~4번을 반복 수행한다.

### select 함수

리눅스는 select 함수로 입출력 다중화를 구현할 수 있다. 이 함수를 이용해서 **관리할 파일의 그룹을 만들고, 이 중 어떤 파일에 데이터가 입력 혹은 출력되었는지를 확인할 수 있다.**

```c
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);

// params
// nfds: select 함수는 파일의 그룹을 관리한다. nfds는 그룹이 몇 개의 팡리을 포함하는지 알려준다.
// readfds, writefds, exceptfds: fd_set은 '비트 필드'로 소켓에 데이터 변화가 있으면, 해당 소켓에 대응되는 필드에 1을 설정한다.
	// readfds는 읽을 데이터가 있는지 검사하기 위해서, writefds는 쓸 데이터가 있는지 검사하기 위해서 사용하는 비트 테이블이다.
	// fd_set은 1024비트의 크기를 가진다. 즉, 최대 1024개의 파일을 관리할 수 있다.
// timeout: select 함수는 관리하는 파일 그룹에 데이터 입출력 변화가 있을 때까지 기다린다.
	// tiemout 매개변수로 기다릴 제한 시간을 지정할 수 있다. NULL이면 데이터 변화가 있을 때까지 무한정 기다린다. 제한 시간까지 데이터 변환이 없으면 반환한다.
```

**select 함수는 제한시간인 timeout 동안 readfs, writefds, exceptfds에 등록된 파일 중 데이터 변화가 생긴 파일의 총 개수를 반환**한다. 함수가 실패하면 -1을 반환한다.

select 함수에서 쓰이는 비트필드는 필드이지 큐가 아니다. index를 앞에서부터만 접근하는게 아니라 랜덤엑세스가 가능하니 주의할 것. 그리고 소켓 지정번호에 대응되는 필드는 이미 정해져있다.

### 소켓 프로그래밍과 입출력 다중화의 결합

입출력 다중화는 여러 파일의 입출력을 다루기 위해 만들어진 기술이다. 리눅스는 소켓도 파일로 본다. 따라서 소켓에 입출력 다중화 기술을 접목시키면 여러 클라이언트를 함께 다룰 수 있을 것이다.

읽을 데이터가 준비된 소켓이 듣기 소켓이면 accept 함수를 호출하고, 연결 소켓이면 read 함수를 호출하도록하자. 일반적인 구현 시나리오는 아래와 같다.

1. socket 함수 호출
2. bind 함수 호출
3. listen 함수 호출
4. socket 함수로 만든 듣기 소켓 fd를 fd_set에 추가한다.
5. select 함수를 호출한다.
6. 듣기 소켓 혹은 연결 소켓에 읽을 데이터가 들어오면 select 함수는 반환한다.
7. FD_ISSET 매크로 함수로 어느 소켓에 읽을 데이터가 있는지 확인한다.
   - 듣기 소켓에 읽을 데이터가 있다면, accept 함수를 호출해서 클라이언트와 연결한다. 이 때 만들어진 연결 소켓은 fd_set에 추가한다.
   - 연결 소켓에 읽을 데이터가 있다면, read 함수로 데이터를 읽어서 처리한다.
8. 3번으로 돌아간다.

# 의문 & 해답

subject를 분석하며 생긴 의문과 그 해답을 정리해보았다.

## 의문) 클라이언트 다수의 요청을 서버가 처리하는 방법 중 입출력다중화가 우월하다면, 왜 멀티프로세스나 멀티스레드를 이용한 서버도 많을까? 역시 각 방법에 장단이 있겠지. 정확한 내용이 궁금하다!

## 해답) 각 방법별 서버의 장단점은 아래와 같다. 장단점을 보고 상황에 맞춰 사용하자!

### 멀티 프로세스

작업스위칭을 위한 최소 단위가 '프로세스'이다. 연결지향이며 프로세스간 통신이 그다지 필요없거나 안정성이 중요하다면 멀티 프로세스 서버를 고려해보자. 서버 프로그램을 개발하는 유닉스 프로그래머들이 안정성을 중시하고 보수적이다보니 상대적으로 안정적인 멀티 프로세스 서버를 널리 사용한다고 한다.(효율이 떨어질 지언정 안정! 효율이 너무 떨어지면 차라리 서버컴퓨터 대수를 늘려버린다고..)

- 장점

  - 단순하다. 프로그램의 흐름에서 적절한 위치에서 fork 함수를 호출해주면 그걸로 끝이다. 그만큼 에러발생확률이 줄고, 에러발생시 파악도 쉽다. 그리고 상대적으로 빠르게 개발이 가능하다.
  - 안전하다. 각 프로세스가 완전히 독립되므로, 어떤 프로세스가 잘못된 동작을 하더라도 나머지 프로세스로의 영향을 최소화할 수 있다. 오랜 시간 동안 검증된 것도 안전성에 한몫한다.

- 단점
  - 성능이 다른 방법에 비해 떨어진다. 프로세스를 생성하는 것 자체에 큰 비용이 들고, 프로세스 생성시 모든 코드가 복사되므로 성능이 떨어질 수 밖에 없다. **웹서버처럼 연결과 종료가 빈번하면 문제가 생길 수 있다.**
  - 프로세스 간의 통신이 어렵다. 프로세스가 독립되어있다보니 IPC 설비 등으로 통해 데이터 통신을 해야하는데, IPC 설비는 다루기가 쉽지않다.

### 멀티 스레드

작업스위칭을 위한 최소 단위가 '문맥(context)'이다. 웹서비스처럼 1) 연결을 유지하지 않으며 2) 매우 많은 클라이언트를 처리해야한다면 멀티 스레드의 사용을 고민해야한다.

- 장점

  - 응답성이 프로세스에 비해 향상된다. 전체 코드를 복사하는게 아니라 필요한 부분만 스레드 분기해서 활용하면 되기 때문!
  - 상대적으로 자원의 공유가 쉽다. 스레드는 단일 프로세스 위에 올라가니까 복잡한 과정없이 프로세스 자원을 공유할 수 있다.
  - 자원의 효율적인 사용할 수 있게된다. 요즘 컴퓨터나 노트북은 멀티코어가 많은데, 각각 코어의 CPU가 스레드를 담당하게 하기 때문이다. (한 녀석도 빠지지말고 일하게 한다..!) 자원을 공유해서 쓰는 것도 효율성에 한 몫한다.

- 단점
  - 안정성이 상대적으로 떨어진다. 멀티스레드는 하나의 프로세스에서 실행되기 때문에 특정 스레드에서 발생한 문제가 다른 스레드에까지 영향을 끼칠 수 있다.
  - 난해하다. 멀티 프로세스 방식에 비해 코드 흐름을 이해하고 결과를 예측하기 까다롭다. 또한 문제가 발생했을 때 어떤 스레드에서 문제가 발생했는지를 확인하는 작업도 멀티 프로세스에 비해서 까다롭다.

### 입출력 다중화

작업스위칭을 위한 최소 단위가 '파일의 입출력'이다. 채팅 서비스처럼 요청처리에 걸리는 시간이 짧은 서비스에 적당하다.

- 장점

  - **자원효율적이다.** 입출력 다중화는 프로세스나 스레드를 만들지 않고도 여러 소켓을 처리할 수 있다. 자원이 많이 드는 스레드나 프로세스를 생성할 필요도 없기 때문에 일반적으로 멀티 프로세스나 멀티 스레드보다 효율적으로 작동한다.
  - **구현이 상대적으로 용이하다.** 스레드와 프로세스간 데이터 통신을 위한 IPC를 사용할 필요도 없고, 동기화를 위해 고민할 필요도 없다.

- 단점
  - **동시 실행이 아니다.** 때문에 데이터를 읽어서 처리하고 응답하는데 많은 시간이 걸리는 서비스에는 적당하지 않다. 그 시간 동안 다른 입출력은 대기하기 때문이다. 따라서 채팅 서비스 같은 메시지 전달 서비스에는 적합할 수 있으나 서버와 대량의 데이터를 주고받는 파일 전송 서비스, 데이터베이스를 열람해야 하는 정보 서비스에는 부적합하다.
  - 소켓의 변화를 확인하기 위해 **'최대 소켓 지정번호 + 1'만큼을 늘 검사해야하는 단점**이 있다. 비효율의 원인이 될 수 있다.
  - **최대 1024만큼의 동시 접속만을 지원**한다. 때문에 동시에 다수의 클라이언트가 오랜 시간 접속하는 온라인 게임 같은 서비스에는 부적합하다.

다행히 `epoll` 함수를 이용하면 효율성과 접속 제한 문제를 해결할 수 있다고 한다. 하지만 42subject에서는 이 함수를 허용하고 있지 않으므로 추후 학습해보자.

## 질문) 왜 subject에서는 read/write 후에 errno를 활용하지 못하도록 할까?

## 해답) read/write 오류케이스를 errno 없이 구별해내도록 유도하는듯하다.. 자세한건 직접 구현해보면서 느껴봐야할듯.

select는 소켓 버퍼에 데이터가 남아 있으면 fd_set을 1로 둔다. 그러므로 read 함수로 소켓버퍼를 비우지 못했다면, 버퍼를 비울 때까지 여러번 select를 호출하고 read를 다시 호출하는 식으로 비효율이 발생된다.

이런 비효율을 막기 위해 버퍼를 비울 때까지 read를 호출할 수 있지만, 소켓 데이터를 모두 비운 다음 read 함수가 계속 입력을 기다리는 상태-일종의 blocking 상태-가 될 수 있어서 문제가 된다.

이걸 막기 위해서는 **소켓을 'non-blocking'이 되게 해야한다.** 그럼 read 함수 호출시 데이터가 없더라도 바로 반환된다! 단, 데이터가 없어서 반환할 때도 -1을 반환하기 때문에 소켓에 정말 에러가 생겨서 -1을 반환했는지, 아니면 읽을 데이터가 없어서 반환했는지를 구분해서 처리해야한다. **이 때는 errno를 사용하여 구분한다는데.. 42 subject에서는 read/write 후에 errno를 활용하는 것을 엄격하게 금지했다. 흠.. 따로 방법을 찾을 것.**

참고로 fcntl 함수는 소켓을 non-blocking이 되게 하는데 쓰인다. subject에서 fcntl 함수에 쓸 수 있는 flag를 따로 명시해뒀으니 주의할 것!

하단은 yohlee님이 정리해주신 내용이다.

[참고 1 입출력함수](https://valueelectronic.tistory.com/224)
[참고 2 네트워크프로그래밍](https://dgkim5360.tistory.com/entry/beej-guide-to-network-programming-translation-part-1)

```C
#include <sys/types.h>
#include <sys/socket.h>

ssize_t send(int sockfd, const void *buf, int len, int flags);
// sockfd: 목적지의 socket file descriptor. socket()이나 accept()의 리턴값이 사용된다.
// buf: 보내고자 하는 데이터를 가리키는 pointer
// len: 보내고자 하는 데이터의 byte 길이
// return value: 실제 보내진 데이터의 byte 길이.
// return 값이 len 보다 작을 수 있음 - 이 때의 처리가 필요함 (모든 패킷이 전송되지 않았다는 것이다.) 무조건 buf의 길이와 len의 길이가 같아질 때까지 반복문을 돌던가 해야할듯.

ssize_t recv(int sockfd, void *buf, int len, int flags);
// len: 버퍼의 최대 byte길이
// return value: 받은 데이터를 읽어 buffer에 넣은 byte 길이 반환.
//(오류: -1 리턴, errno에 오류값을 넣어줌. 0이 반환되면 상대방이 연결을 끊었다는 의미임.)
```

- sendto()와 recvfrom()은 Dgram(Data gram-style)으로, 원격 host와 연결되어 있지 않은 상황에서 사용된다.
- 위 두 함수는 UDP 통신에서 주로 사용되는 듯 하다. connect()가 되지 않았을 때 사용하는듯..? 허용함수에 없는 내용이니 넘어가자.

#### MSG_PEEK 옵션 (recv 함수에만 존재)

- 입력 버퍼에 수신된 데이터의 존재 유무를 확인한다.
- 큐에서 데이터를 제거하지 않고 받는 큐의 시작에서부터 데이터를 반환받기 위해 사용함.
- 이 옵션을 사용하지 않으면 recv 함수 호출 이후 바로 버퍼에서 데이터가 사라지지만, 이 옵션을 사용하면 버퍼에 읽어들인 값이 보존됨.
  - 근데 0(EOF)가 리턴될 때 까지 로컬 버퍼에 수신버퍼의 값을 strjoin 해주면 되는 거 아닌가..? 왜 MSG_PEEK으로 수신버퍼 메모리를 할당하지 않고 미리 메세지를 확인해야 하는건지 모르겠다.

#### recv와 send, read와 write

- recv와 send, read와 write는 대체로 비슷하지만 recv/send에서는 플래그 등 다른 옵션을 사용할 수 있기 때문에 더욱 전문적이고 강력하다는 장점이 있다.
- 하지만 recv와 send는 소켓에서만 작동한다. 예를들어 USB 포트 등 다른 입출력장치에 사용하기 위해서는 read/write를 사용해야 한다.

---

7. 학습 내용에 대한 개인적인 총평

팀 학습을 하면 좋은 점이, 자신이 학습한 내용을 타 팀원에게 알려주는 과정에서 내가 몰랐던 부분을 인지하게되고 그 부분을 채울 기회가 생긴다는 것입니다. 그리고 애매한 부분에 대해서 팀원들과 논의했을 때 생각지 못한 답을 얻을 수 있는 점이 정말 짜릿한 것 같습니다.

---

다음 학습 계획

- 클래스 설계
