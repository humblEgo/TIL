## C언어에 대해 기록
역량있는 개발자가 되기 위해, 하드웨어에 관한 내용도 포함하여 C언어를 조금 더 깊이있게 학습합니다. 이를 위해 최호성 강사님의 '독하게 시작하는 C 프로그래밍' 강의를 수강하며 배운 점을 기록합니다.

목차
 - [자료형](#자료형)
 - [표준 입/출력 도구](#표준-입출력-도구)
 - [연산자](#연산자)
 - [배열](#배열)
 - [함수](#함수)
 - [포인터](#포인터)



----
### 자료형
 - 정의: **일정 크기(길이)의 메모리**에 저장된 정보를 **해석하는 방법**
   - 자료형의 유무가 B언어와 C언어간의 승패를 갈랐다고 합니다.


#### 상수의 종류
 - 리터럴 상수
   - 문자 상수: 영문자나 특수문자를 기술한 상수
   - 문자열 상수: 문자 상수들의 연속된 집합체를 표현한 상수. 다른 상수들과 달리 여러 개가 한 덩어리를 이룬 배열이며 '주소'로 식별될 수 있음.
   - 정수 상수
   - 실수 상수
 - 심볼릭 상수
   - 형한정: const 형한정어를 이용해 선언 및 정의되는 상수
   - 전처리기: #define 전처리기로 선언 및 정의되는 상수
   
 
 #### 보수를 이용한 뺄셈 연산과정
  - 8비트의 표현 범위를 이용하여, 보수를 더하는 방식으로 감산함.
  EX) 4에서 2를 뺄 경우, 00000100<sub>(2)</sub> 에 2의 '2의 보수'인 11111110<sub>(2)</sub>를 더한다. '2의 보수'는 보수를 구하려고 하는 정수를 각 자리수를 0은 1로, 1은 0으로 바꾸어 '1의 보수'를 구하고, 1을 더하여 구한다.
 
 
#### 부동소수점
실수형식은 근본적으로 근사값 처리로 인한 **오차**를 가지고 있다.
 - float: 32비트 단정도 형식, **유효 자릿수는 소수점 이하 6자리**, 정확도가 떨어지므로 메모리 이슈 없으면 웬만하면 실수표현할 때 double쓰는게 나음. 
 - double: 64비트 배정도 형식 **유효 자릿수는 소수점 이하 15자리**
 - long double: 특수정도 형식, 지원 안하는 컴파일러가 많음. 정확성이 많이 요구될 때, 80비트로 구현됨.
 
 
#### 문자열
문자열의 본질은 배열이다. 즉, 문자열 == (상수화된) 문자(배)열.
 - 초기화하면 마지막 null 값까지 포함하여 메모리에 저장된다.--> 문자열 크기를 12로 선언했으면, 11개까지 써야한다. 만약 12개를 넘기면 Buffer Overflow 문제가 발생하고, 프로그램 Crash가 나면 Buffer Overrun 문제가 발생할 수 있다. 이를 막기 위해 **'경계검사'**를 꼭 해야한다.

#### 메모리에 대한 기본 이론
 1. 32비트 플랫폼에서 주소의 길이는 32비트이며, 16진수로 표시한다. 그리고 주소의 범위는 0x00000000번지부터 0xFFFFFFFF번지까지이며, 모두 연이어져 있는 선형 메모리이다.
 2. 자료형은 일정 크기의 메모리를 해석하는 방법이고, 변수는 해서갛ㄹ 대상 메모리에 붙인 이름이다.
 3. 0번지~64kb 영역의 메모리는 운영체제가 사용하고 있다.
 4. 스택이든, 힙이든, 실행 코드 영역이든 모두 선형 메모리 위에 일렬로 존재한다.

#### C언어 코딩 컨벤션
헝가리안 표기법은 찾아보니 구시대의 유물이라는 의견이 많은듯 하여, [링크 블로그를 참고하여 개발할 예정](https://tttsss77.tistory.com/64)

----
### 표준 입출력 도구

 - 특기할 내용
   - 레이어별로 하드웨어(H/W), 커널(Kernel), 유저(User)로 나누었을 때, 입출력은 항상 **커널에서** 이루어진다.
   - 커널<-->하드웨어간에는 '드라이버'로, 유저<-->커널간에는 유저모드에서 접근할 수 있도록 추상화된 'File'로 정보를 주고 받는다. 이 때 정보는 규칙(Protocol)에 입각하여 작성된다.
   ex) 커널의 프로토콜인터페이스와 정보를 주고받는 파일은 'Socket'이다
   - Buffer는 Memory이며, 미리 자료를 복사 받아서 자료를 주고받는 것이 끊기는 등의 충격을 완화하는 역할을 한다. 만약 버퍼를 거치지 않는 경우 DMA를 한다고하며 버퍼를 통하는 것보다 빠르다. 참고로 getchar()나 scanf(), gets() 같은 함수는 Buffered I/O를 한다. 각각 정보를 가져온다는 점에서 동일하고, getchar()는 한글자씩, gets()는 한줄씩, scanf()는 내용을 출력타입에 맞게 변환하여 가져오는 차이가 있다. 단, gets()는 심각한 보안결함이 있어서, gets_S()를 써야한다.

   - 입력가변 길이 처리할 경우, UI단계에서 길이 제한을 하거나 연결리스트 등 가변가능한 자료구조를 써서 대응하는게 좋음.

----
### 연산자

#### 연산의 우선순위
 - 식이 있을 때, 연산 우선순위에 따라 먼저 계산되는 값은 임시저장 된다(메모리에 저장된다) 이후 계산이 진행되며 값이 구해지면 임시저장된 값은 삭제된다. 즉, 당연하지만 필요하다면 유실전에 따로 저장해야한다.

#### 단순대입
<pre>
int a;
a = 10;
</pre>
위와 같은 코드가 있다면, a는 l-value(left + location value)이고, 10은 r-value(right value)이다. l-value에는 원래 쓰레기값이 있고, 이후 r-value가 copy & overwrite가 진행된다.

#### 이형자료 간의 연산 및 형승격
'표현 범위'가 큰 형식을 따라간다. 즉, `printf("%f",5/2)` 요런 코드를 소수점 아래까지 표시하려면, 5나 2 중 하나를 double로 형변환 해줘야한다.
 

#### Sizeof() 연산자
sizeof(자료형)으로 쓰고, CPU가 아닌 **컴파일러**가 수행하는 연산이다. 따라서, 많이 이용한다고 해도 CPU의 부하가 증가하지 않는다(성능에 영향을 주지 않는다). 단, 컴파일러마다 크기가 달라지는 자료형도 있어서 값이 달라질 수 있다.

#### 실수의 연산
결론부터 말하자면 실수는 **상등이나 부등 연산을 수행하면 안된다.** 부동소수점의 근사처리로 인한 오차가 이슈가 되어 상등이 아닌데 상등이라고 나오거나 부등이 아닌데 부등이라고 나오는 경우가 왕왕생긴다. 대신 비교연산은 수행해도 된다.

--> 이런 특성은 switch case 구문 작성시 case 다음에 실수가 아니라 정수를 적는 것으로 이어진다. case 구문 내에서 상등연산이 이뤄지는데, 실수는 상등연산시 오류가 발생할 수 있기 때문이다.

#### if문 관리
다중 if문의 경우, 경우에 따라 논리적으로 단순명쾌할 수 있지만 불필요한 연산이 수행된다는 점에서 성능하락 이슈가 있다. 따라서 결과값을 내기까지 판단해야하는 조건을 최소화하는 것이 성능향상에 좋으며, 그런 의미에서 다중 if문과 머신차원에서 거의 동일한 연산이 수행되는 switch-case도 가급적 없애는게 좋다. 왠만하면 2분할 방식으로 논리구조를 짜고, 고성능을 요하는 상황에서는 lookup-table을 이용하는 것도 고려하자.

#### goto문 관리
goto문은 스파게티 코드를 만드는 주범으로 사용이 지양되고 있지만, error 처리할 때는 쓰이곤 한다.

#### continue문 관리
소스코드 정적분석 했을 때, knot이 늘어나서 코드가 복잡해지므로, 가급적 쓰지 않는 것이 좋음.

----
### 배열
배열은 여러 인스턴스가 모여 한 덩어리를 이룬 것이다. 

#### 배열의 이름
배열의 이름은 그 자체로 주소를 뜻하며 정의하자면 **여러 요소를 대표하는 첫 번째 요소의 메모리 주소에 부여하는 식별자**이다. 즉, 0번째의 메모리 주소에 이름을 넣기 마련이다. 
한편 문자열의 경우, (상수화된)문자(배)열 이므로 본질은 배열인데 이름이 없다. 때문에 문자열은 이름이 아닌 주소로 식별하게 되어있다. 
배열은 여러 인스턴스가 모여 한 덩어리를 이룬 것이므로, 배열의 이름(식별자)이 하나라고 한개의 변수 다루듯 다루면 에러가 나게 쉽다.

#### 문자열의 성격
문자열은 '가변'길이가 되는 경우가 많고, 배열은 기본적으로 '고정'길이이다. 문자열의 가장 마지막 단어 이후엔 null 이 들어가서 '사용된 영역'과 '사용되지 않은 영역'간의 구분자가 되어준다.

#### 다차원 배열
배열의 배열을 뜻하며, 메모리의 실제모습과 상관없이 논리구조가 2차원 혹은 3차원인 배열을 뜻한다. 즉, ㅈ료의 접근방법에 한정되는 것이다.

예를 들어 `char aData[3][4]`면 논리적으로 따지면 aData 이름의 배열이 3행 4열 형태로 있다고 말할 수 있다. 물론 컴퓨터의 메모리는 1차원적으로 되어있으므로, 엄밀히 따지자면 char[4] 배열을 요소로 3개 가지고 있는 배열의 구조로 되어있다. 때문에 인덱스를 `aData[0][4]`처럼 범위를 넘게 입력하면, `aData[0][0]`을 기준으로 4인덱스 만큼 떨어져 있는 'aData[1][0]'을 참조하는 오류가 발생한다.

----
### 함수
무엇을 함수로 만들 것인가? 아래 대원칙에 따라 만드는게 보통임.
 - UI와 내부기능을 분리한다.
   - 웬만하면 입력값 유효성 검사는 입력단에서 처리하는 것이 효율성 측면에서 좋음.
 - 하나의 단위기능으로 규정할 수 있는 대상은 함수로 만든다.

----
### 포인터
변수의 본질은 메모리이며 모든 메모리는 자신의 위치를 식별하기 위한 근거로 고유번호(일련번호)를 갖는데, 이 번호를 메모리의 주소라 한다. 한편, 이 때 말하는 메모리는 Virtual Memory(가상메모리)이다.

윈도우의 경우, 윈도우7부터는 메모리해킹을 방지하기 위해 ASLR(Address Space Layout Randomization)이 지원된다.

#### 함수가 여러개로 나뉘었을 때 배열 등을 다른 함수로 전달
지역변수로 선언된 배열을 매개변수로 가져갈 수 있도록 하기 위해 매개변수에 해당 배열 포인터형을 입력할 수 있다. 배열의 이름이 주소이므로, 포인터 변수에 저장할 수 있는 것이다.

#### 메모리의 종류
메모리는 **용도**에 따라 아래와 같이 나누어진다. 
 - Stack: 자동변수이고 지역변수인 변수가 사용하는 메모리 영역이며, 임시 메모리의 성격을 가진다. 크기가 작고(최대 1MB 수준) 관리(할당 및 반환)가 자동으로 이루어지는 장점이 있다.
 - Heap: 동적 할당할 수 있는 자유 메모리 영역이며, 개발자가 직접 수동관리해야한다. 32비트 응용프로그램의 경우, 대략 1.xGB 정도를 사용할 수 있다. 따라서 대량의 메모리가 필요하거나 필요한 메모리의 크기를 미리 알 수 없을 때 사용한다.
 - PE image(실행파일)
   - Text Section: C언어의 소스코드가 번역된 기계어가 저장된 메모리 영역이다. 기본적으로 읽기전용 메모리이며, 변조될 경우 해킹이다.
   - Data Section
     - Read Only: 상수 형태로 기술하는 무자열이 저장된 메모리 영역이며, 읽기는 가능하지만 쓰기는 허용되지 않는다.
     - Read/Write: 정적변수나 전역변수들이 사용하는 메모리 영역이며, 별도로 초기화 하지 않아도 0으로 초기화된다. 관리는 자동이라서 힙 영역 메모리처럼 할당 및 해제를 신경 쓸 필요는 없다.
     
#### 메모리 동적할당 및 관리
