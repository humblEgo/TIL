1. 학습 날짜 // 2020-08-10(월)

2. 학습시간 // 9:00~22:00

3. 학습 범위 및 주제 // 세마포어

4. 동료 학습 방법 // -

5. 학습 목표 // philo_two 구현완료

---

6. 상세 학습 내용

# 세마포어

- 작동원리
  - 차단을 원하는 자원에 대해서 세마포어를 생성하면, 해당 자원을 가리키는 세마포어 값이 할당됨. 이 세마포어 값을 검사해서 임계영역에 접근할 수 있는지를 결정하게 된다.
  - 세마포어 값이 0이면 자원에 접근 불가, 0 초과인 정수면 해당 정수의 크기만큼의 프로세스가 자원에 접근할 수 있다.
  - 결론적으로 아래와 과정을 따른다.
    1. 임계영역을 설정함.
    2. 임계영역에 진입하기 전에 세마포어 값을 확인
    3. 세마포어 값이 0보다 크면 세마포어를 가져옴. 세마포어를 가져왔으니 커널의 입장에서 세마포어가 1 감소한다.
    4. 세마포어 값이 0이면 값이 0보다 커질때까지 block 되며, 0보다 커지게 되면 2번부터 시작하게 된다.

세마포어는 원자화(시그널의 도착에 의해 작업이 중단되지 않으며, 한 순간에 오직 하나의 프로세스만이 자원에 접근하는 것을 말한다.)된 연산을 필요로 한다. 원자화된 연산은 유저레벨의 함수에서는 제공하기가 힘들어서 커널에서 전용 구조체를 이용해서 관리하게 된다.

전통적으로는 SYstem V 인터페이스가 있고, 우리 과제에서 주어진 것은 POSIX 규격을 따르는 세마포어 인터페이스에 속한 함수들이다. 

## POSIX 세마포어

POSIX 세마포어 함수를 사용하기 위해서는 -lrt로 리얼타임 라이브러리를 링크해야한다. 아래처럼!

`gcc -lrt test.c`

### 세마포어 만들기

세마포어는 'unnamed semaphore'와 'named semaphore'로 나누어져있다.

전자는 `sem_init`으로 만들고 후자는 `sem_open`으로 만든다. 과제에는 `sem_open`만 허용되어있다. 

'named semaphore'는 마치 세마포어 객체를 파일처럼 관리한다. *정확히 파일은 아니어서 read/write/close 함수를 쓸 수는 없다고 한다.* 

인자는 다음 4개이다.

- name: 서로 구분되는 세마포어의 이름
- oflag: 세마포어 생성을 위해 O_CREAT로 설정된다. (이미 세마포어가 존재하는 경우 실패하게하려면 O_EXCL로 설정함.)
- mode_t: 새로운 세마포어에 대한 권한을 제어한다.
- value: 세마포어의 초기 값을 결정한다.

리턴 값은 'sem_t' 구조체이다.



세마포어 파일은 /dev/shm에 만들어진다. 그러므로 아래처럼 /dev/shm을 마운트 시켜줘야 한다.

`# mount /dev/shm`

#### 세마포어 얻기(기다리기)

세마포어를 얻을 때까지 기다린다. `sem_wait`, `sem_trywait`, `sem_timedwait`가 있고, `sem_wait`함수만 과제에 허용되어있다.

sem_wait 함수는 세마포어 값이 0보다 크면 프로세스가 세마포어를 얻고, 세마포어를 감소한다음 즉시 반환한다. 만약 세마포어값이 0이라면 세마포어가 0보다 더 커지거나 시그널이 발생할 때까지 대기한다. *흡사 mutex_lock 같은 느낌*

#### 세마포어 되돌려주기

`sem_post`함수로 세마포어를 되돌려준다. 세마포어 값이 하나 증가한다. *흡사 mutex_unlock 같은 느낌*

#### 세마포어 삭제

`sem_unlink` 함수로 세마포어를 삭제하고, **OS에 자원을 반환**한다. 이 때 바로 반환되는 것은 아니고 해당 세마포어를 참조하는 프로세스가 모두 없어져야 비로소 세마포어 객체가 사라진다고 한다. `sem_open`으로 만든 'named 세마포어'를 삭제하고자 할 때 사용한다.

`sem_unlink` 를 호출한 이후에 `sem_close`함수를 호출하여 종료하면 끝! http://neosrtos.com/docs/posix_api/semaphore_close.html

만약 개발자가 세마포어를 close하는 동작을 잊는다면, 세마포어 cleanup은 **프로세스 종료시점**에 이루어진다고 한다. 요건 POSIX 세마포어의 특징이다.



## 세마포어와 뮤텍스의 차이점

1. 세마포어는 뮤텍스로 사용될 수 있지만, 뮤텍스는 세마포어로 사용될 수 없다.
2. 세마포어와 뮤텍스는 모두 본래 비 재귀적이다.
3. 세마포어는 소유할 수 없는 반면 뮤텍스는 소요 가능하며 소유주가 이에 대한 책임을 진다.
4. **뮤텍스는 뮤텍스를 소유하고 있는 쓰레드가 이 뮤텍스를 해제해야 한다. 그러나 세마포어의 경우 이러한 조건이 필요치 않다. 임의의 다른 쓰레드가 함수 sem_post()를 사용하여 세마포어를 해제하기 위한 신호를 보낼 수 있다.**
5. 정의에 따라 뮤텍스는 하나 이상의 쓰레드에 의해 동시에 실행되지 않도록 재진입코드 부분에 대한 접근을 시리얼화 하기 위해 사용한다.
6. 세마포어는 시스템 범위에 걸쳐 있어서 파일 시스템상의 파일 형태로 존재한다. 반면 뮤텍스는 프로세스의 범위를 가지며 프로세스가 종료될 때 자동으로 clean up된다. 다만, POSIX 세마포어는 일관성없게도 프로세스 종료시점에 clean up되는 특징을 가지고 있다.
7. 세마포어의 본래 목적은 쓰레드 뿐만 아니라 관련 혹은 비 관련 프로세스를 동기화 하는데 있다. 반면 뮤텍스는 쓰레드간의 동기화에만 사용되어왔고 최근 커널에서야 관련(related) 프로세스에서 사용가능하게 한다.
8. 세마포어를 사용하는 프로그램이 뮤텍스를 사용하는 프로그램에 비해 좀 더 많은 메모리를 사용한다.
9. 사용면에서는 뮤텍스가 세마포어에 비해 좀 더 간단한 사용법을 갖는다.



[참고](https://www.joinc.co.kr/w/Site/system_programing/IPC/semaphores)
[참고2](https://www.hanbit.co.kr/network/category/category_view.html?cms_code=CMS5536818490)


---    
    
7. 학습 내용에 대한 개인적인 총평 

보통 3일만에 해결하는 과제라고 명시되어있는 것치고 많은 시간을 쏟고 있어서 조금 접근을 잘못했나싶기도 합니다만, 이왕 하는거 면접 등에서 질문을 받아도 바로바로 답할 수 있을 정도로 공부해보고 있습니다. 확실히 뮤텍스를 해보고 세마포어를 하니까 훨씬 편하네요ㅎㅎ

---

다음 학습 계획

- philosopher two, three 구현