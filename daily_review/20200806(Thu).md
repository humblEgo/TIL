1. 학습 날짜 // 2020-08-07(목)

2. 학습시간 // 9:00~22:00

3. 학습 범위 및 주제 // Philosopher one

4. 동료 학습 방법 // eunhkim님과 토의한다.

5. 학습 목표 // Philosopher one 구현을 마친다.

---

6. 상세 학습 내용

#### 문제) mutex_destroy를 할 때 기생성된 mutex들이 unlock된 상태임을 보장해야한다.
#### 해결) 프로그램 종료조건이 되면 flag를 조절하여 각 쓰레드가 지금껏 열어둔 mutex를 모두 unlock한 다음 while 무한루프를 돌며 메인쓰레드에서 모든 mutex가 destroy하기를 기다리도록 함수를 만든다.

mutex_destroy할 때 해당 뮤텍스가 unlock된 상태가 아니면 undefined behavior가 발생한다고 명시되어있다. 이 [링크](https://wiki.sei.cmu.edu/confluence/display/c/CON31-C.+Do+not+destroy+a+mutex+while+it+is+locked)를 봐도 잠겨있는 동안 mutex를 삭제하면 잘못된 제어 흐름 및 데이터 손상이 발생할 수 있다고 한다.
그런데 다른 모든 동료들의 코드를 보면 이 부분을 간과했거나 무시하여, 프로그램 종료시 그전까지 생성한 모든 mutex를 일괄 파괴해버리도록 코딩한 것을 확인하였다. 어차피 프로그램이 종료되니까 undefined behavior가 일어난 mutex에 다시 접근할 일이 없을거라고 판단한 동료의 말은 일견 설득력있기도 하였다.

나도 그냥 무시하고 프로그램 종료시 그전까지 생성한 모든 mutex를 일괄 파괴하도록 코딩해볼까 고민되었지만, 한번 제대로 처리하는 것을 도전해봐야겠다는 오기가 생겼다.

pthread_mutex_trylock 함수 등의 허용되지 않은 함수를 써야만 구현가능할 것 같다는 생각에 거의 포기하고 있었는데.. 조금 번거롭겠지만 방법이 떠올라서 적용하였고 성공하였다.

문제는 프로그램 종료시 약간의 딜레이가 발생한다는 것. 이 현상은 각 쓰레드가 unlock되는 것을 기다리는 시점에 usleep하는 쓰레드가 있다면 그 usleep이 끝날 때까지 종료를 유보하기 때문에 발생하는 것이었다.
pthread_mutex_trylock 함수와 signal을 보내는 함수를 쓸 수 있다면 충분히 처리할 수 있겠지만, 과제에서 허용되어있지 않고, '철학자가 죽는 조건을 달성하고 죽을 때까지 걸리는 시간이 10초 이내'라는 조건만 달성하면 과제를 통과하는데 문제가 없다는 판단하에 그대로 두었다. 

---

7. 학습 내용에 대한 개인적인 총평

스스로의 기준을 충족하려다보니 시간이 더 들었습니다. 
음 이것까지 처리해야하나..싶은 생각도 들고 좀 오바한 듯했지만, 인지한 문제를 무시하지않고 해결하여 스스로 떳떳한 하루를 보낸 것 같습니다.

---

다음 학습 계획

- philosopher one 구현 마무리