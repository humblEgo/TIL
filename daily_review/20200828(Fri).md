1. 학습 날짜 // 2020-08-28(금)

2. 학습시간 // 9:00~22:00

3. 학습 범위 및 주제 // C++

4. 동료 학습 방법 // sanam씨와 토론함

5. 학습 목표 // C++ module07을 끝낸다.

---

6. 상세 학습 내용

# CPP Module07

키워드: 템플릿

---

## 템플릿?

- 함수나 클래스를 개별적으로 다시 작성하지 않아도, 여러 자료형으로 사용할 수 있도록 만들어 놓은 툴이다.

- 기능은 동일하고 변수 타입만 다른 경우에 '일반화'하기 좋으다.

- 함수 템플릿(Function Templete)와 클래스 템플릿(class Template)로 나누어진다.

- 호출할 때 `function<int>(int a, int b)` 이런식으로 호출하는데, `<int>`처럼 명확하게 어떤 타입을 인자로 넘기는지 명시해주는 것이 권장된다. 만약 명확하게 어떤 타입을 인자로 넘기는지 명시하지 않으면 컴파일러가 인자 정보를 검사하여 적합한 함수를 콜한다.

- 중복함수와 템플릿 함수가 같이 정의&선언되어있다면 중복함수가 우선적으로 실행된다.
- '**함수 템플릿 **자체는 컴파일 되지 않는다. 왜? 함수 템플릿은 함수를 만들기 위한 도구일 뿐이다! 컴파일시에 컴파일러가 함수 템플릿과 함수의 호출문장을 해석하여 **'템플릿 함수'**를 생성하여 오브젝트 파일에 포함시킨다.

## Tips

### ex00

템플릿을 이용하자. 이 때 min, max 함수는 strcmp를 이용하여 비교할 수 있도록 [**함수 템플릿의 특수화(Specialization)**](https://blockdmask.tistory.com/45)을 했다.

### ex01

이것도 ex00에서 학습한 내용으로 바로 구현가능한 수준이다. 함수포인터로 '함수템플릿'을 인자로 넘겨주는 함수를 만들 수 있다는 것이 포인트라면 포인트. 아, 두번째 인자로 넘겨주는 배열길이는 `int`로 넘기거나 `size_t`로 넘기거나 둘다 처리가능하도록 하는게 문제 의도에 맞는 것 같다. 아래처럼 typename을 두개써서 구현해보자.

```c++
template <typename T1, typename T2>
void iter(T1* array, T2 length, void (*func)(T1 const&))
{
...
}
```

### ex02

지금까지는 `Class.hpp`파일에 선언하고 `Class.cpp`파일에 정의한 뒤, `main.cpp`에서 객체생성,실행하는 식으로 정의와 선언을 분리시켜도 문제없이 컴파일되었다. 그런데 템플릿 함수, 템플릿 클래스는 `Templete.hpp`파일에 선언하고 `Templete.cpp`파일에 정의한 뒤 `main.cpp`에서 실행, 객체생성하는 식으로 정의와 선언을 분리시키면 컴파일이 되지 않는다! 

이유는 뭘까? 1) 컴파일은 파일단위로 이뤄진다는 사실과 2) 템플릿을 템플릿함수로 인스턴스화(구체화)할 때 컴파일러가 주어진 템플릿 인수로 새로운 클래스를 생성한다는 것을 떠올려보자. 컴파일러가 `main.cpp`파일을 컴파일하며 템플릿함수를 만들 때 필요한 정보는 `Templete.hpp`에 있는 함수템플릿 정보와 `Templete.cpp`함수에 있는 함수템플릿의 구현에 대한 정보이다. 그런데 파일단위로 컴파일이 이뤄지므로  `main.cpp`파일을 컴파일할 때는 `Templete.cpp`파일을 참조하지 않고, 결국 컴파일 에러가 발생한다!

이를 방지하려면 `Templete.hpp`파일에 함수템플릿 선언과 정의를 함께 하거나, 함수템플릿 정의에 대한 정보를 가진 파일을 include해줘야한다. 이 때 보통 `Templete.tpp` 처럼 템플릿의 정의는 `.tpp`파일에 적는다. 인라인 함수정의에는 인라인 함수 정의에는 .ii, .ixx, .ipp, .inl을 쓰기도 한다.

[참고]([https://www.it-swarm.dev/ko/c%2B%2B/%ED%85%9C%ED%94%8C%EB%A6%BF%EC%9D%84-%ED%97%A4%EB%8D%94-%ED%8C%8C%EC%9D%BC%EC%97%90%EB%A7%8C-%EA%B5%AC%ED%98%84%ED%95%A0-%EC%88%98%EC%9E%88%EB%8A%94-%EC%9D%B4%EC%9C%A0%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9E%85%EB%8B%88%EA%B9%8C/958176257/](https://www.it-swarm.dev/ko/c%2B%2B/템플릿을-헤더-파일에만-구현할-수있는-이유는-무엇입니까/958176257/))

#### 문제) 복사생당자에서 `free() Invalid size` 오류가 계속 발생하였다.

#### 해결) 복사생성자와 assign operator를 동일시한 것이 문제였다. 복사생성자에서 오버로딩된 assign operator를 call하기 전에 `this->_array`에 동적할당을 하여 멤버변수 초기화를 완료한 후 assign operator를 call한다.

복사생성자를 call하면 생성자가 자동으로 call되어 멤버변수가 초기화되어있을 거라고 착각해서 `this->_array`에 동적할당이 되었을거라고 생각한 것이 문제였다. 동적할당된 적 없는 주소를 오버로딩된 assign operator에서 `delete[] this->_assign`하려고 했다보니 문제가 된 것이다..;

아래 이미지의 5번 라인을 삽입하여 해결하였다.

![code4](https://user-images.githubusercontent.com/54612343/91528314-7350a600-e942-11ea-99c8-4e1e3fe34a14.png)



---    
    
7. 학습 내용에 대한 개인적인 총평 

C++을 공부하면 할 수록 C언어보다 생산성이 월등히 높다는 것을 깨닫습니다. 템플릿 함수나 다형성은 C언어만으로 프로그래밍할 때 느끼던 갈증을 시원하게 풀어주는 것 같습니다. 다만 템플릿의 문법이 클래스와 엮이니 생각보다 까다로웠습니다. 
윤성우의 열혈 C++ 책을 독파하였지만, 좀 오해하기 좋게? 적혀있었는지 제가 잘못이해한 건지 복사생성자에 대한 개념이 잘못잡혀있는 것을 발견하였습니다. 저처럼 윤성우의 열혈 C++ 책으로 공부한 sanam씨도 똑같은 실수를 하고 있는 것을 확인하여 토론을 통해 함께 개념을 바로 잡을 수 있었습니다. 역시 직접 해보고 시행착오를 겪는 것이나 다른 사람에게 지식을 설명하는 것이 '내가 모르는 것'을 파악하는데 최고인 것 같습니다.

---

다음 학습 계획

- CPP Module08 구현완료