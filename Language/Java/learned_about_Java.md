### JAVA에 대해 알게된 것 기록
소프트웨어 장인을 목표로 하는데 도움이 되는 패턴을 모아둔 책인 '프로그래머의 길, 멘토에게 묻다'에 적혀있는 '잔을 비우다'>'첫번째 언어' 패턴을 실천하기 위해, JAVA의 정석을 정독하고 기억해둘 만한 내용을 적습니다.
'무지를 드러내자'는 생각으로 애매하면 그냥 다 적을 것.

 - [변수](#변수)
 - [연산자](#연산자)
 - [조건문과 반복문](#조건문과-반복문)
 - [배열](#배열)
 
 
 ----
 ### 변수
 
  - 상수와 리터럴(constant & literal)
    - 리터럴의 타입과 접미사  
  
    |종류|리터럴|접미사|
    |----|----|----|
    |논리형|false, true|없음|
    |정수형|123, 0b0101, 077, 0xFF, 100L|long 타입이면 L, **int 타입이면 생략(byte와 short타입 리터럴은 없어서 int타입 리터럴 사용)**|
    |실수형| 3.14, 3.0e8, 1.4f, 0x1.0p-1|float타입이면 f, double 타입이면 d(**생략가능**)|
    |문자형|'a','1','\n'|없음|
    |문자열|"ABC","123","A","true"|없음|
    
      리터럴의 접두사와 접미사는 대소문자를 구별하지 않는다. 리터럴에 소수점이나 10의 제고븡ㄹ 나타내는 기호 E 또는 e가 포함되어있어도 실수형 리터럴도 간주된다.
  
      기호 p를 이용하면 실수 리터럴을 16진 지수형태로 표현할 수 있다.
      `ex) 0xp1 = (1*16^0)*2^1 =1.0*2 = 2.0`
    
    - 문자 리터럴과 문자열 리터럴
    
      문자 리터럴은 반드시 ''안에 하나의 문자가 있어야한다. 문자열 리터럴은 ""처럼 공백표시 가능.
   
      원래 String은 클래스이므로 아래와 같이 객체를 생성하는 연산자 new를 사용해야 하지만 특별히 그냥 new없이 정의할 수도 있다. 전자의 경우 일반적인 클래스와 같이 heap 내에 객체 레퍼런스 주소를 가진다. 후자의 경우 heap 내의 string constant pool에 저장된다.
   
      **tip: 덧셈 연산자의 경우, 피연산자 중 어느 한 쪽이 String이면 나머지 한 쪽을 먼저 String으로 변환한 다음 두 Stirng을 결합한다. 문자열 변환할 때 편하다.**
    
    - 정수형
    
      정수형의 선택기준으로 정수값의 범위에 따라 정수형을 선택하여 메모리를 절약할 수도 있지만 이는 선택할 문제다. 
      byte와 short는 표현가능한 크기가 작아서 범위를 넘을 위험에 더 쉽게 노출되고, JVM의 피연산자 스택이 피연산자를 4 byte 단위로 저장하기 떄문에 크기가 4 byte보다 작은 자료형의 값을 계산할 때는 4 byte로 변환하여 연산이 수행된다. 
      따라서 오히려 int를 사용하는 것이 더 효율적이다. **웬만하면 정수쓸 때 int쓰고, int의 표현범위를 넘거나 메모리가 부족할 때 다른 정수형을 선택하자.**      
    
    - 실수형
    
      실수형에서 오버플로우될 경우, 변수의 값은 무한대가 된다, 또한 정수형과 달리 언더플로우(underflow)가 있는데, 이는 실수형으로 표현할 수 없는 양의 최소간보다 작은 값이 되는 경우로, 변수의 값이 0이 된다.
      정밀도 이슈가 있으므로 연산속도의 향상이나 메모리를 절약하려면 float를 선택하고, 더 큰 값의 범위나 더 높은 정밀도가 필요하면 double을 선택하자.
    
   
    - 형변환
      형변형 연산자는 그저 피연산자의 값을 읽어서 지정된 타입으로 형변환하고 그 결과를 반환할 뿐이므로, 피연산자인 변수 d의 값은 형변환 후에도 아무런 변화가 없다.
     
      정수형 --> 실수형으로 변환시
      실수형이 정수형보다 훨씬 큰 저장범위를 갖기 때문에, 정수형을 실수형으로 변환하는 것은 별 무리가 없다. 단, int는 최대 10자리의 정밀도를 요구하는데 반면 float는 10진수로 약 7자리의 정밀도만을 제공하므로, int에서 float로 변환할 때는 정밀도 차이에 의한 오차가 발생할 수 있다. 이럴 땐 double을 쓰자.
     
      실수형 --> 정수형으로 변환시
      소수점이 다 버려짐.
     
      자동형변환(산술변환)
      따로 형변환 지정안했을 때, 컴파일러가 기존의 값을 최대한 보존할 수 있는 타입으로 형변환을 자동적으로 추가하는 것. 값 손실 날 경우 에러 메세지로 알린다.
   
   
----
### 연산자

 - 연산자의 우선순위와 결합규칙
   - 산술변환(usual arithmetic conversion)
     두 피연산자의 타입이 일치해야 연산이 가능하다. 컴파일러가 연산 전에 피연산자 타입의 일치를 위해 자동 형변환하는 것을 '산술 변환'이라고 한다.        이 때, 두 피연산자의 타입을 같게 일치시키는 것 외에도 피연산자의 타입이 int보다 작은 타입이면 int로 변환하는 규칙이 적용된다. 이유는 정수형        처리시 int가 효율적이고 오버플로우가 발생할 확률이 낮기 때문이다.
   
 - 산술연산자
   - 사칙연산자: `char c1 = 'a' + 1;`의 경우, 리터럴 간의 연산이기 때문에 int로 산술변환되지 않고 char형을 유지한다. 유니코드상에서 소문자를 대문      자로 변경하려면 32를 더하면 된다.
     한편, int간의 나눗셈을 수행하면 결과가 int이므로 소수점이하 값들은 버려진다. 이를 이용하면 실수의 소수점 n번째자리까지만 추출하거나 n번째까지      만 추출하되 n+1번째에서 반올림하도록 처리 가능하다.
     ```
     ex) double pi = 3.141592;
     double shortPi = (int)(pi*1000 + 0.5) / 1000.0;
     ```
   - 나머지 연산자 %: 피연산자로 정수만 허용한다.
   
 - 비교 연산자
   - 문자열의 비교
     두 문자열의 **내용**을 비교할 때는, 비교 연산자 '=='대신 equals()라는 메서드를 사용해야 한다. 서로 다른 객체라도 내용이 같으면 equals()는        true를 반환한다. 한편 내용이 같더라도 서로다른 객체라면 '=='로 비교시 false가 나온다.
     대문자 소문자 구분않고 비교할 땐, equalsIgnoreCase() 메서드 활용할 것.
     
 - 논리 연산자
   - 논리 연산자 &&, ||, !
     문자는 'a'부터 'z'까지, 'A'부터 'Z'까지도 연속적으로 배치되어 있으므로, 논리 연산자를 통해 문자 ch는 대문자 또는 소문자라는 것을 판별하려면        아래와 같이 연산해서 판별가능하다. 소문자 여부부터 판별하는 것은, 사용자로부터 문자를 입력받을 때 사용자가 대문자보다 소문자를 입력할 확률이        높다고 판단했기 때문.
     `('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z')`
     
   - 대입 연산자 =, op=
     대입 연산자는 연산자들 중에서 가장 낮은 우선순위를 가지고 있기 떄문에 식에서 제일 나중에 수행된다. 연산 진행 방향이 오른쪽에서 왼쪽이다.
     
     대입 연산자의 왼쪽 피연산자를 'lvalue'라고 하고, 오른쪽 피연산자를 'rvalue'라고 한다. rvalue는 변수뿐만 아니라 식이나 상수 등이 모두 가능한      반면, lvalue는 반드시 변수처럼 값을 변경할 수 있는 것이어야 한다.
   
   
----     
### 조건문과 반복문
   - switch-case문
     switch 조건식의 결과는 정수 또는 문자열이어야하고, case문의 값은 정수 상수만 가능하며, 중복되지 않아야 한다.
     로그인한 사용자의 등급(level)을 체크하여, 등급에 맞는 권한을 부여하는 방식으로 응용할 수 있다.
     
  tip: 특정 범위의 난수를 구할 경우, `Math.random()` 값을 사용하는데, 이 메서드는 0.0과 1.0 사이의 범위에 속하는 double 값을 하나 반환하므로, Math.random()에 n을 곱하고, int로 형변환 하면 된다. 
   
   - 반복문
     JDK1.5부터 **배열과 컬렉션**에 저장된 요소에 접근할 때 `for( 타입 변수명 : 배열 또는 컬렉션) {}` 형식으로 for문 작성이 가능해졌다. 다만, 이      경우엔 일반적인 for문과 달리 배열이나 컬렉션에 저장된 요소들을 읽어오는 용도로만 사용할 수 있다는 제약이 있다.
     
   - continue문
     continue문은 반복문 내에서만 사용될 수 있으며, 반복이 진행되는 도중에 continue문을 만나면 반복문의 끝으로 이동하여, for문의 경우 증감식으로,      while문과 do-while문은 조건식으로 이동한다.
     
   - 이름 붙은 반복문
     반복문에 이름을 붙이고, break문에 이름을 지정해 줌으로써 하나 이상의 반복문을 벗어나거나 반복을 건너뛸 수 있다.
     
----
### 배열
    - 배열이란?
      Java에서의 배열은 **같은 타입**의 여러 변수를 하나의 묶음으로 다루는 것이다. 여러개의 변수를 선언하는 것과 달리 인덱스에 따른 각 저장공간이 연속적으로 배치된다.
