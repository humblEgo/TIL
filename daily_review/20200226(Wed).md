#### 1. 학습 날짜 // 2020-02-26(수)

#### 2. 학습시간 // 11:00 ~ 23:00(자가)

#### 3. 학습 범위 및 주제 // libft atoi ~ ft_putnbr_fd

#### 4. 동료 학습 방법 // NULL

#### 5. 학습 목표 // Libft part2 마무리

#### 6. 과제 제출 repository 주소 : http://13.125.198.2:3000/iwoo/Libft.git

---

#### 7. 상세 학습 내용

**실제 코딩에 사용한 시간: 4시간**

**문제 1) File_descriptor는 똑같은 값인데 여러번 read하는 과정에서 이전에 read된 byte 이후에 이어서 read하는 것이 어떻게 가능한지 이해가 가지 않는다.**

**해결 방안: 인터넷 검색을 통해 파일 디스크립터에 대한 내용을 조금 더 깊게 확인했다.**

- 커널 구조체 중에 struct files_struct에는 struct file fd_array라는 배열이 있는데, 이 구조체 배열의 index가 open을 통해 얻는 파일 디스크립터(fd)이다.
- fd로 파일을 제어할 때는, fd번째 원소인 fd_array[fd]는 **'Offset, 동작제어 flag, 접근 모드, i/o 관련 설정, 파일의 inode 객체를 가리키는 레퍼런스'**로 이루어진 dentry 구조체 배열인 File table의 원소를 가르키고, 이 구조체가 가르키는 inode에 접근하는 과정을 거친다. 이 때 dentry는 directory entry를 의미하며 리눅스에서 디렉토리에 접근을 빠르게 하기 위한 구조체로 사용한다고 한다,
- 한편 inode는 파일 종류(일반파일, 소켓, fifo)와 권한, lock 목록 포인터, 여러 파일 오퍼레이션과 다양한 파일 속성(크기, 파일스탬프 등)을 가지고 있다.
- 즉, open 함수로 파일을 호출하면, 해당 파일에 대한 dentry를 생성하고, inode를 생성(또는 읽음) 후에 해당 프로세스의 open 파일 관리 구조체인 files_struct의 fd_array 의 비어있는 위치에 생성한 dentry를 포인팅하고 그 index를 반환하게 되는 것이다.
- fd로 파일에 접근해서 여러번 read하면, 이전에 읽은 byte부터 이어서 파일을 읽는게 신기했는데, 앞선 read 과정에서 fd_array[fd]안에 있는 offset이 변경되었기 때문인 것을 알게 되었다.
- 추가로, 앞으로는 표준 입력, 표준 출력, 표준 에러에 대해서 0, 1, 2 정수 값이 아니라 STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO 매크로 값을 쓰는 습관을 들여야겠다.

---

#### 학습 내용에 대한 개인적인 총평 (최소 5줄 이상)

도서관에 가서 공부를 하지 않으니 너무나 효율이 떨어진다. 지금까지 집은 휴식공간으로 너무 쎄게 포지셔닝 해둔 탓인 것 같다.. 집도 공부할 수 있는 환경으로 만드는 방법을 고민해봐야겠다. 가령 동료들과 슬랙 화상채팅을 이용한다던가.. 오늘은 코딩에 온전히 집중이 되지 않아서 C언어에 대한 책을 빌려둔 것을 슬슬 읽었는데, 라피씬 전에 C언어 유튜브 강의를 급하게 들었던 때와는 확연히 다르게 읽히는 것을 느꼈다. 특히 파일 입출력 관련하여서는 궁금한 부분을 가지고 책을 읽으니 매우 흥미로웠다. 특히 피씬 때는 open함수를 통해 fd 값을 받아와서 쓰면서도 함수를 돌리는데 급급했지, fd 값이 유지되는 상황에서 read함수가 어떻게 다르게 작동하는지 궁금했었는데, 이 부분이 해소되어서 짜릿함을 느꼈다.

이러나 저러나 목표했던 것을 해내지 못한 것은 아쉽다. 김수보 멘토님 말씀대로 '내가 얼마나 코딩해낼 수 있을지 가늠하는 것'도 중요한 개발자의 역량이므로 좀 더 신경써서 목표를 정하고 성취해봐야겠다.

---

#### 다음 학습 계획 (최소 5줄 이상)

1. Libft part2 진짜 마무리
2. '10분안에 보는 정규표현식' 한 챕터 더 읽기
3. 왜 내 개인 깃헙에 푸쉬해도 잔디가 안 심기는지 확인해보고 해결하기
4. 10시간 이상 코딩해보기
5. 파이썬 강의 들어보기
