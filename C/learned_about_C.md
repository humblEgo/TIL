## C언어에 대해 기록
역량있는 개발자가 되기 위해, 하드웨어에 관한 내용도 포함하여 C언어를 조금 더 깊이있게 학습합니다. 이를 위해 최호성 강사님의 '독하게 시작하는 C 프로그래밍' 강의를 수강하며 배운 점을 기록합니다.

목차
 - [자료형](#자료형)
 - [표준 입/출력 도구](#표준-입출력-도구)
 - [연산자](#연산자)



----
### 자료형
 - 정의: **일정 크기(길이)의 메모리**에 저장된 정보를 **해석하는 방법**
   - 자료형의 유무가 B언어와 C언어간의 승패를 갈랐다고 합니다.


#### 상수의 종류
 - 리터럴 상수
   - 문자 상수: 영문자나 특수문자를 기술한 상수
   - 문자열 상수: 문자 상수들의 연속된 집합체를 표현한 상수. 다른 상수들과 달리 여러 개가 한 덩어리를 이룬 배열이며 '주소'로 식별될 수 있음.
   - 정수 상수
   - 실수 상수
 - 심볼릭 상수
   - 형한정: const 형한정어를 이용해 선언 및 정의되는 상수
   - 전처리기: #define 전처리기로 선언 및 정의되는 상수
   
 
 #### 보수를 이용한 뺄셈 연산과정
  - 8비트의 표현 범위를 이용하여, 보수를 더하는 방식으로 감산함.
  EX) 4에서 2를 뺄 경우, 00000100<sub>(2)</sub> 에 2의 '2의 보수'인 11111110<sub>(2)</sub>를 더한다. '2의 보수'는 보수를 구하려고 하는 정수를 각 자리수를 0은 1로, 1은 0으로 바꾸어 '1의 보수'를 구하고, 1을 더하여 구한다.
 
 
#### 부동소수점
실수형식은 근본적으로 근사값 처리로 인한 **오차**를 가지고 있다.
 - float: 32비트 단정도 형식, **유효 자릿수는 소수점 이하 6자리**, 정확도가 떨어지므로 메모리 이슈 없으면 웬만하면 실수표현할 때 double쓰는게 나음. 
 - double: 64비트 배정도 형식 **유효 자릿수는 소수점 이하 15자리**
 - long double: 특수정도 형식, 지원 안하는 컴파일러가 많음. 정확성이 많이 요구될 때, 80비트로 구현됨.
 
 
#### 문자열
문자열의 본질은 배열이다. 즉, 문자열 == (상수화된) 문자(배)열.
 - 초기화하면 마지막 null 값까지 포함하여 메모리에 저장된다.--> 문자열 크기를 12로 선언했으면, 11개까지 써야한다. 만약 12개를 넘기면 Buffer Overflow 문제가 발생하고, 프로그램 Crash가 나면 Buffer Overrun 문제가 발생할 수 있다. 이를 막기 위해 **'경계검사'**를 꼭 해야한다.

#### 메모리에 대한 기본 이론
 1. 32비트 플랫폼에서 주소의 길이는 32비트이며, 16진수로 표시한다. 그리고 주소의 범위는 0x00000000번지부터 0xFFFFFFFF번지까지이며, 모두 연이어져 있는 선형 메모리이다.
 2. 자료형은 일정 크기의 메모리를 해석하는 방법이고, 변수는 해서갛ㄹ 대상 메모리에 붙인 이름이다.
 3. 0번지~64kb 영역의 메모리는 운영체제가 사용하고 있다.
 4. 스택이든, 힙이든, 실행 코드 영역이든 모두 선형 메모리 위에 일렬로 존재한다.

#### C언어 코딩 컨벤션
헝가리안 표기법은 찾아보니 구시대의 유물이라는 의견이 많은듯 하여, [링크 블로그를 참고하여 개발할 예정](https://tttsss77.tistory.com/64)

----
### 표준 입출력 도구

 - 특기할 내용
   - 레이어별로 하드웨어(H/W), 커널(Kernel), 유저(User)로 나누었을 때, 입출력은 항상 **커널에서** 이루어진다.
   - 커널<-->하드웨어간에는 '드라이버'로, 유저<-->커널간에는 유저모드에서 접근할 수 있도록 추상화된 'File'로 정보를 주고 받는다. 이 때 정보는 규칙(Protocol)에 입각하여 작성된다.
   ex) 커널의 프로토콜인터페이스와 정보를 주고받는 파일은 'Socket'이다
   - Buffer는 Memory이며, 미리 자료를 복사 받아서 자료를 주고받는 것이 끊기는 등의 충격을 완화하는 역할을 한다. 만약 버퍼를 거치지 않는 경우 DMA를 한다고하며 버퍼를 통하는 것보다 빠르다. 참고로 getchar()나 scanf(), gets() 같은 함수는 Buffered I/O를 한다. 각각 정보를 가져온다는 점에서 동일하고, getchar()는 한글자씩, gets()는 한줄씩, scanf()는 내용을 출력타입에 맞게 변환하여 가져오는 차이가 있다. 단, gets()는 심각한 보안결함이 있어서, gets_S()를 써야한다.

   - 입력가변 길이 처리할 경우, UI단계에서 길이 제한을 하거나 연결리스트 등 가변가능한 자료구조를 써서 대응하는게 좋음.

----
### 연산자

#### 연산의 우선순위
 - 식이 있을 때, 연산 우선순위에 따라 먼저 계산되는 값은 임시저장 된다(메모리에 저장된다) 이후 계산이 진행되며 값이 구해지면 임시저장된 값은 삭제된다. 즉, 당연하지만 필요하다면 유실전에 따로 저장해야한다.

#### 단순대입
<pre>
int a;
a = 10;
</pre>
위와 같은 코드가 있다면, a는 l-value(left + location value)이고, 10은 r-value(right value)이다. l-value에는 원래 쓰레기값이 있고, 이후 r-value가 copy & overwrite가 진행된다.

#### 이형자료 간의 연산 및 형승격
'표현 범위'가 큰 형식을 따라간다. 즉, `printf("%f",5/2)` 요런 코드를 소수점 아래까지 표시하려면, 5나 2 중 하나를 double로 형변환 해줘야한다.
 

#### Sizeof() 연산자
sizeof(자료형)으로 쓰고, CPU가 아닌 **컴파일러**가 수행하는 연산이다. 따라서, 많이 이용한다고 해도 CPU의 부하가 증가하지 않는다(성능에 영향을 주지 않는다). 단, 컴파일러마다 크기가 달라지는 자료형도 있어서 값이 달라질 수 있다.

#### 실수의 연산
결론부터 말하자면 실수는 **상등이나 부등 연산을 수행하면 안된다.** 부동소수점의 근사처리로 인한 오차가 이슈가 되어 상등이 아닌데 상등이라고 나오거나 부등이 아닌데 부등이라고 나오는 경우가 왕왕생긴다. 대신 비교연산은 수행해도 된다.

--> 이런 특성은 switch case 구문 작성시 case 다음에 실수가 아니라 정수를 적는 것으로 이어진다. case 구문 내에서 상등연산이 이뤄지는데, 실수는 상등연산시 오류가 발생할 수 있기 때문이다.


