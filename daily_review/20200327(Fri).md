#### 1. 학습 날짜 // 2020-03-27(금)

#### 2. 학습시간 // 20:00~23:00

#### 3. 학습 범위 및 주제 // Raycasting, 애자일

#### 4. 동료 학습 방법 // NULL

#### 5. 학습 목표 // c로 player 구현 완료

#### 6. 과제 제출 repository 주소 : http://13.125.198.2:3000/iwoo/cub3D.git

---

#### 7. 상세 학습 내용

**실제 코딩에 사용한 시간: 3시간**

**문제 1) math 헤더를 쓰는데 삼각함수 활용시 undefined function 이라는 메세지가 출력된다.**

**해결 방법: gcc에 -lm 옵션을 붙인다.**

**문제 2) 풀려고 시도한 백준 문제에서 정렬에 시간초과가 걸린다.**

**해결 방법: 버블정렬이 아니라 퀵정렬을 시도해본다.**

- 퀵정렬은 분할정복법을 통해 정렬하는 방법이다. 따라서 아래 과정대로 정렬된다.

  - 분할: 배열을 다음과 같은 조건을 만족하도록 두 부분으로 나눈다.
  - 조건: elements in lower parts <= elements in upper parts
  - 정복: 각 부분을 순환적으로 정렬한다.

퀵정렬은 배열을 크기별로 나누는 기준인 'pivot 값'이 해당 배열의 가장 큰 값이나 가장 작은 값일 경우가 최악의 경우로써, 시간복잡도 o(N^2)를 가진다. 보통 배열의 가장 마지막 값을 pivot으로 적용하므로, '이미 정렬된 입력 데이터'에 퀵정렬을 적용하는 경우 가장 큰 시간복잡도를 가지게 되는 것이다.

한편, 운이 좋아서 항상 절반으로 분할되는 경우는 최선의 경우로써, 시간복잡도 O(nlogn)을 가진다. 그리고 평균시간복잡도는 O(nlogn)을 가진다.

이런 특성 때문에, pivot을 선택하는 위치가 이슈가 된다.

- 첫번째 값이나 마지막 값을 pivot으로 선택하는 경우
  - 현실의 데이터는 랜덤하지 않은 경우도 많아서 (거꾸로) 정렬된 데이터가 입력으로 들어올 가능성이 높아서 권장치않음.
- 'Median of Three'
  - 첫번째 값과 마지막 값, 그리고 가운데 값 중에서 중간값을 pivot으로 선택.
  - 최악의 경우 시간복잡도가 달라지지는 않음.
- Randomized Quicksort
  - 피봇을 랜덤하게 선택.

---

#### 학습 내용에 대한 개인적인 총평 (최소 5줄 이상)

c로 player를 랜더링하는 것을 마무리하려고 했으나, player의 ray를 랜더링하는데 시간을 많이 썼습니다. player에 붙은 ray를 (x, x \* tan(라디안)) 좌표에 1픽셀씩 렌더링하면 라디안 각도를 따라서 쭈욱 직선이 그어져야 마땅한데 수평선만 그어지는 문제가 생겼기 때문입니다. 알아보니 60분법 각도를 매개변수로 주었을 때 라디안 값을 반환하는 함수에서, double형이 아닌 int형을 반환하고 있었던 것이 문제였습니다.
요즘 가정사로 여유가 없어서인지 단순한 문제가 발목을 잡는 것이 잦게 느껴집니다. 이에 속상해서 백준 문제나 하나 풀어보기로 했습니다. 그런데 즐겨쓰던 버블정렬로는 자꾸 시간초과가 나서, 다음에 배워봐야겠다고 벼르고 있었던 '퀵정렬'을 실험해보았습니다. 이것도 익숙해져야 바로바로 구현해서 쓸 수 있을 것 같으니 앞으로는 버블정렬 대신 퀵정렬을 응용해보는 방향으로 코딩해보아야겠습니다.

---

#### 다음 학습 계획 (최소 5줄 이상)

1. 코딩학습의 목표를 이번에야말로 제대로 잡아보기
2. c언어로 player 랜더링 마무리
3. 1시간 이상 학습 꼭 하기
4. 함께 자라기 책 1챕터 이상 꼭 읽기
5. 문과생 개발자가 되다 책 1챕터 이상 읽기
