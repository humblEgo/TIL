#### 1. 학습 날짜 // 2020-03-03(화)

#### 2. 학습시간 // 08:00 ~ 23:00(자가)

#### 3. 학습 범위 및 주제 // Get_new_line mandatory part, 네트워크

#### 4. 동료 학습 방법 // NULL

#### 5. 학습 목표 // '모두의 네트워크' 다 읽기, Start Get_next_line mandatory part끝내기

#### 6. 과제 제출 repository 주소 : http://13.125.198.2:3000/iwoo/Libft.git

---

#### 7. 상세 학습 내용

**실제 코딩에 사용한 시간: 8시간**

**문제 1) GNL 실컷 다 구현했다고 생각했는데, 알고보니 함수를 잘못 이해했다.**

**해결 방법: 다 삭제하고 다시 구현하였다.**

- 가장 첫번째 line을 처음으로 읽어올 때는 읽어온 값을 buffer에 저장한 뒤, 리턴할 배열을 동적할당하여 buffer 값을 복사한 뒤, `char *line`에 동적할당했던 배열의 주소를 대입하는 식으로 작동시키고, 만약 가장 첫번째 line이 아닐 경우, 읽어온 값을 기존의 `char *line`에 이어붙일 계획을 세웠다.
- 이를 위해 `char *line`이 NULL일 경우에는 가장 첫번째 line을 읽는 경우라고 생각하고, if문 조건을 `if (line == NULL)`과 같이 작성했으나 작동하지 않았다.\*\*
- if 조건에 `if (line == NULL)`나 `if (line == 0)`라고 해도 동작을 하지 않길래 printf로 line의 주소를 프린트해보았더니 `(nil)`이라는 값이 나왔다. [이 링크](https://softwareengineering.stackexchange.com/questions/321798/in-c-why-is-null-and-0-triggering-an-if-statement)를 통해 확인해보니, NULL은 매크로 값이고, 값이 결정되어있지 않아서 그렇다고 한다.
- 이에 `if (!(line))`으로 조건을 주었더니 잘 작동하였다.

- 문제는 제일 처음 라인을 읽는다고 해도 \*line 값이 NULL일 보장이 없다는 점을 간과했었다는 것이다. 때문에 문자열 중복 여부를 확인할 때 ascii 값을 배열인덱스로 써서 해당 인덱스의 배열값이 0이 아니면 문자열이 중복된 것으로 확인했듯이, fd값을 배열인덱스로 써서 해당 인덱스의 배열값이 0이면 해당 fd 파일을 제일 처음으로 연 것으로 간주하기로 했다.
- 초기화를 어떻게 해줘야하나 고민했는데, [이 링크](https://stackoverflow.com/questions/18283688/in-c-how-do-i-create-a-static-array-of-constant-size-with-zeroed-values-but/18283813)에 따르면, C99 표준에 초기화되지 않은 static array는 0으로 자동초기화 된다고 적혀있어서 따로 초기화할 필요없다고 결론지었다.

**문제 2) 제일 마지막 줄의 경우 읽어왔을 때 개행이 하나 더 포함된 배열을 반환하였다..**

**해결 방법 : 정말 허무하게도, 출력할 때 개행을 포함해두었던 것이 문제점이었다.**

- test 케이스의 main 문에 printf("%s\n", line); 같은 것을 넣어뒀던 것이 확은이었다. 다음부터는 출력 자체의 문제를 꼭 확인해보자.

---

#### 학습 내용에 대한 개인적인 총평 (최소 5줄 이상)

get_next_line은 static 변수가 필요하다고 적혀있어서 공부해보았는데, 왜 필요한지는 구현해보면서 느낄 수 있었다. 지금의 C언어는 많은 프로그래머들의 불편함과 이를 극복하기 위한 고민이 적용된 것이라는 점이 감사하다.

다른 동료와의 슬랙을 통해 while문을 적극 활용하여 비교적 간단하게 함수를 구현할 수 있다는 것을 알게되었으나, 함수를 다시 실행해도 값이 그대로 남아있는 static 변수의 특징에 꽂혀서 재귀적으로 함수를 구현해보았다. 때문에 시간이 좀 더 많이 걸렸지만, 재귀에 대해서도 좀 더 이해할 수 있었던 것 같다. 다만, 자신의 방식을 고집하며 다소 아집을 부린 면도 있었던 것 같아서 반성하게 된다.

학습시 뽀모도로를 적용해보니 확실히 효율이 좋아지는 것을 느낀다, 내일은 오전시간을 더 알차게 써봐야겠다.

---

#### 다음 학습 계획 (최소 5줄 이상)

1. Get_Next_Line에서 BUFFER_SIZE가 읽는 줄 길이보다 작을 때 생기는 문제 해결할 것
2. Get_Next_Line 보너스 파트 완성할 것
3. '모두의 네트워크' 슥슥 모두 읽어볼 것
4. 오전시간 동안 뽀모도로 3시간 적용해볼 것
5. netwhat 과제를 풀기위한 네트워크 개념 절반 정리해두기.
