### JAVA에 대해 알게된 것 기록
소프트웨어 장인을 목표로 하는데 도움이 되는 패턴을 모아둔 책인 '프로그래머의 길, 멘토에게 묻다'에 적혀있는 '잔을 비우다'>'첫번째 언어' 패턴을 실천하기 위해, JAVA의 정석을 정독하고 기억해둘 만한 내용을 적습니다.
'무지를 드러내자'는 생각으로 애매하면 그냥 다 적을 것.

 - [변수](#변수)
 - [연산자](#연산자)
 - [조건문과 반복문](#조건문과-반복문)
 - [배열](#배열)
 - [객체지향언어](#객체지향언어)
 
 ----
 ### 변수
 
  - 상수와 리터럴(constant & literal)
    - 리터럴의 타입과 접미사  
  
    |종류|리터럴|접미사|
    |----|----|----|
    |논리형|false, true|없음|
    |정수형|123, 0b0101, 077, 0xFF, 100L|long 타입이면 L, **int 타입이면 생략(byte와 short타입 리터럴은 없어서 int타입 리터럴 사용)**|
    |실수형| 3.14, 3.0e8, 1.4f, 0x1.0p-1|float타입이면 f, double 타입이면 d(**생략가능**)|
    |문자형|'a','1','\n'|없음|
    |문자열|"ABC","123","A","true"|없음|
    
      리터럴의 접두사와 접미사는 대소문자를 구별하지 않는다. 리터럴에 소수점이나 10의 제고븡ㄹ 나타내는 기호 E 또는 e가 포함되어있어도 실수형 리터럴도 간주된다.
  
      기호 p를 이용하면 실수 리터럴을 16진 지수형태로 표현할 수 있다.
      `ex) 0xp1 = (1*16^0)*2^1 =1.0*2 = 2.0`
    
    - 문자 리터럴과 문자열 리터럴
    
      문자 리터럴은 반드시 ''안에 하나의 문자가 있어야한다. 문자열 리터럴은 ""처럼 공백표시 가능.
   
      원래 String은 클래스이므로 아래와 같이 객체를 생성하는 연산자 new를 사용해야 하지만 특별히 그냥 new없이 정의할 수도 있다. 전자의 경우 일반적인 클래스와 같이 heap 내에 객체 레퍼런스 주소를 가진다. 후자의 경우 heap 내의 string constant pool에 저장된다.
   
      **tip: 덧셈 연산자의 경우, 피연산자 중 어느 한 쪽이 String이면 나머지 한 쪽을 먼저 String으로 변환한 다음 두 Stirng을 결합한다. 문자열 변환할 때 편하다.**
    
    - 정수형
    
      정수형의 선택기준으로 정수값의 범위에 따라 정수형을 선택하여 메모리를 절약할 수도 있지만 이는 선택할 문제다. 
      byte와 short는 표현가능한 크기가 작아서 범위를 넘을 위험에 더 쉽게 노출되고, JVM의 피연산자 스택이 피연산자를 4 byte 단위로 저장하기 떄문에 크기가 4 byte보다 작은 자료형의 값을 계산할 때는 4 byte로 변환하여 연산이 수행된다. 
      따라서 오히려 int를 사용하는 것이 더 효율적이다. **웬만하면 정수쓸 때 int쓰고, int의 표현범위를 넘거나 메모리가 부족할 때 다른 정수형을 선택하자.**      
    
    - 실수형
    
      실수형에서 오버플로우될 경우, 변수의 값은 무한대가 된다, 또한 정수형과 달리 언더플로우(underflow)가 있는데, 이는 실수형으로 표현할 수 없는 양의 최소간보다 작은 값이 되는 경우로, 변수의 값이 0이 된다.
      정밀도 이슈가 있으므로 연산속도의 향상이나 메모리를 절약하려면 float를 선택하고, 더 큰 값의 범위나 더 높은 정밀도가 필요하면 double을 선택하자.
    
   
    - 형변환
      형변형 연산자는 그저 피연산자의 값을 읽어서 지정된 타입으로 형변환하고 그 결과를 반환할 뿐이므로, 피연산자인 변수 d의 값은 형변환 후에도 아무런 변화가 없다.
     
      정수형 --> 실수형으로 변환시
      실수형이 정수형보다 훨씬 큰 저장범위를 갖기 때문에, 정수형을 실수형으로 변환하는 것은 별 무리가 없다. 단, int는 최대 10자리의 정밀도를 요구하는데 반면 float는 10진수로 약 7자리의 정밀도만을 제공하므로, int에서 float로 변환할 때는 정밀도 차이에 의한 오차가 발생할 수 있다. 이럴 땐 double을 쓰자.
     
      실수형 --> 정수형으로 변환시
      소수점이 다 버려짐.
     
      자동형변환(산술변환)
      따로 형변환 지정안했을 때, 컴파일러가 기존의 값을 최대한 보존할 수 있는 타입으로 형변환을 자동적으로 추가하는 것. 값 손실 날 경우 에러 메세지로 알린다.
   
   
----
### 연산자

 - 연산자의 우선순위와 결합규칙
   - 산술변환(usual arithmetic conversion)
     두 피연산자의 타입이 일치해야 연산이 가능하다. 컴파일러가 연산 전에 피연산자 타입의 일치를 위해 자동 형변환하는 것을 '산술 변환'이라고 한다.        이 때, 두 피연산자의 타입을 같게 일치시키는 것 외에도 피연산자의 타입이 int보다 작은 타입이면 int로 변환하는 규칙이 적용된다. 이유는 정수형        처리시 int가 효율적이고 오버플로우가 발생할 확률이 낮기 때문이다.
   
 - 산술연산자
   - 사칙연산자: `char c1 = 'a' + 1;`의 경우, 리터럴 간의 연산이기 때문에 int로 산술변환되지 않고 char형을 유지한다. 유니코드상에서 소문자를 대문      자로 변경하려면 32를 더하면 된다.
     한편, int간의 나눗셈을 수행하면 결과가 int이므로 소수점이하 값들은 버려진다. 이를 이용하면 실수의 소수점 n번째자리까지만 추출하거나 n번째까지      만 추출하되 n+1번째에서 반올림하도록 처리 가능하다.
     ```
     ex) double pi = 3.141592;
     double shortPi = (int)(pi*1000 + 0.5) / 1000.0;
     ```
   - 나머지 연산자 %: 피연산자로 정수만 허용한다.
   
 - 비교 연산자
   - 문자열의 비교
     두 문자열의 **내용**을 비교할 때는, 비교 연산자 '=='대신 equals()라는 메서드를 사용해야 한다. 서로 다른 객체라도 내용이 같으면 equals()는        true를 반환한다. 한편 내용이 같더라도 서로다른 객체라면 '=='로 비교시 false가 나온다.
     대문자 소문자 구분않고 비교할 땐, equalsIgnoreCase() 메서드 활용할 것.
     
 - 논리 연산자
   - 논리 연산자 &&, ||, !
     문자는 'a'부터 'z'까지, 'A'부터 'Z'까지도 연속적으로 배치되어 있으므로, 논리 연산자를 통해 문자 ch는 대문자 또는 소문자라는 것을 판별하려면        아래와 같이 연산해서 판별가능하다. 소문자 여부부터 판별하는 것은, 사용자로부터 문자를 입력받을 때 사용자가 대문자보다 소문자를 입력할 확률이        높다고 판단했기 때문.
     `('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z')`
     
   - 대입 연산자 =, op=
     대입 연산자는 연산자들 중에서 가장 낮은 우선순위를 가지고 있기 떄문에 식에서 제일 나중에 수행된다. 연산 진행 방향이 오른쪽에서 왼쪽이다.
     
     대입 연산자의 왼쪽 피연산자를 'lvalue'라고 하고, 오른쪽 피연산자를 'rvalue'라고 한다. rvalue는 변수뿐만 아니라 식이나 상수 등이 모두 가능한      반면, lvalue는 반드시 변수처럼 값을 변경할 수 있는 것이어야 한다.
   
   
----     
### 조건문과 반복문
   - switch-case문
     switch 조건식의 결과는 정수 또는 문자열이어야하고, case문의 값은 정수 상수만 가능하며, 중복되지 않아야 한다.
     로그인한 사용자의 등급(level)을 체크하여, 등급에 맞는 권한을 부여하는 방식으로 응용할 수 있다.
     
     tip: 특정 범위의 난수를 구할 경우, `Math.random()` 값을 사용하는데, 이 메서드는 0.0과 1.0 사이의 범위에 속하는 double 값을 하나 반환하므        로, Math.random()에 n을 곱하고, int로 형변환 하면 된다. 
   
   - 반복문
     JDK1.5부터 **배열과 컬렉션**에 저장된 요소에 접근할 때 `for( 타입 변수명 : 배열 또는 컬렉션) {}` 형식으로 for문 작성이 가능해졌다. 다만, 이      경우엔 일반적인 for문과 달리 배열이나 컬렉션에 저장된 요소들을 읽어오는 용도로만 사용할 수 있다는 제약이 있다.
     
   - continue문
     continue문은 반복문 내에서만 사용될 수 있으며, 반복이 진행되는 도중에 continue문을 만나면 반복문의 끝으로 이동하여, for문의 경우 증감식으로,      while문과 do-while문은 조건식으로 이동한다.
     
   - 이름 붙은 반복문
     반복문에 이름을 붙이고, break문에 이름을 지정해 줌으로써 하나 이상의 반복문을 벗어나거나 반복을 건너뛸 수 있다.
     
----
### 배열
   - 배열이란?
     Java에서의 배열은 **같은 타입**의 여러 변수를 하나의 묶음으로 다루는 것이다. 여러개의 변수를 선언하는 것과 달리 인덱스에 따른 각 저장공간이        연속적으로 배치된다.
     
   - 배열의 길이와 인덱스
     배열의 길이는 0이나 int범위의 양의 정수이어야 한다.
     
     **자바에서는 JVM이 모든 배열의 길이를 별도로 관리**하며, '배열이름.length'를 통해서 배열의 길이에 대한 정보를 얻을 수 있다. 배열은 한번 생      성하면 길이를 변경할 수 없기 때문에, 이미 생성된 배열의 길이는 변하지 않는다. 따라서 '배열이름.length'는 상수다. 즉, 값을 읽을 수만 있을 뿐        변경할 수 없다.
     
     배열의 길이를 변경하는 것은 1) 변경하고자 하는 길이의 배열을 새로 생성하고, 2) 기존 배열의 내용을 새로운 배열에 복사하는 식으로 이루어진다.
     
   - 배열의 초기화
     배열 인덱스별로 값을 초기화해주거나, for문으로 초기화하는 방법 외에도 아래처럼 간편하게 초기화 가능하다.
     ```int[] score = new int[]{100, 99, 98, 100, 100}; // 배열의 생성과 초기화를 간편하게!
      int[] score = {100, 99, 98, 100, 100}; // 배열의 선언과 정의를 동시에하는 경우에는 new int[]를 생략 가능! 따로하면 생략 불가```
     괄호 {}안에 아무것도 안넣으면, 길이가 0인 배열이 생성된다.
     
   - 배열의 출력
     배열의 모든 요소를 출력하고 싶을 때, print와 for문의 조합으로 출력하는 방법 외에도 Arrays.toStirng()을 사용하면, 해당 배열의 모든 요소를 출      력 가능하다. 단 java.util을 import해와야한다.
     
     한편 C언어에서와 달리, 배열이름을 그대로 출력하더라도 '배열의 주소'가 출력되는 것이 아니라, '타입@내부주소'가 출력된다. 내부주소는 실제주소와      다르므로 딱히 의미있는 정보가 아니다.
     
     예외적으로 char배열은 println 메서드로 출력하면 각 요소가 구분자 없이 그대로 출력된다. println이 원래 그렇게 설계되었기 때문.
     
   - 배열의 복사
     방법 1. for문을 통한 복사
     1) 새로운 배열을 생성 2) for문 통해 인덱스별 값을 복사 3) 피복사대상 배열의 참조변수에 새로 생성한 배열의 참조변수를 저장한다. 그럼 피복사대      상 배열의 참조변수는 새로 생성한 배열을 가리키게 되고, 기존에 가리키고 있던 피복사대상 배열은 JVM의 가바지 컬렉터에 의해서 자동적으로 메모리에      서 삭제된다. 배열은 참조변수를 통해서만 접근할 수 있기 떄문에, 자신을 가리키는 참조변수가 없는 배열은 사용할 수 없기 때문이다.
     
     방법 2. system.arraycopy()를 이용한 복사.
     
 - String 배열
   문자열을 char배열로 다루는 C언어와 달리, Java에는 String클래스를 활용하여 문자열처리를 하는게 보통이다. String 배열은 char배열에 여러 가지 기    능(메서드)을 추가하여 확장한 것이다. 이건 Java가 객체지향개념이 나오고 나서의 언어이다보니, 데이터와 그에 관련된 기능을 하나의 클래스에 묶어서      다룰 수 있게 한 것이라고 볼 수 있다.
   char 배열과 String 클래스의 큰 차이 중 하나는 String 객체(문자열)는 읽을 수만 있을 뿐 내용을 변경할 수 없다는 것이다. 변경 가능한 문자열을 다    루려면, StringBuffer 클래스를 사용하면 된다.
   
   한편, Scanner클래스의 nextLine()외에도 커맨드라인을 통해 사용자로부터 값을 입력받을 수 있다.
   
 - 다차원 배열
   2차원 배열도 괄호{}를 사용해서 생성과 초기화를 동시에 할 수 있다. 예시는 아래와 같다.
   ```
       int[][] score = {
           {100, 100, 100}
           , {20, 20, 20}
           , {30, 30, 30}
           , {40, 40, 40}
           , {50, 50, 50}
       }
   ```
   이 때, `score.length`는 score가 참조하고 있는 배열의 길이이므로 5이다. 'score[0].length'는 score[0]이 참조하는 배열의 길이이므로 3이다.

 - 가변 배열
   2차원 이상의 다차원 배열을 생성할 때 전체 배열 차수 중 마지막 차수의 길이를 지정하지 않고, 추후에 각기 다른 길이의 배열을 생성하여 유동적인 가변 배열을 구성할 수 있다.
   `int[][] score = new int[5][];` 처럼 선언 및 정의하고, 각 행마다 다른 길이의 배열을 생성할 수 있는 것이다.
   
----
### 객체지향언어

 - 객체와 인스턴스
   클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화(instantiate)라고 하며, 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스(instance)라    고 한다. 객체는 **속성(멤버변수, 특성, 필드, 상태)**과 **기능(메서드, 함수, 행위)**의 집합이라고 할 수 있고, 클래스는 객체를 정의한 것이      다.
   
 - 인스턴스의 생성과 사용
   
   ```
   Tv t;
   t = new Tv();
   ```
   위 예시처럼 생성할 경우, 다음 단계를 거친다. 
   1) 메모리에 참조변수 t를 위한 공간이 마련되고, 
   2) 연산자 new에 의해 Tv클래스의 인스턴스가 메모리의 빈 공간에 생성되고, 동시에 멤버변수는 각 자료형에 해당하는 기본값으로 초기화 된다. 
   3) 이후 대입연산자(=)에 의해서 생성된 객체의 주소값이 참조변수 t에 저장된다. 이때부터 참조변수 t를 통해 Tv인스턴스에 접근할 수 있다.
   
 - 객체 배열
   객체도 배열로 다루는 것이 가능하며, 이 때 객체 배열안에는 각 객체의 주소가 저장된다. 이 때 배열과 동일하게 같은 타입의 인스턴스만 저장가능하다.
   
 - 클래스의 또 다른 정의
   - 데이터 저장개념은 아래 순서대로 발전해왔다.
     1. 변수: 하나의 데이터를 저장할 수 있는 공간
     2. 배열: 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
     3. 구조체: 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
     4. 클래스: 데이터와 함수의 결합(구조체+함수), 변수(데이터)와 함수를 하나의 클래스에 정의하여 서로 관계가 깊은 변수와 함수들을 함께 다룰 수 있      게 했다.
   - 사용자정의 타입
     Java에서는 클래스가 곧 사용자정의 타입이다. 
