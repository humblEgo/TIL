### JAVA에 대해 알게된 것 기록
소프트웨어 장인을 목표로 하는데 도움이 되는 패턴을 모아둔 책인 '프로그래머의 길, 멘토에게 묻다'에 적혀있는 '잔을 비우다'>'첫번째 언어' 패턴을 실천하기 위해, JAVA의 정석을 정독하고 기억해둘 만한 내용을 적습니다.
'무지를 드러내자'는 생각으로 애매하면 그냥 다 적을 것.

 - [변수](#변수)
 - [연산자](#연산자)
 - [조건문과 반복문](#조건문과-반복문)
 - [배열](#배열)
 - [객체지향언어](#객체지향언어)
 - [예외처리](#예외처리)
 - [java.lang패키지와 유용한 클래스](#java.lang패키지와-유용한-클래스)
 ----
 ### 변수
 
  - 상수와 리터럴(constant & literal)
    - 리터럴의 타입과 접미사  
  
    |종류|리터럴|접미사|
    |----|----|----|
    |논리형|false, true|없음|
    |정수형|123, 0b0101, 077, 0xFF, 100L|long 타입이면 L, **int 타입이면 생략(byte와 short타입 리터럴은 없어서 int타입 리터럴 사용)**|
    |실수형| 3.14, 3.0e8, 1.4f, 0x1.0p-1|float타입이면 f, double 타입이면 d(**생략가능**)|
    |문자형|'a','1','\n'|없음|
    |문자열|"ABC","123","A","true"|없음|
    
      리터럴의 접두사와 접미사는 대소문자를 구별하지 않는다. 리터럴에 소수점이나 10의 제고븡ㄹ 나타내는 기호 E 또는 e가 포함되어있어도 실수형 리터럴도 간주된다.
  
      기호 p를 이용하면 실수 리터럴을 16진 지수형태로 표현할 수 있다.
      `ex) 0xp1 = (1*16^0)*2^1 =1.0*2 = 2.0`
    
    - 문자 리터럴과 문자열 리터럴
    
      문자 리터럴은 반드시 ''안에 하나의 문자가 있어야한다. 문자열 리터럴은 ""처럼 공백표시 가능.
   
      원래 String은 클래스이므로 아래와 같이 객체를 생성하는 연산자 new를 사용해야 하지만 특별히 그냥 new없이 정의할 수도 있다. 전자의 경우 일반적인 클래스와 같이 heap 내에 객체 레퍼런스 주소를 가진다. 후자의 경우 heap 내의 string constant pool에 저장된다.
   
      **tip: 덧셈 연산자의 경우, 피연산자 중 어느 한 쪽이 String이면 나머지 한 쪽을 먼저 String으로 변환한 다음 두 Stirng을 결합한다. 문자열 변환할 때 편하다.**
    
    - 정수형
    
      정수형의 선택기준으로 정수값의 범위에 따라 정수형을 선택하여 메모리를 절약할 수도 있지만 이는 선택할 문제다. 
      byte와 short는 표현가능한 크기가 작아서 범위를 넘을 위험에 더 쉽게 노출되고, JVM의 피연산자 스택이 피연산자를 4 byte 단위로 저장하기 떄문에 크기가 4 byte보다 작은 자료형의 값을 계산할 때는 4 byte로 변환하여 연산이 수행된다. 
      따라서 오히려 int를 사용하는 것이 더 효율적이다. **웬만하면 정수쓸 때 int쓰고, int의 표현범위를 넘거나 메모리가 부족할 때 다른 정수형을 선택하자.**      
    
    - 실수형
    
      실수형에서 오버플로우될 경우, 변수의 값은 무한대가 된다, 또한 정수형과 달리 언더플로우(underflow)가 있는데, 이는 실수형으로 표현할 수 없는 양의 최소간보다 작은 값이 되는 경우로, 변수의 값이 0이 된다.
      정밀도 이슈가 있으므로 연산속도의 향상이나 메모리를 절약하려면 float를 선택하고, 더 큰 값의 범위나 더 높은 정밀도가 필요하면 double을 선택하자.
    
   
    - 형변환
      형변형 연산자는 그저 피연산자의 값을 읽어서 지정된 타입으로 형변환하고 그 결과를 반환할 뿐이므로, 피연산자인 변수 d의 값은 형변환 후에도 아무런 변화가 없다.
     
      정수형 --> 실수형으로 변환시
      실수형이 정수형보다 훨씬 큰 저장범위를 갖기 때문에, 정수형을 실수형으로 변환하는 것은 별 무리가 없다. 단, int는 최대 10자리의 정밀도를 요구하는데 반면 float는 10진수로 약 7자리의 정밀도만을 제공하므로, int에서 float로 변환할 때는 정밀도 차이에 의한 오차가 발생할 수 있다. 이럴 땐 double을 쓰자.
     
      실수형 --> 정수형으로 변환시
      소수점이 다 버려짐.
     
      자동형변환(산술변환)
      따로 형변환 지정안했을 때, 컴파일러가 기존의 값을 최대한 보존할 수 있는 타입으로 형변환을 자동적으로 추가하는 것. 값 손실 날 경우 에러 메세지로 알린다.
   
   
----
### 연산자

 - 연산자의 우선순위와 결합규칙
 
   - 산술변환(usual arithmetic conversion)
     두 피연산자의 타입이 일치해야 연산이 가능하다. 컴파일러가 연산 전에 피연산자 타입의 일치를 위해 자동 형변환하는 것을 '산술 변환'이라고 한다.        이 때, 두 피연산자의 타입을 같게 일치시키는 것 외에도 피연산자의 타입이 int보다 작은 타입이면 int로 변환하는 규칙이 적용된다. 이유는 정수형        처리시 int가 효율적이고 오버플로우가 발생할 확률이 낮기 때문이다.
   
 - 산술연산자
 
   - 사칙연산자: `char c1 = 'a' + 1;`의 경우, 리터럴 간의 연산이기 때문에 int로 산술변환되지 않고 char형을 유지한다. 유니코드상에서 소문자를 대문      자로 변경하려면 32를 더하면 된다.
     한편, int간의 나눗셈을 수행하면 결과가 int이므로 소수점이하 값들은 버려진다. 이를 이용하면 실수의 소수점 n번째자리까지만 추출하거나 n번째까지      만 추출하되 n+1번째에서 반올림하도록 처리 가능하다.
     ```
     ex) double pi = 3.141592;
     double shortPi = (int)(pi*1000 + 0.5) / 1000.0;
     ```
   - 나머지 연산자 %: 피연산자로 정수만 허용한다.
   
 - 비교 연산자
 
   - 문자열의 비교
     두 문자열의 **내용**을 비교할 때는, 비교 연산자 '=='대신 equals()라는 메서드를 사용해야 한다. 서로 다른 객체라도 내용이 같으면 equals()는        true를 반환한다. 한편 내용이 같더라도 서로다른 객체라면 '=='로 비교시 false가 나온다.
     대문자 소문자 구분않고 비교할 땐, equalsIgnoreCase() 메서드 활용할 것.
     
 - 논리 연산자
 
   - 논리 연산자 &&, ||, !
     문자는 'a'부터 'z'까지, 'A'부터 'Z'까지도 연속적으로 배치되어 있으므로, 논리 연산자를 통해 문자 ch는 대문자 또는 소문자라는 것을 판별하려면        아래와 같이 연산해서 판별가능하다. 소문자 여부부터 판별하는 것은, 사용자로부터 문자를 입력받을 때 사용자가 대문자보다 소문자를 입력할 확률이        높다고 판단했기 때문.
     `('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z')`
     
   - 대입 연산자 =, op=
     대입 연산자는 연산자들 중에서 가장 낮은 우선순위를 가지고 있기 떄문에 식에서 제일 나중에 수행된다. 연산 진행 방향이 오른쪽에서 왼쪽이다.
     
     대입 연산자의 왼쪽 피연산자를 'lvalue'라고 하고, 오른쪽 피연산자를 'rvalue'라고 한다. rvalue는 변수뿐만 아니라 식이나 상수 등이 모두 가능한      반면, lvalue는 반드시 변수처럼 값을 변경할 수 있는 것이어야 한다.
   
   
----     
### 조건문과 반복문

   - switch-case문
   
     switch 조건식의 결과는 정수 또는 문자열이어야하고, case문의 값은 정수 상수만 가능하며, 중복되지 않아야 한다.
     로그인한 사용자의 등급(level)을 체크하여, 등급에 맞는 권한을 부여하는 방식으로 응용할 수 있다.
     
     tip: 특정 범위의 난수를 구할 경우, `Math.random()` 값을 사용하는데, 이 메서드는 0.0과 1.0 사이의 범위에 속하는 double 값을 하나 반환하므        로, Math.random()에 n을 곱하고, int로 형변환 하면 된다. 
   
   - 반복문
   
     JDK1.5부터 **배열과 컬렉션**에 저장된 요소에 접근할 때 `for( 타입 변수명 : 배열 또는 컬렉션) {}` 형식으로 for문 작성이 가능해졌다. 다만, 이      경우엔 일반적인 for문과 달리 배열이나 컬렉션에 저장된 요소들을 읽어오는 용도로만 사용할 수 있다는 제약이 있다.
     
   - continue문
   
     continue문은 반복문 내에서만 사용될 수 있으며, 반복이 진행되는 도중에 continue문을 만나면 반복문의 끝으로 이동하여, for문의 경우 증감식으로,      while문과 do-while문은 조건식으로 이동한다.
     
   - 이름 붙은 반복문
   
     반복문에 이름을 붙이고, break문에 이름을 지정해 줌으로써 하나 이상의 반복문을 벗어나거나 반복을 건너뛸 수 있다.
     
----
### 배열

   - 배열이란?
   
     Java에서의 배열은 **같은 타입**의 여러 변수를 하나의 묶음으로 다루는 것이다. 여러개의 변수를 선언하는 것과 달리 인덱스에 따른 각 저장공간이        연속적으로 배치된다.
     
   - 배열의 길이와 인덱스
   
     배열의 길이는 0이나 int범위의 양의 정수이어야 한다.
     
     **자바에서는 JVM이 모든 배열의 길이를 별도로 관리**하며, '배열이름.length'를 통해서 배열의 길이에 대한 정보를 얻을 수 있다. 배열은 한번 생      성하면 길이를 변경할 수 없기 때문에, 이미 생성된 배열의 길이는 변하지 않는다. 따라서 '배열이름.length'는 상수다. 즉, 값을 읽을 수만 있을 뿐        변경할 수 없다.
     
     배열의 길이를 변경하는 것은 1) 변경하고자 하는 길이의 배열을 새로 생성하고, 2) 기존 배열의 내용을 새로운 배열에 복사하는 식으로 이루어진다.
     
   - 배열의 초기화
   
     배열 인덱스별로 값을 초기화해주거나, for문으로 초기화하는 방법 외에도 아래처럼 간편하게 초기화 가능하다.
     ```int[] score = new int[]{100, 99, 98, 100, 100}; // 배열의 생성과 초기화를 간편하게!
      int[] score = {100, 99, 98, 100, 100}; // 배열의 선언과 정의를 동시에하는 경우에는 new int[]를 생략 가능! 따로하면 생략 불가```
     괄호 {}안에 아무것도 안넣으면, 길이가 0인 배열이 생성된다.
     
   - 배열의 출력
   
     배열의 모든 요소를 출력하고 싶을 때, print와 for문의 조합으로 출력하는 방법 외에도 Arrays.toStirng()을 사용하면, 해당 배열의 모든 요소를 출      력 가능하다. 단 java.util을 import해와야한다.
     
     한편 C언어에서와 달리, 배열이름을 그대로 출력하더라도 '배열의 주소'가 출력되는 것이 아니라, '타입@내부주소'가 출력된다. 내부주소는 실제주소와      다르므로 딱히 의미있는 정보가 아니다.
     
     예외적으로 char배열은 println 메서드로 출력하면 각 요소가 구분자 없이 그대로 출력된다. println이 원래 그렇게 설계되었기 때문.
     
   - 배열의 복사
   
     방법 1. for문을 통한 복사
     
     1) 새로운 배열을 생성 2) for문 통해 인덱스별 값을 복사 3) 피복사대상 배열의 참조변수에 새로 생성한 배열의 참조변수를 저장한다. 그럼 피복사대      상 배열의 참조변수는 새로 생성한 배열을 가리키게 되고, 기존에 가리키고 있던 피복사대상 배열은 JVM의 가바지 컬렉터에 의해서 자동적으로 메모리에      서 삭제된다. 배열은 참조변수를 통해서만 접근할 수 있기 떄문에, 자신을 가리키는 참조변수가 없는 배열은 사용할 수 없기 때문이다.
     
     방법 2. system.arraycopy()를 이용한 복사.
     
 - String 배열
 
   문자열을 char배열로 다루는 C언어와 달리, Java에는 String클래스를 활용하여 문자열처리를 하는게 보통이다. String 배열은 char배열에 여러 가지 기    능(메서드)을 추가하여 확장한 것이다. 이건 Java가 객체지향개념이 나오고 나서의 언어이다보니, 데이터와 그에 관련된 기능을 하나의 클래스에 묶어서      다룰 수 있게 한 것이라고 볼 수 있다.
   
   char 배열과 String 클래스의 큰 차이 중 하나는 String 객체(문자열)는 읽을 수만 있을 뿐 내용을 변경할 수 없다는 것이다. 변경 가능한 문자열을 다    루려면, StringBuffer 클래스를 사용하면 된다.
   
   한편, Scanner클래스의 nextLine()외에도 커맨드라인을 통해 사용자로부터 값을 입력받을 수 있다.
   
 - 다차원 배열
 
   2차원 배열도 괄호{}를 사용해서 생성과 초기화를 동시에 할 수 있다. 예시는 아래와 같다.
   ```
       int[][] score = {
           {100, 100, 100}
           , {20, 20, 20}
           , {30, 30, 30}
           , {40, 40, 40}
           , {50, 50, 50}
       }
   ```
   이 때, `score.length`는 score가 참조하고 있는 배열의 길이이므로 5이다. 'score[0].length'는 score[0]이 참조하는 배열의 길이이므로 3이다.

 - 가변 배열
 
   2차원 이상의 다차원 배열을 생성할 때 전체 배열 차수 중 마지막 차수의 길이를 지정하지 않고, 추후에 각기 다른 길이의 배열을 생성하여 유동적인 가변 배열을 구성할 수 있다.
   `int[][] score = new int[5][];` 처럼 선언 및 정의하고, 각 행마다 다른 길이의 배열을 생성할 수 있는 것이다.
   
----
### 객체지향언어

 - 객체와 인스턴스
 
   클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화(instantiate)라고 하며, 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스(instance)라    고 한다. 객체는 **속성(멤버변수, 특성, 필드, 상태)**과 **기능(메서드, 함수, 행위)**의 집합이라고 할 수 있고, 클래스는 객체를 정의한 것    이다.
   
 - 인스턴스의 생성과 사용
   
   ```
   Tv t;
   t = new Tv();
   ```
   위 예시처럼 생성할 경우, 다음 단계를 거친다. 
   
   1) 메모리에 참조변수 t를 위한 공간이 마련되고,    
   2) 연산자 new에 의해 Tv클래스의 인스턴스가 메모리의 빈 공간에 생성되고, 동시에 멤버변수는 각 자료형에 해당하는 기본값으로 초기화 된다. 
   3) 이후 대입연산자(=)에 의해서 생성된 객체의 주소값이 참조변수 t에 저장된다. 이때부터 참조변수 t를 통해 Tv인스턴스에 접근할 수 있다.
   
 - 객체 배열
 
   객체도 배열로 다루는 것이 가능하며, 이 때 객체 배열안에는 각 객체의 주소가 저장된다. 이 때 배열과 동일하게 같은 타입의 인스턴스만 저장가능하다.
   
 - 클래스의 또 다른 정의
 
   - 데이터 저장개념은 아래 순서대로 발전해왔다.
   
     1. 변수: 하나의 데이터를 저장할 수 있는 공간
     2. 배열: 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
     3. 구조체: 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
     4. 클래스: 데이터와 함수의 결합(구조체+함수), 변수(데이터)와 함수를 하나의 클래스에 정의하여 서로 관계가 깊은 변수와 함수들을 함께 다룰 수 있      게 했다.
     
   - 사용자정의 타입
   
     Java에서는 클래스가 곧 사용자정의 타입이다. 

 - 변수와 메서드
 
   변수는 **선언된 위치**에 따라 클래스변수, 인스턴스변수, 지역변수의 세 종류로 나뉜다. 클래스 영역에 선언된 멤버변수 중 static이 붙은 것은 클래    스 변수, 붙지 않은 것은 인스턴스변수이다. 멤버변수를 제외한 나머지 변수들은 모두 지역변수이다.
   
   - 인스턴스변수: 클래스 영역에 선언되며 클래스의 인스턴스를 생성할 때 만들어진다. 따라서 인스턴스를 생성해야 사용할 수 있다.
   - 클래스변수: 클래스가 메모리에 올라갈 때 만들어지며 프로그램이 종료될 때까지 유지된다. 따라서 인스턴스를 생성하지 않고도 
     '클래스이름.클래스변수'와 같은 방식으로 사용할 수 있다. 
     만약 public을 앞에 붙이면 같은 프로그램 내에서 어디서나 접근할 수 있는 전역변수의 성격을 가지게 된다.
   - 지역변수: 스코프 내에서만 사용가능하며 스코프를 벗어나면 소멸된다.
   
 - 메서드의 호출
 
   - 메서드의 실행흐름
   
     같은 클래스 내의 메서드끼리는 참조변수를 사용하지 않고도 서로 호출이 가능하지만, static메서드는 같은 클래스 내의 인스턴스 메서드를 호출할 수      없다.
     
 - return문
 
   return문은 현재 실행중인 메서드를 종료하고 호출한 메서드로 되돌아간다. 메서드의 반환타입이 void가 아닌 경우, 반환값이 반드시 필요하며, 조건문을    썼을 때는 조건이 true가 아닌 경우에도 MECE하게 return값이 설정되어있어야 한다.
   
 - JVM의 메모리 구조
 
   응용 프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고 JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어    관리한다. 그 중 주요 영역 3가지를 꼽아보자면 아래와 같다.
   
   1. 메서드 영역(method area)
   
      프로그램 실행 중 클래스가 사용되면 JVM은 해당 클래스의 클래스파일(\*.class)을 읽고 분석하여 클래스에 대한 정보(클래스 데이터)를 이 곳에 저장       한다. 이 때, 그 클래스의 클래스변수도 이 영역에 함께 생성된다.
      
   2. 힙(heap)
   
      인스턴스가 생성되는 공간. 즉, 인스턴스 변수들이 생성되는 공간이다. 
      
   3. 호출스택(call stack 또는 execution stack)
   
      메서드의 작업에 필요한 메모리 공간을 제공한다. 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당되며, 이 메모리는 메서드가 작       업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용된다. 그리고 메서드가 작업을 마치면 할당되었던 메모리공간       은 반환되어 비워진다.
 
 - 기본형 매개변수와 참조형 매개변수
 
   메서드를 호출할 때 매개변수로 지정한 값을 메서드의 매개변수에 복사해서 넘겨준다. 기본형 매개변수는 변수의 값을 읽어올 수 있지만, 참조형 매개    변수는 값이 저장된 곳의 주소를 알 수 있기 떄문에 값을 읽어오는 것은 물론 값을 변경하는 것도 가능하다.
 
   반환타입이 참조형일 경우, 메서드가 '객체의 주소'를 반환하는 것을 말한다.
   
 - 재귀호출(recursive call)
   
   재귀호출은 메서드의 내부에서 메서드 자신을 다시 호출하는 것을 말하며 대부분 반복문으로 구현 가능하다. 반복문에 비해 '매개변수 복사'와 '종료 후 복귀할 주소저장' 등이 추가로 필요하기 때문에 수행시간이 더 걸린다는 단점을 가지고 있지만, 논리적으로 간결하기 때문에 쓰인다.
   
 - 클래스 메서드와 인스턴스 메서드
 
   메서드의 작업내용 중에서 인스턴스변수를 필요로 한다면, static을 붙일 수 없다. 반대로 인스턴스변수를 필요로 하지 않는다면 static을 붙이는 것이 바람직하다. 메서드 호출시간이 짧아지므로 성능이 향상되기 떄문이다. 
   
   같은 클래스에 속한 멤버들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조 또는 호출이 가능하다. 단, 클래스멤버가 인스턴스 멤버를 참조 또는 호출하고자 하는 경우에는 인스턴스를 생성해야한다. (인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만, 클래스멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수도 있기 때문이다.)
   
 - 오버로딩
 
 **한 클래스 내**에 같은 이름의 메서드를 여러 개 정의하는 것이며, 1) 메서드 이름이 같고 2) 매개변수의 개수 또는 타입이 달라야한다. 안그러면 중복 정의로 간주되어 컴파일 에러가 발생한다. 오버로딩된 메서드들 간에는 넘겨주는 매개변수 값의 타입에 따라 하나가 선택되어 실행된다. 
 
 - 가변인자
 
 메서드의 매개변수 개수가 고정적이지 않은 경우를 가변인자라고 한다. 가변인자는 '타입... 변수명'과 같은 형식으로 선언하며, 가변인자 외에도 매개변수가 더 있다면, 가변인자를 매개변수 중에서 제일 마지막에 선언해야한다. 가변인자는 내부적으로 배열을 이용하는 것이므로, 가변인자가 선언된 메서드를 호출할 때마다 배열이 새로 생성된다는 비효율이 있다. 한편 가변인자를 선언한 메서드를 오버로딩하면, 메서드를 호출했을 때 두 오버로딩된 메서드가 구분되지 않아서 컴파일에러가 발생하기 쉽다.
 
 - 생성자
 
 인스턴스변수들의 초기화에 사용되는 조금 특별한 메서드이다. 인스턴스가 생성될 때 호출되어 인스턴스변수들을 초기화할 때 주로 쓰이며, 인스턴스 생성 시에 실행되어야 할 작업을 위해서도 사용된다. 생성자도 메서드처럼 클래스 내에 선언되며, 구조도 메서드와 유사하지만, **리턴값이 없다는 점이 다르다.** 생성자의 조건은 다음과 같다. **1) 생성자의 이름은 클래스의 이름과 같아야 한다. 2) 생성자는 리턴 값이 없다.** 생성자도 메서드이기 떄문에 리턴값이 없다는 의미의 void를 붙여야 하지만, 모든 생성자가 리턴값이 없으므로 void를 생성할 수 있게 한 것이다. 인스턴스를 생성하기위해 사용하는 `클래스이름()`이 바로 생성자인 것!
 
 - 기본 생성자
 
 사실 모든 클래스에는 반드시 하나 이상의 생성자가 정의되어 있어야 하지만, 클래스에 생성자를 정의하지 않고도 인스턴스를 생성할 수 있는 이유는 컴파일러가 제공하는 '기본 생성자' 덕분이다. 컴파일 할 때 소스파일(\*.java)의 클래스내에 **생성자가 하나도 정의되어 있지 않은 경우** 컴파일러는 자동적으로 `클래스이름() { }`과 같은 내용의 기본 생성자를 추가하여 컴파일 한다. (클래스의 접근 제어자가 public인 경우에는 기본 생성자로 `public 클래스이름() { }`이 추가된다.
 
 다음 조건을 만족할 경우, 같은 클래스의 멤버들 간에 서로 호출할 수 있는 것처럼 생성자 간에도 서로 호출이 가능하다.
 ```
 1) 생성자의 이름으로 클래스 이름 대신 this를 사용한다.
 2) 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.
 ```
 2)의 이유는 생성자 내에서 초기화 작업도중에 다른 생성자를 호출하게 되면, 호추뢴 다른 생성자 내에서도 멤버변수들의 값을 초기화 할 것이므로 다른 생성자를 호출하기 이전의 초기화 작업이 무의미해질 수 있기 때문이다. 'this'는 참조변수로 인스턴스 자신을 가리키고, 인스턴스멤버만 사용할 수 있다. 클래스메서드에서는 인스턴스 멤버들을 사용할 수 없는 것처럼, 'this' 역시 사용할 수 없다.
 
 - 생성자를 이용한 인스턴스의 복사
 
 현재 사용하고 있는 인스턴스와 같은 상태를 갖는(두 인스턴스의 모든 인스터스변수가 동일한 값을 갖고 있는) 인스턴스를 하나 더 만들고자 할 때 생성자를 
이용할 수 있다.

 - 변수의 초기화

 멤버변수(클래스변수와 인스턴스변수)와 배열은 초기화하지 않아도 자동적으로 변수의 자료형에 맞는 기본값으로 초기화가 된다. 따라서 멤버변수의 초기화는 선택적이다. 하지만 지역변수는 자동초기화되지 않으므로, 초기화가 필수적이다.

 - 초기화 블럭
 
 초기화 작업이 복잡하여 명시적 초기화만으로는 부족한 경우 초기화 블럭을 사용한다. 클래스 초기화 블럭과 인스턴스 초기화 블럭이 있다. 클래스 초기화 블럭은 클래스가 메모리에 처음 로딩될 때 한번만 수행되며, 인스턴스 초기화 블럭은 생성자와 같이 인스턴스를 생성할 때 마다 수행된다. 초기화 블럭은 명시적 초기화 다음에 수행된다. 또한 생성자 보다 인스턴스 초기화 블럭이 먼저 수행된다.
 
 - 클래스간의 관계: 상속
 
 자손 클래스는 조상 클래스의 모든 멤버를 상속 받는다. 이 때 생성자와 초기화 블럭은 상속되지 않는다. 클래스간의 관계가 '~은 ~이다(is-a)'가 성립하면 상속시키는게 깔끔한 경우가 많다. 
 
 - 클래스간의 관계: 포함관계
 
 상속이외에 클래스를 재사용하는 방법으로써, 아래 예시처럼 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것. 클래스간의 관계가 '~은 ~을 가지고 있다.(has-a)'가 성립하면 포함시키는게 깔끔한 경우가 많다.
 ```
 class Car {
     Engine e = new Engine();
     Door[] d = new Door[4];
     }
 ```
  
 - 단일 상속
  
   C++과 달리 Java에서는 단일 상속만을 허용한다. 다중 상속을 허용할 경우 복합적인 기능을 가진 클래스를 쉽게 작성할 수 있다는 장점이 있지만, 클래스간 관계가 복잡해지고 서로 다른 클래스로부터 상속받은 멤버간의 이름이 같은 경우 구별할 수 있는 방법이 없다는 단점이 있기 때문이다. Java처럼 단일 상속을 사용하면 클래스 간의 관계가 보다 명확해빚고 코드를 더욱 신뢰할 수 있게 만들어 준다. 대신 클래스를 '포함'시켜서 다중상속처럼 활용할 수 있다.
   
 - 오버라이딩
 
 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것을 말한다. 메서드의 내용만을 새로 작성하는 것이므로 메서드의 선언부는 조상의 것과 완전히 이리해야한다. 결과적으로 
 ```
 자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와 선언부가 같아야한다. 즉,
  - 이름이 같아야 한다. 
  - 매개변수가 같아야한다. 
  - 반환타입이 같아야 한다.
  
 조상 클래스의 메서드를 자손 클래스에서 오버라이딩할 때
  - 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
  - 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.
  - 인스턴스메서드를 static메서드로 또는 그 반대로 변경할 수 없다.
 ```
 
 - super
 
 super는 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수이다.
 
 - super()
 
 조상 클래스의 생성자를 호출하는데 사용된다. 조상 클래스 생성자의 호출은 모든 클래스의 최고 조상인 Object클래스의 생성자인 Object()까지 가서야 끝이 난다. 그래서 Object클래스를 제외한 모든 클래스의 생성자는 첫 줄에 반드시 자신의 다른 생성자 또는 조상의 생성자를 호출해야 한다. 그렇지 않으면 컴파일러는 생성자의 첫 줄에 자동으로 `super();`를 추가한다.
 
 - package

 패키지란 클래스의 묶음이다. 패키지에는 클래스 또는 인터페이스를 포함시킬 수 있다. 클래스의 실제 이름은 패키지명을 포함하고 있어서, 같은 이름의 클래스 일지라도 서로 다른 패키지에 존재하면 이름이 충돌하지 않는다. 아래 규칙이 적용된다.
 ```
 - 하나의 소스파일에는 첫 번째 문장으로 단 한번의 패키지 선언만을 허용한다.
 - 모든 클래스는 반드시 하나의 패키지에 속해야 한다.
 - 패키지는 점(.)을 구분자로 하여 계층구조로 구성할 수 있다.
 - 패키지는 물리적으로 클래스 파일(.class)을 포함하는 하나의 디렉토리이다.
 ```
 참고로 패키지명은 대소문자를 모두 허용하지만, 클래스명과 쉽게 구분하기 위해서 소문자로 명명하는 것을 원칙으로 하고 있다. 소스파일에 자신이 속할 패키지를 지정하지 않은 클래스는 자동적으로 '이름 없는 패키지'에 속하게 된다. 결국 패키지를 지정하지 않는 모든 클래스들은 같은 패키지에 속하는 셈.
 
 - import문
 
 컴파일러에게 소스파일에 사용된 클래스의 패키지에 대한 정보를 제공하는 것. 모든 소스파일(.java)에서 import문은 package문 다음에, 그리고 클래스 선언문 이전에 위치해야 한다. import문은 프로그램의 성능에 전혀 영향을 미치지 않는다. 컴파일 시간이 아주 조금 더 걸릴 뿐. 모든 소스파일에는 묵시적으로 `import java.lang.*;`이라고 선언되어 있다.
 
 - static imort문
 
 import문을 사용하면 클래스의 패키지명을 생략할 수 있는 것과 같이 static import문을 사용하면 static멤버를 호출할 때 클래스 이름을 생략할 수 있다. 
 
 - 제어자(modifier)
 
 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다. 접근 제어자와 그 외의 제어자로 나눌 수 있다.
   - 접근제어자: public, protected, default, private
   - 그 외: static, final, abstract, native, transient, synchronized, volatile, strictfp
 
 tip1) final이 붙은 변수는 상수이므로 일반적으로 선언과 초기화를 동시에 하지만, 인스턴스변수의 경우 생성자에서 초기화 되도록 할 수 있다.
 
 tip2) 하나의 소스파일(\*.java)에는 public클랫가 단 하나만 존재할 수 있으며, 소스파일의 이름은 반드시 public클래스의 이름과 같아야 한다.
 
 tip3) 생성자에 접근 제어자를 사용하여 인스턴스의 개수를 제한할 수 있다. 이 때 public static 메서드를 함께 선언해서 외부에서 이 클래스의 인스턴스를 사용하도록 할 수도 있다. 생성자가 private인 클래스는 다른 클래스의 조상이 될 수 없다. 그래서 클래스 앞에 final을 더 추가하여 상속할 수 없는 클래스라는 것을 알리는 것이 좋다.
 
 - 다형성(polymorphism)
 
 객체지향개념에서 다형성이란 '여러 가지 형태를 가질 수 있는 능력'을 의미하며, 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현하였다. 즉, **조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 하였다**는 것이다.
 
 - 참조변수의 형변환
 
 ```
 자손타입 --> 조상타입 (Up-casting) : 형변환 생략가능
 자손타입 <-- 조상타입 (Down-casting) : 형변환 생략불가
 ```
 위처럼 이뤄지며, 참조변수의 형변환을 통해서, 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위(개수)를 조절하는 것이다. 형변환은 참조변수의 타입을 변환하는 것이지 인스턴스를 변환하는 것은 아니기 때문에 참조변수의 형변환은 인스턴스에 아무런 영향을 미치지 않는다. 서로 상속관계에 있는 타입간의 형변환은 양방향으로 자유롭게 수행될 수 있으나, 참조변수가 가리키는 인스턴스의 자손타입으로 형변환은 허용되지 않는다. 그래서 참조변수가 가리키는 인스턴스의 타입이 무엇인지 확인하는 것이 중요하다.
 
 참고로 instatnceof 연산의 결과가 true라는 것은 검사한 타입으로 형변환이 가능하다는 것을 뜻한다.
 
 매개변수에도 다형성이 있어서, 조상클래스 타입을 매개변수로 받는 메서드에 자손클래스 타입의 매개변수를 넣어도 작동시킬 수 있다.
 
 한편 조상타입의 참조변수 배열을 사용하면, 공통의 조상을 가진 서로 다른 종류의 객체를 배열로 묶어서 다룰 수 있다. 
 
 tip) Vector 클래스는 배열의 크기를 동적으로 관리해주어서 편하게 사용할 수 있다.
 
 - 추상클래스(abstract class)
 
 미완성 메서드를 포함하고 있는 클래스. 특정 기능을 목적으로 작성했다고 주석으로 밝혀적는게 일반적이다. 추상클래스로부터 상속받는 자손클래스 오버라이딩을 통해 추상메서드를 구현해주어야한다. 자손 클래스에서 추상메서드를 반드시 구현하도록 강제할 수 있다는 것이 포인트!
 
 - 인터페이스(interface)
 
 인터페이스는 일종의 추상클래스이다. 인터페잇는 추상클래스처럼 추상메서드를 갖지만 추상클래스보다 추상화 정도가 높아서 추상메서드와 상수만을 멤버로 가질 수 있다. 클래스의 멤버들과 달리 다음과 같은 제약사항이 있다.
   ```
   - 모든 멤버변수는 public static final 이어야 하며, 이를 생략할 수 있다.
   - 모든 메서드는 public abstract 이어야 하며, 이를 생략할 수 있다. (단, static 메서드와 디폴트 메서드는 제외)
   ```
  인터페이스는 인터페이스로부터만 상속받을 수 있으며, 클래스와는 달리 다중상속, 즉 여러 개의 인터페이스로부터 상속을 받는 것이 가능하다. 
 
 - 인터페이스의 구현
 
 클래스가 확장한다는 의미의 키워드 'extends'를 사용한다면, 인터페이스는 구현한다는 의미의 키워드 'implements'를 사용한다. 만일 구현하는 인터페이스의 메서드 중 일부만 구현한다면, abstract를 붙여서 추상클래스로 선언해야 한다. 
 
 tip) 인터페이스의 이름에는 주로 Fightable과 같이 'able'로 끝나는 것들이 많은데, 어떠한 기능 또는 행위를 하는데 필요한 메서드를 제공한다는 의미를 강조하기 위해서이다. 또한 그 인터페이스를 구현한 클래스는 '~를 할 수 있는' 능력을 갖추었다는 의미이기도 하다.
 
 - 인터페이스를 이용한 다형성
 
 다형성에 따라 자손클래스의 인스턴스를 조상타입의 참조변수로 참조하는 것이 가능하듯, 인터페이스 역시 이를 구현한 클래스의 조상이라 할 수 있으므로, 해당 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있으며, 인터페이스 타입으로 형변환도 가능하다. 
 
 인터페이스 타입의 매개변수가 갖는 의미는 메서드 호출 시 해당 인터페이스를 구현한 클래스의 인스턴스를 매개변수로 제공해야한다는 것이다. **리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미한다.**
 
 - 인터페이스의 장점
 
 인터페이스를 사용하는 이유와 장점은 다음과 같다.
   - 개발시간을 단축시킬 수 있다.
      - 선언과 구현의 분리 짱짱..
   - 표준화가 가능하다.
   - 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.
      - 예를 들어 SCV가 탱크, 드랍십은 수리하고 마린은 수리하지 않도록 할 때 유용쓰
   - 독립적인 프로그래밍이 가능하다.
      - 클래스와 클래스간의 직접적인 관계를 인터페이스를 이용해서 간접적인 관계로 변경하면 한 클래스의 변경이 관련된 다른 클래스에 영향을 미치지 않는 독립적인 프로그래밍이 가능해진다.
 
 
----
### 예외처리

 - 에러와 예외
 
 '에러(Error)'는 프로그램 코드에 의해서 수습될 수 없는 심각한 오류를 뜻하고, '예외(Exception)'는 프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류를 뜻한다. 자바에서는 에러와 예외 모두 클래스로 정의하였으며, 따라서 둘 모두 Object클래스의 자손들이다. 상속관계에 따라, Exception 클래스는 1) Exception 클래스와 그 자손들 2) RuntimeException클래스와 그 자손들로 나눌 수 있다. 
 
 - 예외처리하기
 
 예외처리(exception handling)란, 프로그램 실행 시 발생할 수 있는 예기치 못한 예외의 발생에 대비한 코드를 작성하는 것을 뜻한다. 먼저 'try - catch' 구문으로 처리 가능하며 원리는 다음과 같다.
 1. try블럭 안의 코드를 실행하고, 예외가 발생할 경우 발생한 예외에 해당하는 클래스의 인스턴스가 만들어진다.
 2. catch블럭의 괄호()내에 선언된 참조변수의 종류와 생성된 예외클래스의 인스턴스를 instanceof 연산자를 이용해서 감사하여 검사결과가 true인 catch블럭을 만날 때까지 순차적으로 진행한다.
 3. 검사결과가 true인 catch블럭을 찾게 되면 블럭에 있는 문장들을 모두 수행한 후 에 'try - catch'문을 빠져나가고 예외는 처리된다.
 검사결과가 true인 cathc블럭이 없으면 예외는 처리되지 않는다.
 
 모든 예외 클래스는 Exception클래스의 자손이므로, catch블럭의 괄호()에 Exception클래스 타입의 참조변수를 선언해 놓으면 어떤 종류의 예외가 발생하더라도 이 catch블럭에 의해서 처리된다.
 
 두번째로 예외를 메서드에 선언하는 방식으로도 예외를 처리 가능하다. 아래처럼 메서드의 선언부에 키워드 throws를 사용해서 메서드 내에서 발생할 수 있는 예외를 명시해서 처리를 강제하는 것이다.
 ```java
 void method() throws Exception1, Exception2, ... ExceptionN { // 메서드 내용}
 ```
 사실 예외를 메서드의 throws에 명시하는 것은 예외를 처리하는 것이 아니라, 자신(예외가 발생할 가능성이 있는 메서드)을 호출한 메서드에게 예외를 전달하여 예외처리를 떠맡기는 것이다. **결국 어느 한 곳에서는 반드시 try-catch문으로 예외처리를 해주어야 한다.**
 
 - finally 블럭
 
 finally블럭은 try-cath문과 함께 예외의 발생여부에 상관ㅇ벗이 실행되어야할 코ㅡ를 포함시킬 목적으로 사용된다. 
 
 - 연결된 예외(chained exception)
 
 한 예외가 다른 예외를 발생시켰다면, 원인 예외(cause exception)로 등록해서 활용할 수 있다. 그럼 여러가지 예외를 상속관계가 아니어도 하나의 큰 부류의 예외로 묶어서 다룰 수 있으며, checked예외를 unchecked예외로 바꿔서 불필요한 예외처리가 필요없도록 한다. Exception클래스의 조상인 Throwable클래스에 정의되어있는 `initCause()`를 사용가능하다.
 
### java.lang패키지와 유용한 클래스

 - Object클래스: 모든 클래스의 조상, 멤버변수는 없고 오직 11개의 메서드만 가지고 있다. 
   - equals(Object obj): 매개변수를 객체 참조변수로 받아서 비교하여 그 결과를 boolean 값으로 알려주는 역할. 값이 아니라 주소값으로 비교한다. 값을 비교하도록 하고 싶으면 equals메서드를 오버라이딩하여 주소가 아닌 객체에 저장된 내용을 비교하도록 변경하면 된다.
   - hashCode(): 해싱기법에 사용되는 '해시함수'를 구현한 것.
   - toString(): 인스턴스에 대한 정보를 문자열로 제공. 보통 인스턴스나 클래스에 대한 정보 또는 인스턴스 변수들의 값을 문자열로 변환하여 반환하도록 오버라이딩되는 것이 보통이다. String클래스의 toString()은 String인스턴스가 갖고 있는 문자열을 반환하도록 오버라이딩 되어 있고, Date클래스의 경우, Date인스턴스가 갖고 있는 날짜와 시간을 문자열로 변환하여 반환하도록 오버라이딩되어 있다. 오버라이딩할 때 Object클래스에 정의된 toString()의 접근 제어자가 public이므로 참고해서 접근제어자 설정하는게 바람직함.
   - clone(): 자신을 복제해서 새로운 인스턴스를 생성하는 일을 함. 복제할 클래스에 Cloneable인터페이스를 implements해야 쓸 수 있고, clone()을 오버라이딩하는 경우 접근 제어자를 protected에서 public으로 변경해서 상속관계까 없는 다른 클래스에서 clone()을 호출 할 수 있도록 처리한다. 
     - 얕은 복사: clone()은 값만 복사하므로, 객체가 참조하고 있는 객체까지 복제하지는 않는다. 같은 객체를 공유하므로 복사본을 수정시 참조주소가 가리키고 있는 객체도 함께 변경된다.
     - 깊은 복사: 원본이 참조하고 있는 객체까지 복제하는 것. 원본과 복사본이 서로 다른 객체를 참조하므로 원본의 변ㄱ영이 복사본에 영향을 미치지 않는다.
   - getClass(): 자신이 속한 클래스의 Class객체를 반환하는 메서드. Class객체는 클래스의 모든 정보를 담고 있으며, 클래스 당 1개만 존재한다. '클래스 로더'에 의해서 메모리에 클래스파일이 올라갈 때 자동으로 생성된다. 이를 이용하면 동적으로 객체를 생성하고 메서드를 호출 할 수 있음. 쓸거면 '리플렉션 API' 참고하면 됨.
 
 - String클래스: 자바에서는 문자열을 위한 클래스를 따로 제공한다. 중요하니까 파볼 것.
   - 변경 불가능한(immutable)클래스: String클래스를 까보면 아래와 같은데,
   ```java
   public final class String implements java.io.Serializable, Comparable {
       private char[] value;
       ...
       }
   ```
   인스턴스 생성 시 생성자의 매개변수로 입력받는 문자열을 인스턴스변수에 문자형 배열로 저장된다. 
   
   - 문자열 리터럴: 자바 소스파일에 포함된 문자열 리터럴은 컴파일 시에 클래스 파일에 저장된다. 
   
   - 빈 문자열: String에는 char와 달리 빈문자열 생성 가능하다. C언어에서는 문자열의 끝에 null 문자를 항상 붙이지만, 자바에선느 null 문자를 사용하지 않고, 문자열의 길이 정보를 따로 저장한다.
   
   -String클래스의 생성자와 메서드: 한번은 훑어야지..!
     - Stirng(String s): 주어진 문자열을 갖는 Stirng 인스턴스를 생성.
     - String(char[] value): 주어진 문자열을 갖는 String 인스턴스를 생성.
     - String(StringBuffer buf): StirngBuffer인스턴스가 갖고 있는 문자열과 같은 내용의 String인스턴스를 생성.
     - char charAt(int index): 지정된 위치에 있는 문자를 알려줌.
     - int compareTo(String str): 문자열과 사전순서로 비교한다. 같으면 0을, 사전순으로 이전이면 음수를, 이후면 양수를 반환한다.
     - String concat(String str): 문자열을 뒤에 덧붙인다.
     - boolean contains(CharSequence s): 지정된 문자열이 포함되었는지 검사한다.
     - boolean endsWith(String suffix): 지정된 문자열로 끝나는지 검사한다.
     - boolean equals(Object obj): 매개변수로 받은 문자열과 String 인스턴스의 문자열을 비교한다. '내용'을 비교하는 것!
     - boolean equalsIgnoreCase(String str): 문자열과 String인스턴스의 문자열을 대소문자 구분없이 비교한다.
     - int indexOf(int ch): 주어진 문자가 문자열에 존재하는지 확인하여 위치를 알려준다. 못 찾으면 '-1'을 반환한다.
     - int indexOf(int ch, itn pos): 주어진 문자가 문자열에 존재하는지 지정된 위치부터 확인하여 위치를 알려준다. 못 찾으면 -1을 반환한다.
     - int indexOf(String str): 주어진 문자열이 존재하는지 확인하여 그 위치를 아렬준다. 없으면 -1을 반환한다.
     - String intern(): 문자열을 상수풀에 등록한다. 이미 상수풀에 같은 내용의 문자열이 있을 경우 그 문자열의 주소값을 반환한다.
     - int lastIndexOf(int ch): 지정된 문자 또는 문자코드를 문자열의 오른쪽 끝에서부터 찾아서 위치를 알려준다. 못 찾으면 -1 반환.
     - int lastIndexOf(String str): 지정된 문자열을 인스턴스의 문자열 끝에서부터 찾아서 위치를 알려준다. 못 찾으면 -1 반환.
     - int length(): 문자열의 길이를 알려준다.
     - String replace(char old, char nw): 문자열 중의 문자를 새로운 문자로 바꾼 문자열을 반환한다.
     - String replace(CharSequence old, CharSequence nw): 문자열 중에서 문자열을 새로운 문자열로 모두 바꾼 문자열을 반환한다.
     - String replaceAll(String regex, Strign replacement): 문자열 중에서 지정된 문자열과 일치하는 것을 새로운 문자열로 모두 변경한다.
     - String replaceFirst(String regex, String replacement): 문자열 중에서 지정된 문자열과 일치 하는 것 중, 첫 번쨰 것만 새로운 문자열로 변경한다.
     - String[] split(String regex): 문자열을 지정된 분리자로 나누어 문자열 배열에 담아 반환한다.
     - String[] split(String regex, int limit): 문자열을 지정된 분리자로 나누어 문자열배열에 담아 반환한다. 단, 문자열 전체를 지정된 수로 자른다.
     - boolean startsWith(String prefix): 주어진 문자열로 시작하는지 검사한다.
     - String substring(int begin, int end): 주어진 시작위치부터 끝 위치 범위에 포함된 문자열을 얻는다. 이 때, 시작위치의 문자는 범위에 포함되지만(<=), 끝 위치의 문자는 포함되지 않는다.(<)
     - String toLowerCase(): String인스턴스에 저장되어있는 모든 문자열을 소문자로 변환하여 반환한다.
     - String toUpperCase(): String인스턴스에 저장되어있는 모든 문자열을 대문자로 변환하여 반환한다.
     - String toString(): String인스턴스에 저장되어 있는 문자열을 반환한다.
     - String trim(): 문자열의 왼쪽 끝과 오른쪽 끝에 있는 공백을 없앤 결과를 반환한다. 이 때 문자열 중간에 있는 공백은 제거되지 않는다.
     - static String valueOf(데이터형 변수): 지정된 값을 문자열로 변환하여 반환한다. 참조변수의 경우, toString()을 호출한 결과를 반환한다.
     
 - join()과 StringJoiner
 
 join()은 여러 문자열 사이에 구분자를 넣어서 결합한다. 
 
 - 문자 인코딩 변환
 
 getBytes(Sring charsetName)을 이용하면 문자열의 문자 인코딩을 다른 인코딩으로 변경할 수 있다.
 
 - String.format(): printf()하고 사용법이 완전히 똑같음.
 
 - String을 기본형 값으로 변환
 
 valueOf()를 쓰거나 parseInt()를 쓰면 된다. valueOf(String s)는 메서드 내부에서 그저 parseInt(String s)를 호출할 뿐이므로 두 메서드는 반환 타입만 다르지 같은 메서드이다.
 ```java
 //예시
 int i = Integer.parseInt("100"); 
 int i2 = Integer.valueOf("100"); //원래 valueOf()의 반환 타입은 Integer인데, 오토박싱으로 인해 int로 자동형변환된다.
 ```
 이런 메서드를 쓸 때 문자열에 공백 또는 문자가 포함되어 있는 경우 변환시 예외가 발생할 수 있으므로 trim()을 습관적으로 사용하여 문자열 양끝의 공백을 제거해주자!!
 
 - StringBuffer클래스
 
 String클래스는 인스턴스를 생성할 때 지정된 문자열을 변경할 수 없지만 StringBuffer클래스는 변경이 가능하다. 내부적으로 문자열 편집을 위한 버퍼가 있고, 인스턴스 생성시 크기 지정이 가능하다. 크기 지정안하면 16개의 문자를 저장할 수 있는 크기의 버퍼를 생성한다. 뜯어보면 아래같은 코드가 들어있다.
 ```java
 // 새로운 길이(newCapacity)의 배열을 생성한다. newCapacity는 정수값이다.
 char newValue[] = new char[newCapacity];
 
 //배열 value의 내용을 배열 newValue에 복사한다.
 System.arraycopy(value, 0, newValue, 0); // count는 문자열의 길이
 value = newValue; // 새로 생성된 배열의 주소를 참조변수 value에 저장.
 ```
 
   - append()
   
   append()는 반환타입이 StringBuffer여서 **자신의 주소를 반환**한다. 따라서 아래처럼 연속해서 append()를 호출할 수도 있다.
   ```java
   StringBuffer sb = new StringBuffer("abc");
   sb.append("123").append("zz");
   ```
   
   - StringBuffer의 비교
   
   StringBuffer에서는 toString()과 다르게 equals메서드가 오버라이딩 되어있지 않아서 등가비교연산자(==)와 동일하게 작동한다. 따라서 값만 비교하려면 toString()을 호출해서 String 인스턴스를 얻은 다음, 여기에 equals메서드를 사용해서 비교해야한다.
   ```java
   //예시
   String s = sb.toString();
   String s2 = sb2.toString();
   
   System.out.println(s.equals(s2)); //true
   ```
   
 - StringBuilder클래스
 
 StringBuffer는 멀티쓰레드에 안전(thread safe)하도록 동기화되어있다. 때문에 멀티쓰레드로 작성된 프로그램이 아닌 경우, STringBuffer의 동기화는 불필요하게 성능만 떨어뜨리게 된다. 그래서 StringBuffer에서 쓰레드의 동기화만 뺀 것이 StringBuilder가 추가되었다!
 
 - Math클래스
 
 Math클래스의 생성자는 접근 제어자가 private이기 떄문에 다른 클래스에서 Math인스턴스를 생성할 수 없도록 되어있다. 클래스 내에 인스턴스변수가 하나도 없어서 인스턴스를 생성할 필요가 없기 때문. Math클래스의 메서드는 모두 static이다.
 
   - static long round(double이나 float a): 소수점 첫 째자리에서 반올림하고 long값 반환함. 매개변수 값이 음수일 때 rint()랑 값 다르니까 주의.
   - static double rint(double a): 소수점 첫 째자리에서 반올림하고 double값 반환함. 매개변수 값이 음수일 때 round()랑 값 다르니까 주의.
   - sqrt(): 제곱근을 계산해줌.
   - pow(): n제곱을 계산해줌.
   - 삼각함수는 매개변수의 단위가 라디안이다. 라디안 값을 넣어주거나 아니면 toRadians(double angdeg)를 이용하자.
   - atan2메서드는 직각 삼각형에서 두 변의 길이 a,b를 알면 끼인각을 구해줌. 결과값은 라디안임. 도(degree)로 변환하려면 '180/PI'를 곱하거나 toDegree(double angrad)를 이용하면 된다.
   - static 데이터타입 abs(데이터타입 변수명): 절대값 반환.
   - static double ceil(double a): 올림
   - static double floor(double a): 내림
   - static 데이터타입 max(데이터타입 변수명1,데이터타입 변수명2): 값 비교하여 큰 쪽 반환.
   - static 데이터타입 min(데이터타입 변수명1,데이터타입 변수명2): 값 비교하여 작은 쪽 반환.
   - static double rint(double a): 주어진 double값과 가장 가까운 정수값을 double형으로 반환
   - static double random(): 0.0~1.0범위의 임의의 double값을 반환한다.(1.0은 범위에 포함되지 않는다.)
   
 - StricMath클래스
 
 Math클래스는 최대한의 성능을 얻기 위해 JVM이 설치된 OS의 메서드를 호출해서 사용한다. 즉, OS에 의존적인 계산을 하고 있고 OS에 따라 계산 결과값이 달라질 수 있다. 이러한 차이를 없애기 위해 성능은 다소 포기하는 대신, 어떤 OS에서 실행되어도 항상 같은 결과를 얻도록 Math클래스를 새로 작성한 것이 StrictMath클래스이다.
 
 - wrapper클래스
 
 기본형 값을 객체로 다루기 위한 클래스이다. 래퍼 클래스의 생성자는 매개변수로 문자열이나 각 자료형의 값들을 인자로 받는데, 생성자의 매개변수로 문자열을 제공할 때, 각 자료형에 알맞은 문자열을 사용해야 예외가 발생하지 않는다. 래퍼 클래스는 모두 equals()가 오버라이딩 되어있어 주소값이 아닌 값을 비교할 수 있다. 참고로 컴파일러가 **오토박싱&언박싱** 기능을 제공해서 기본형과 참조형 간에도 계산이 가능하다.
 
 - 정규식(Regular Expression) - java.util.regex패키지
 
 정규식이란 테스트 데이터 중에서 원하는 조건(패턴, pattern)과 일치하는 문자열ㅇㄹ 찾아 내기 위해 사용하는 것으로 미리 정의된 기호와 문자를 이용해서 작성한 문자열을 말한다. 원하는 데이터 뽑아내거나 형식에 맞는지 체크할 때 활용! 과정을 요약하면 아래와 같다.
   1. 정규식을 매개변수로 Pattern 클래스의 static 메서드인 Pattern complie(String regex)을 호출하여 Pattern인스턴스를 얻는다.
   `예시: Pattern p = Pattern.compile("c[a-z]*");`
   2. 정규식으로 비교할 대상을 매개변수로 Pattern클래스의 Matcher matcher(CharSequence input)를 호출해서 Matcher인스턴스를 얻는다.
   `예시: Matcher m = p.matcher(data[i]);`
   3. Matcher인스턴스에 boolean matches()를 호출해서 정규식에 부합하는지 확인한다.
   `예시: if(m.matches())`
   
 - java.util.StringTokenizer클래스
 
 StringTokenizer는 긴 문자열을 지정된 구분자(delimiter)를 기준으로 토근(token)이라는 여러 개의 문자열로 잘라내는 데 사용된다. 구분자로 단 하나의 문자 밖에 사용하지 못하기 떄문에 보다 복잡한 형태의 구분자로 문자열을 나누어야 할 때는 어절 수 없이 정규식을 사용하는 메서드를 사용해야한다.
 
 split()는 빈 문자열도 토큰으로 인식하는 반면 StringTokenizer는 빈 문자열을 토큰으로 인식하지 않는다. 또한 split()는 데이터를 토큰으로 잘라낸 결과를 배열에 담아서 반환하기 때문에 성능이 비교적 떨어진다.
 
 
