#### 1. 학습 날짜 // 2020-05-18(월)

#### 2. 학습시간 // 10:00~22:00

#### 3. 학습 범위 및 주제 // raycasting, 스프링

#### 4. 동료 학습 방법 // -

#### 5. 학습 목표 // 정보처리기사 한 챕터, 스프링 강의 1강의 이상, cub3D 재개

---

#### 6. 상세 학습 내용

## 의존성(Dependency)

코드에서 두 모듈 간의 연결을 뜻하고, 특히 객체지향언어에서는 두 클래스 간의 관계를 뜻하는 경우가 많다.
의존성이 위험한 이유는 아래와 같다.

- 하나의 모듈이 바뀌면 의존한 다른 모듈까지 변경이 이뤄진다.
- 유닛테스트 작성이 어렵다.
- 코드의 유연성이 떨어진다.
- 코드의 중복 및 가독성을 떨어뜨리는 원인이 된다.

예를 들어 어떤 객체 모듈 내에서 **new 연산자**를 통해 다른 객체의 인스턴스를 생성하면 **강결합(Tightly Coupled)**으로 두 객체가 묶여진다.
이런 위험을 해결하기 위해 의존성 주입(Dependency Injection)이 필요하다.

## 의존성 주입(Dependency injection)

의존성 주입(DI, Dependency injection)은 객체가 필요로하는 어떤 객체를 내부에 선언해두고 **외부에서 생성해서 넣어주는 것**을 말한다. 이 때 [의존관계 역전 원칙(Dependency Inversion Principle)](https://ko.wikipedia.org/wiki/%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84_%EC%97%AD%EC%A0%84_%EC%9B%90%EC%B9%99)을 지키며 의존성이 분리되어야 올바른 DI라고 할 수 있다.

- 재사용성을 높여준다.
- 테스트 작성이 용이하다.
- 코드를 단순화 시켜준다.
- 종속적이던 코드의 수가 줄어든다.
- 코드 가독성이 올라가서 왜 사용하는지 파악하기 수월해진다.
- 유연성과 확장성이 향상된다.
- 객체간의 의존관계를 설정하거나 없애거나 줄일 수 있다.

객체별로 수정이 가능해지므로 프로그래밍의 유연성이 증가한다.

## 의존관계 역전 원칙(Dependency Inversion Principle)

의존관계 역전 원칙은 아래와 같다.

> 1. 하이레벨 모듈은 로우레벨 모듈에 의존해서는 안된다. 둘 다 추상에 의존해야한다.
> 2. 추상은 상세를 의존해서는 안된다. 상세는 추상을 의존해야한다.

> 더 쉽게 말할 수도 있다. 자주 변경되는 컨크리트 클래스에 의존하지 마라. 만약 어떤 클래스의 참조를 가져야 한다면, 참조 대상이 되는 클래스를 추상 클래스로 만들어라. ㅁ나약 어떤 함수를 호출해야 한다면, 호출되는 함수를 추상 함수로 만들어라. <br>
> 일반적으로, 추상 클래스와 인터페이스는 자신에게서 유도된 구체적인 클래스보다 훨씬 덜 변한다.<br> > _Java 프로그래머를 위한 UML 실전에서는 이것만 쓴다! 로버트 C.마틴 지음_

추상과 상세를 분리해서 관계를 최대한 느슨하게 만들어야하는 것이다! 그러면 '역전'이라는 단어는 무얼 의미하는 걸까? '역전'이라는 단어가 쓰인 이유가 궁금하여 [이 페이지](https://vandbt.tistory.com/42)를 참고하였다.

> 의존관계의 역전에서 '역전'이란, "**구조적 디자인**에서 발생하든 로우레벨 모듈의 변경이 하이레벨 모듈의 변경을 요구하는 위계의 관계를 끊자"는 의미로 쓰여진 단어이다.

정통적인 절차적 메소드에서는 하이레벨 모듈이 로우레벨 모듈에 의존하는 형태였다. 이는 아래의 부작용을 낳는다.

- 하이레벨 모듈은 어플리케이션의 중요한 정책 결정과 비즈니스 모델을 담고있음에도 불구하고, 로우레벨 모듈에서 발생하는 변경에 의해 하이레벨 모듈을 변경하는 상황이 야기된다.
- 하이레벨 모듈을 재사용하는 것이 어려워진다.

객체지향적 메소드에서는 위 정통적 형태를 '역전'시킬 수 있다. 하이레벨 모듈이 로우레벨 모듈을 표현하는 추상클래스에 의존하고, 로우레벨 모듈들도 이 추상클래스에 의존하게 하는 것이다.
이런 상황은 **IOC(Inversion Of Control)**라고도 한다.

## IOC Container(Inversion Of Control Container)

위 IOC를 구현하는 프레임워크가 컨테이너이다. 컨테이너는 객체를 관리하고, 객체의 생성을 책임지고, 의존성을 관리한다. 적절한 설정만 되어있다면 누구의 도움 없이도 프로그래머가 작성한 코드를 스스로 참조한 뒤 알아서 객체의 생성과 소멸을 컨트롤해준다.

스프링에서 컨테이너는 아래 두 종류가 있다.

1. 빈팩토리(BeanFactory)

- DI의 기본사항을 제공하는 가장 단순한 컨테이너
- 빈의 정의는 바로 로딩하지만 빈 자체가 필요하게 되어 getBean()이 호출되기 전까지는 인스턴스화를 하지 않는다.(lazy loading)

2. 어플리케이션 컨텍스트(Application Context)

- 빈팩토리와 유사한 기능을 제공하지만 더 많은 기능을 제공한다.
  - 글로벌이 지원되는 텍스트 메세지를 관리해준다.
  - 이미지같은 파일 자원ㅇ르 로드 할 수 있는 포괄적인 방법을 제공해준다.
  - 리스너로 등록된 빈에게는 이벤트 발생을 알려준다.
- 미리 빈을 생성해 놓고, 빈이 필요할 떄 즉시 사용할 수 있도록 보장해준다. _(컨텍스트 초기화 시점에 모든 싱글톤 빈을 미리 로드한 후, 애플리케이션 기동 후에는 빈을 지연없이 얻을 수 있다.)_

[참고링크1](https://effectiveprogramming.tistory.com/entry/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9D%98-%EC%98%AC%EB%B0%94%EB%A5%B8-%EC%9D%B4%ED%95%B4-%EC%B1%85%EC%9E%84Responsibility)
[참고링크2](https://medium.com/@jang.wangsu/di-dependency-injection-%EC%9D%B4%EB%9E%80-1b12fdefec4f)
[참고링크3](https://engkimbs.tistory.com/602?category=767795)
[참고링크4](https://vandbt.tistory.com/42)
[참고링크5](https://medium.com/@jang.wangsu/di-inversion-of-control-container-%EB%9E%80-12ecd70ac7ea)
[참고링크6](https://limmmee.tistory.com/13)

---

#### 학습 내용에 대한 개인적인 총평

클린코드와 스프링 강의에서 '의존성 주입'이라는 개념이 반복해서 나왔습니다. 이 개념을 확인하고 학습해야 제대로된 학습이 될 것이라는 판단하에 '의존성 주입'에 대해서 학습을 진행했습니다. 학습을 진행하다보니 객체지향개념의 전반에 대해서 알아보는 기회를 가질 수 있었습니다. 객체지향은 단순히 클래스를 만들어서 객체를 찍어내는 개념이 아니라는 것을 느꼈습니다. C언어로 주로 프로그래밍을 하다보니 프로그래밍을 '행위의 나열'로 바라보았는데, '객체들 간의 대화'로 바라보는 관점을 접하니 개안하는 느낌이었습니다. 특히 추상 클래스를 활용하여 객체간에 '느슨한 관계'를 만드는 부분에서 왜 객체 지향 패러다임이 유행했는지 그 이유를 엿보았네요. 결과적으로 상황에 맞게 적합한 방식을 쓸 수 있도록 계속 프로그래밍 관점들에 관심을 두어야겠습니다.

---

#### 다음 학습 계획

- 스프링 1강 이상
