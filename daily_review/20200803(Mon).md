1. 학습 날짜 // 2020-08-03(월)

2. 학습시간 // 9:00~22:00

3. 학습 범위 및 주제 // philo_one 구현

4. 동료 학습 방법 // jkang님께 궁금한 점을 물어봄.

5. 학습 목표 // 우선 must_eat_count 없이 잘 돌아가는 프로그램을 만들어본다.

---

6. 상세 학습 내용

막상 코드를 짜려고 하니 과제가 조금 모호하게 적혀있는 것을 확인하였다. 이에 jkang님께 궁금한 것을 물어보았고, 모니터쓰레드와 철학자쓰레드가 별도로 구현되어야한다는 것을 알게되었다.
eunhkim님이 자신이 경험한 통과기준을 말씀해주셔서 하나씩 코드를 버전업하며 이 통과기준에 맞는 함수를 구현해보기로 하였다.

우선 프로그램 실행시 받아오는 인자들의 유효성을 검사하는 함수를 만들었다.
이후 쓰레드를 생성하며 철학자 routine을 계속 실행하는 함수를 만들었고, `pthread_detach` 함수를 연달아 실행하여 쓰레드를 분리시켰다.
그런데 이상하게도 분기한 쓰레드가 실행종료되기엔 한참 남았는데 계속 프로그램이 종료되는 현상이 발생하였다.

#### 문제) 쓰레드가 미처 다 실행되지 않았는데 계속 종료된다.
#### 해결) 분기한 쓰레드가 다 실행될 때까지 메인쓰레드가 종료되지 않아야한다.

처음에는 `pthread_join` 함수를 잘못써서 undefined behavior를 겪었던 것처럼, `ptherad_detach` 함수를 제대로 쓰지 못했기 때문이라고 생각했다. 
실제로 `pthread_join` 함수를 썼더니 분기한 쓰레드들이 모두 종료되고나서 프로그램이 종료되는 것을 확인했기에 더욱 이런 생각에 사로잡혀 `pthread_deatch` 함수에 관해서 깊게 파보았었는데, 원인은 다른 곳에서 찾을 수 있었다.

바로 분기한 쓰레드가 다 실행되기 전에 메인쓰레드가 종료되었기 떄문이었다.

`pthread_join`의 경우, 자식쓰레드가 종료되어 메인쓰레드로 `join`할 때까지 기다리기 때문에 이런 현상이 발생하지 않았지만, `pthread_detach`의 경우 자식쓰레드를 생성시키고 메인쓰레드는 끝까지 실행되어버린 것이었다. 이는 다행히 `phthread_detach`를 쓴 예제들을 분석하다가 메인쓰레드 함수 끝에 `pause()`함수를 쓰는 것을 발견한 덕에 발견할 수 있었다.

문제를 늦게 발견한 이유를 반성해보았는데, 먼저 아직 내가 절차지향적 사고를 벗어나지 못했기 때문임을 알게되었다. 자연스럽게 메인쓰레드가 자식쓰레드의 실행이 종료되어야 다음 코드가 실행될거라고 생각한 것이다. 그리고 무엇보다 문제발생 원인을 구조화해놓고, 가능성이 높은 것부터 하나씩 클리어하려고 하지 않고 직관적으로 생각나는 것들을 하나씩 검증해보려했기 때문이었다.

---

7. 학습 내용에 대한 개인적인 총평

매우 단순한 사실을 깨닫지 못하여 다소 시간을 낭비했습니다. 대신 덕분에 멀티쓰레드 프로그래밍이 무엇인지 제대로 체감한 것 같습니다.
그리고 문제에 접근할 때 INTP스럽게도 직관에 의존하려는 나쁜 습관을 버리고, 좀 더 계획적으로 접근해야겠다고 다시 다짐했습니다. 이전 직장에서 깨달았던 부분인데, 최근 조금 소홀히 했던 것 같습니다.
pthread 시리즈 함수들에 대한 지식이 조금 부족한 것 같아서 내일은 책을 빌려서 한번 참고해봐야겠습니다.

---

다음 학습 계획

- philosopher one 구현