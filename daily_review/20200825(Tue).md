1. 학습 날짜 // 2020-08-25(화)

2. 학습시간 // 9:00~22:00

3. 학습 범위 및 주제 // C++

4. 동료 학습 방법 // -

5. 학습 목표 // C++ module05를 끝낸다.

---

6. 상세 학습 내용

# CPP Module 05

키워드: try-catch

---

C++에서 말하는 '예외(Exception)'는 프로그램의 실행 도중에 발생하는 문제상황을 의미한다. 따라서 컴파일 시 발생하는 **문법적인 에러는 예외에 포함되지 않는다,** 대신 **프로그램의 논리에 맞지 않는 상황이 예외**이다.

C와 달리 C++에서는 try, catch, throw, finally 같은 구문을 통해 구조적으로 예외를 처리할 수 있는 메커니즘을 제공하는데, 이를 통해 코드의 가독성과 유지보수성을 높인다.

*대박.. 함수 스택이 깊어졌을 때 malloc 오류라도 처리하려면 하나하나 return 을 해주면서 예외를 처리했어야했는데 이제 훨씬 편해졌다!ㅎㅎ*

특기할만한 특징

- 예외가 처리되지 않으면, 예외가 발생한 함수를 호출한 영역으로 예외 데이터가 (더불어 예외처리에 대한 책임까지) 전달된다.

- 함수가 여러번 호출되어 스택이 쌓였는데 마지막으로 실행된 함수에서 예외가 발생한다면, 스택이 하나씩 해제되며 호출한 함수에게 예외를 전달한다.

- 만약 반환된 예외를 처리하는 코드가 없다면 main문까지 스택이 풀리고 main문에서도 terminate 함수가 호출되면서 프로그램이 종료되어버린다.

- catch문 적힌 자료형과 throw된 예외의 자료형이 다르다면 catch문이 실행되지 않고, 그 함수를 호출한 영역으로 예외가 전달된다.

- catch문이 여러개일 경우 throw받은 예외를 처리할 수 있는 catch블록을 위에서부터 아래로 찾아내려간다.

- new 연산자에 의해서 발생하는 예외는 'bad_alloc'이라는 예외이다. 

- `catch(...)`처럼 작성하면 전달되는 모든 예외를 다 받아서 처리하게 된다.

- catch 블록에 전달된 예외는 다시 던져질 수 있다.

- 아래처럼 함수선언 뒤에 throw 란을 공란으로 두면 어떠한 예외도 전달하지 않음을 의미하며 이 함수가 예외를 전달하면 프로그램이 그냥 종료된다.

  ```c++
  int SimpleFunc(void) throw()
  {
  ...
  }
  ```

- try~catch문에서 '예외객체'를 throw한 경우엔 객체를 복사해서 던지므로 catch문에서 래퍼런스로 받는 것이 오버로드를 줄이는데 좋다.

- ❗**생성자에서 예외가 발생 시에는 소멸자가 호출되지 않는다!!!** 이 말은 예외를 던지기 이전에 획득한 자원이 있으면 `catch`에서 잘 해제시켜줘야한다.❗

#### try 블록을 묶는 기준

- try블록을 묶는 기준은 **예외가 발생할만한 영역을 묶는 것이 아니다.** 예외가 발생할만한 영역만 묶는 게 아니라, 그와 관련된 모든 문장을 함께 묶어서 이를 하나의 '일'의 단위로 구성하는 것이다. 

#### 전달되는 예외의 명시

특정 함수를 호출할 때 아래 정보들을 알아야한다.

- 함수의 이름
- 매개변수의 선언
- 반환형 정보
- 함수 내에서 전달될 수 있는 예외의 종류 <-- *그래야 해당 함수를 감싸는 적절한 try~catch 블록을 구성할 수 있다.*

#### 예외클래스와 예외객체

예외발생을 알리는데 사용되는 객체를 가리켜 '예외객체'라 하며, 예외객체의 생성을 위해 정의된 클래스를 '예외 클래스'라 한다. 그리고 객체를 이용해서 예외상황을 알리면, 예외가 발생한 원인에 대한 정보를 보다 자세히 담을 수 있다. 



## try~catch 문의 단점

1. 프로그램의 성능이 눈에 띄게 느려진다. <-- 때문에 무조건 발생할 수 있는 모든 예외를 처리하는 것이 아니라 적당한 타협점을 찾아야한다고 한다.
2. 프로그램 용량이 커지게 된다.
3. 전통적인 if-else문을 모두 바꿀 수 있는 것은 아니다.
4. throw로 갑자기 종료할 경우 이전에 동적할당한 메모리가 해제되지 않을 수도 있다.
5. 템플릿에는 쓸 수 없다.

[참고](https://modoocode.com/230)



## new 연산자 예외처리

두 가지 방식이 주로 쓰인다.

- new가 할당실패했을 때 bad_alloc 예외를 발생시키도록 두고, 이를 catch해서 처리하는 방식

  ```c++
  int main(void) {
         Temp * temp;
         try {
                temp = new Temp();
         }
         catch (std::bad_alloc & ba) {
                std::cout << ba.what();
         }
  }
  ```

- new의 인자로 std::nothrow를 전달하여 new가 할당실패했을 때 bad_alloc 예외를 throw하는게 아니라 nullptr를 리턴하도록 한다. 이후 이를 체크하여 처리하는 방식

  ```c++
  int main(void) {
         test * a = new (std::nothrow) test;
         if (a == nullptr) {
                std::cout << "할당 실패";
         }
  }
  ```



## 생성자에서 예외가 발생하면 어떻게 처리될까??

생성자에서 throw할 경우엔 어떻게 될까? 특히 상속된 유도클래스의 생성자가 기초클래스를 만든 상태에서 예외를 throw할 경우엔 어떻게 될까? 아아 뭔가 제대로 모르고 쓰면 큰일날 것만 같은 느낌이 들지 않는가?

실제로 생성자가 throw하는 경우는 그 생성자가 작동하던 객체가 '초기화에 실패한 클래스 객체'라는 것이다. 이 때 이 객체를 사용자가 사용하게 되면 또 오류가 나는 끔-찍한 일이 생기므로 꽤나 심각한 상황이다. 

왠만하면 예외를 throw하여 이를 받아서 처리하게끔 하는 것이 권장된다. 그런데 이런 예외를 throw하는게 불가한 경우가 있다. 왜냐하면~

**생성자에서 예외를 throw하면 소멸자가 호출되지 않는다!**

즉, 생성자에서 힙영역을 할당받고 소멸자에서 되돌려주는 식으로 설계를 했고, 생성자에서 힙영역을 할당받은 다음 예외를 throw한다면 메모리릭이 날 수 있다는 뜻이다.

이런 경우에는 객체를 생성하되 제대로된 객체가 아님을 확인할 수 있도록 해둔 '좀비객체'를 만들어서 처리하는 것도 방법이다.

[참고](https://isocpp.org/wiki/faq/exceptions#ctors-can-throw)

[참고2](https://isocpp.org/wiki/faq/exceptions#selfcleaning-members)



## 예외처리 팁

![try~catch](https://user-images.githubusercontent.com/54612343/91109765-e2b26580-e6b6-11ea-8a57-8303e51e2f3d.png)

위 캡처본은 line12가 실행될 때 'GradeTooLowException'이 throw되는 코드이다. line4에서 동적할당한 메모리주소를 `max_low` 포인터변수에 담고 있고, line14에서 delete하여 메모리 자원을 돌려주려는 의도로 작성된 코드이다. 그런데 이상한 점이 느껴지지 않는가? 결론부터 말하면 위 코드는 컴파일되지 않으며, 컴파일된다고 해도 메모리릭의 위험성을 가지고 있다.

#### 컴파일이 안된다고?

- try문 블럭내에서 정의&선언했던 변수는 try문 바깥에서 쓸 수 없다. 따라서 line19는 컴파일에러를 일으킨다. 만약 line19를 line21로 옮긴다고해도 마찬가지이다.

#### 메모리릭은 왜 나는데?

- 이런 상황에서 line12에서 에러가 throw되면, try 블럭안의 나머지 코드가 작동되지 않고, 바로 line16 catch문으로 진입하기 때문에 동적할당된 메모리주소를 잃어버리게된다. 결국 메모리릭이 발생한다!

#### 어떻게 해결하는가?

결과적으로 아래처럼 try~catch문 밖에서도 주소값을 보존하고, 동적할당 여부에 따라 delete여부를 결정하도록 코딩하였다.

![try~catch_advanced](https://user-images.githubusercontent.com/54612343/91110546-1f7f5c00-e6b9-11ea-8316-85f8b5feaec1.png)

- line1: 처음에 `max_low`변수를 try~catch문 밖에서 선언하며 nullptr를 정의해주었다. 이제 try~catch문 밖에서도 `max_low`변수에 접근할 수 있게 되었다.
- line5: try~catch문 밖에서 선언해둔 포인터에 동적할당한 주소를 저장한다. 동적할당을 실패할 경우 `bad_alloc`에러를 리턴하여 line20의 catch문에 진입하게 된다.
- line24: 만약 `max_low` 변수에 동적할당한 주소가 담겨있으면 delete하여 자원을 돌려준다.

---

요는 업캐스팅된 객체의 함수에 어떻게 접근할지, 그 객체의 소멸자 처리를 어떻게 할지가 포인트이다! 가상의 강력함을 느낄 수 있는 모듈.

#### ex03

- 과제문서를 보면 `class AMataria` 가 `AMataria.hpp`에 있고, `class ICharacter`가 `ICharacter.hpp`에 있는데, `class ICharacter`가 `class AMataria`를 사용하고, `class AMataria`가 `class ICharacter`를 사용하는.. 난감하게 설계된 상태이다. 
  다행히 `class ICharacter`에서는 AMataria 포인터만 쓰므로, 클래스 전방선언을 이용하여 해결하자.
- [참고3번 링크](https://postgame.tistory.com/33)를 보면 pimpl(pointer to implementation) 관용구나 상속을 이용하여 멋지게 해결할 수 있는 방법이 있는 것을 늦게 알게되었다. 다음에는 이 구현방식을 응용해보자.

  [참고1](https://jrabbit.tistory.com/35)
  [참고2](https://gpgstudy.com/forum/viewtopic.php?t=23724)
  [참고3](https://postgame.tistory.com/33)

---    
    
7. 학습 내용에 대한 개인적인 총평 

와 진짜 신세계.. 사실 try~catch문이 있는 것은 알고 있었고, 배우는 것을 고대해왔는데 생각보다 더 신세계였습니다.
이전에 함수스택 깊은 곳에서 malloc guard라도 건다고 치면, return되는 값을 받아서 안전하게 종료되도록 한땀한땀 코딩했었는데, 혁신적으로 편해졌네요.
이런 규칙을 만들어낸 비아르네 스트로우스트루프씨에게 리스펙..

---

다음 학습 계획

- CPP Module05 구현완료, CPP Module06 구현완료