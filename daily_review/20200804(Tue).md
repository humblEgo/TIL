1. 학습 날짜 // 2020-08-04(화)

2. 학습시간 // 9:00~22:00

3. 학습 범위 및 주제 // pthread_mutex

4. 동료 학습 방법 // -

5. 학습 목표 // 우선 must_eat_count 없이 잘 돌아가는 프로그램을 만들어본다.

---

6. 상세 학습 내용

# POSIX 쓰레드

POSIX 표준 하에서는 여러 파일 디스크립터의 입력을 모니터링하기 위해 다음 6가지 접근법이 일반적으로 사용된다.

1. 여러 프로세스가 파일 디스크립터를 각각 모니터링한다.
2. Select
3. Poll
4. 폴링(Polling) 기법을 통한 논블록 I/O
5. POSIX 비동기 I/O
6. 여러 쓰레드가 파일 디스크립터를 각각 모니터링한다.

6번 방법을 사용하면 주어진 문제상황을 단일 파일 디스크립터를 처리하는 문제로 단순화시킬 수 있다. 다른 구현보다 훨씬 간단하다고 한다!

pthreads는 'POSIX threads package'에서 따온 말인 것.. 알고 있었는가.. 난 몰랐다.

pthreads 함수 시리즈는 성공시에 0을 리턴하고 실패시에 0이 아닌 에러 코드를 리턴한다.  이들은 errno를 설정하지 않으므로, 호출자는 에러를 보고하기 위해 perror 함수를 사용할 수 없다.

## 쓰레드 생성하기

pthread_create 함수는 쓰레드를 생성한다. 다른 쓰레드 패키지와 달리 POSIX의 pthread_create 함수는 따로 시작 명령을 내리지 않아도 자동으로 쓰레드를 실행 가능 상태로 만든다고 한다.

## 쓰레드를 분리(detach)하고, 결합(join)하기

별다른 옵션 없이 쓰레드를 생성하면 분리되어 있지 않은 쓰레드가 생성된다. 이 분리되어있지 않은 쓰레드를 결합 가능(joinable)하다고 하는데, pthread_join을 호출하거나 전체 프로세스가 종료되지 않는 한 자신의 가지고 있던 자원을 반환하지 않는다.

만일  `pthread_join(pthread_self());` 같은 요망한 코드를 작성하면 무슨 일이 생길까? 

정답은 쓰레드가 결합 가능하다는 가정하에(즉, 분리되어 있지 않다는 가정하에), 이 문장은 데드락을 발생시킨다. 일부 OS에서는 데드락을 감지하고는 pthread_join 함수가 EDEADLK 에러를 리턴하기도 한다.

반면 쓰레드가 종료할 때, 쓰레드가 분리되어 있다면 해당 쓰레드가 가진 자원을 해제하고, 자신의 종료 상태를 보고하지 않는다.

pthread_detach로 쓰레드를 분리시킨다.

## 쓰레드를 종료하고, 취소하기

프로세스를 종료하기 위해서는 아래 세 가지 방법이 있다.

1. exit 함수를 직접 호출
2. main문에서 return 문을 수행
3. 프로세스 내의 다른 쓰레드에서 exit 함수를 호출

이들 중 어떤 경우라도, **모든 쓰레드는 종료**된다. *내가 이걸 간과하고 실컨 쓰레드를 생성하고서 main문이 냅다 종료되게 놔두었다가 그만.. 긴 시간을 날리고 말았지..* 

만일 메인 쓰레드(main문이 포함되어있는 그 쓰레드!)가 다른 쓰레드들을 모두 생성한 후 더 이상 할 일이 없다면, 메인 함수는 모든 쓰레드가 오나료될 때까지 블록된 채로 있거나, pthread_exit(NULL)을 호출하면 된다. *요건 42에겐 허용되어있지 않다ㅎㅎ*

## 쓰레드로 매개변수를 넘기고, 값을 리턴받기

쓰레드 생성자는 생성시에 쓰레드에게 void 포인터 형의 매개변수 하나를 념겨 줄 수 있다. 여러 개의 값을 넘겨 주고자 한다면, 배열이나 구조체에 대한 포인터를 넘겨 주면 된다.

## 쓰레드-안전성

여러 쓰레드가 어떤 함수를 서로 간의 간섭 없이 동시에 호출하여 실행하는 것이 가능할 때, 그 함수를 쓰레드-안전적(thread-safe)이라고 한다.

쓰레드를 사용할 때 잠재적인 문제점은 바로 쓰레드-안정성(thread safety)을 보장하지 않는 라이브러리 함수들을 호출하는 것이다. 쓰레드-안정적이지 못한 라이브러리 함수들은 잘못된 결과를 발생시킬 가능성을 갖는다. 예를들어 `strerror` 같은 함수가 그렇다. 요런 함수는 `strerror_r`처럼 '_r'로 끝나는 네이밍으로 쓰레드-안전적인 버전을 새로 정의하였다.

## 유저 쓰레드와 커널 쓰레드

쓰레드 제어 방식에는 두 가지 전통적인 모델이 존재한다.

1. 유저 레벨 쓰레드

2. 커널 레벨 쓰레드

   커널은 각 쓰레드를 스케쥴링 가능한 개체로서 인식하며, 각 쓰레드들은 프로세서 자원을 획득하기 위해 시스템 레벨에서 경쟁한다. 커널 레벨 쓰레드의 스케쥴링 비용은 프로세스 자체를 스케쥴링하는 비용과 거의 맞먹지만, 커널 레벨 쓰레드를 사용하면 멀티프로세서의 이점을 취할 수 있다. 물론 유저 레벨 쓰레드보다는 비용이 많이 든다.

이 두가지 모델의 장점을 취한 '하이브리드 쓰레드 모델'도 있다. POSIX 쓰레드 스케쥴링 모델은 하이브리드 모델이다!

## 쓰레드 속성

POSIX 표준은 스택 크기나 스케쥴링 정책 등과 같은 특성을 `pthread_attr_t` 형의 객체로 캡슐화함으로써 특성의 표현 및 할당에 대해 객체 지향적인 접근법을 사용하고 있다. 속성 객체는 오직 쓰레드의 생성 시에만 영향을 미친다. 덕분에 pthread_crate 호출 시에 수많은 인자들을 넣어주지 않아도 된다.

## 쓰레드 스케쥴링

속성 객체의 경쟁 범위(contention scope)는 쓰레드가 스케쥴링 자원을 획득하기 위해서 프로세스 내에서만 경쟁할 것인지, 아니면 시스템 수준에서 경쟁할 것인지를 제어한다. 

동일한 우선순위를 갖는 쓰레드들은 스케쥴링 정책에 따라 프로세서 자원을 얻기 위해 경쟁한다.

스케쥴링 정책의 예시는 아래와 같다.

- FIFO 스케쥴링 정책
- 라운드 로빈 스케쥴링 정책
- 우발성 스케쥴링 정책
- 선점형 우선순위 스케쥴링 정책

## POSIX 동기화 함수

POSIX:THR Extension에서 이용가능한 동기화 메커니즘은 아래 3가지이다.

- 뮤텍스 잠금(mutex lock)
- 조건변수(condition variable)
- 일기-쓰기 잠금(read-write lock)

## 뮤텍스 잠금

뮤텍스는 잠금(locked) 상태나 잠금이 풀린(unlocked) 상태 중 하나를 갖는 특별한 변수이다. 뮤텍스는 해당 뮤텍스를 잡기 위해 기다리고 있는 쓰레드들을 위한 큐를 가지고 있다. 뮤텍스 큐에 있는 쓰레드들이 뮤텍스를 획득하는 순서는 쓰레드 스케쥴링 정책에 따라 달라질 수 있지만, POSIX 표준은 어떤 특정한 정책을 구현하기를 요구하지 않는다.

쓰레드가 잠겨 있지 않은 뮤텍스를 획득하려고 시도하면, 쓰레드는 블록되지 않고 뮤텍스르 ㄹ얻는다. 이런 경우는 쓰레드가 큐에 들어가고 곧바로 자동적으로 큐에서 제거된 후 뮤텍스를 획득했다고 생각해도 무방하다.

뮤텍스 함수들은 쓰레드 취소 지점으로 동작하지도 않으며, 시그널에 의해 인터럽트되지도 않는다. 뮤텍스에서 대기 중인 쓰레드는 논리적인 면에서 인터럽트 될 수 없다. 단, 프로세스의 종료, 시그널 핸들러에서의 pthread_exit 함수 호출을 통한 쓰레드 종료, 비동기 취소(일반적으로 잘 사용되지 않음) 등의 경우는 예외이다.

뮤텍스는 단기간 동안만 잠겨서 사용하려는 의도로 만들어졌다. 이 말이 무슨 말이냐, 입력을 기다리는 경우처럼 기다리는 기간이 정해지지 않은 사건에 대해서는 조건변수를 사용해야 한다는 뜻이다.

## 뮤텍스의 생성과 초기화

POSIX에서는 뮤텍스 잠금을 나타내기 위해 pthread_mutex_t 형을 사용한다. 프로그램은 뮤텍스를 사용하기 전에 항상 뮤텍스를 초기화해야 한다. pthread_mutex_t 변수를 정적으로 초기화하려면, 단순히 해당 변수에 PTHREAD_MUTEX_INITIALIZER를 할당해 주면 된다. 

```c
ptrhead_mutex mylock;
mylock = PTHREAD_MUTEX_INITIALIZER; // 요래 쓰라는 말씀!
```

정적 초기화 방식은 `pthread_mutex_init` 함수를 호출한 방법보다 더 효율적이며, 어떠한 쓰레드도 실행되기 전에 반드시 단 한번만 초기화가 수행되도록 보장해 준다.

동적으로 할당되거나 기본 뮤텍스 속성을 갖지 않는 뮤텍스 변수의 경우, `pthread_mutex_init`함수를 호출하여 초기화해 주어야 한다.

```c
int error;
pthread_mutex_t mylock;

if (error = pthread_mutex_init(&mylock, NULL))
	fprintf(strderr, "Failed to init mylock: %s\n", strerror(error)); 
//주의, strerror는 쓰레드-안전하지 않은 함수이다! 여러개 쓰레드에서 호출된다면 쓰면 안됨.
```

Q) 어떤 쓰레드가 이미 초기화된 뮤텍스를 초기화하려고 시도한다면 무슨 일이 벌어질까?

A) POSIX는 이 행동이 정의되어 있지 않다고 명시적으로 언급하고 있다. 따라서 프로그램에서 이와 같은 상황은 반드시 피해야한다.

## 뮤텍스를 파괴하기

`pthread_mutex_destroy` 함수는 매개변수로 주어진 뮤텍스를 파괴한다. mutex 매개변수는 파괴하고자 하는 뮤텍스를 가리키는 포인터이다. pthread_mutex_destroy 함수를 통해 파괴된 pthread_mutex_t 변수는 pthread_mutex_init 함수를 사용해야 다시 초기화될 수 있다.

Q) 이미 파괴된 뮤텍스를 참조하면 뭔일 생길까? 아니면 한 쓰레드가 pthread_mutex_destroy 함수를 호출할 때, 다른 쓰레드가 해당 뮤텍스를 잠근 상태였다면 무슨 일이 발생할까?

A) POSIX에서는 두 상황에 대한 행동이 정의되어 있지 않다고 명시적으로 언급한다. 피하자.

## 뮤텍스의 잠금과 해제

```c
pthread_mutex_t mylock;

mylock = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_lock(&mylock);  // pthread_mutex_lock은 mylock이 unlock될 때까지 블록된다.
/* 크리티컬 세션*/
pthread_mutex_unlock(&mylock);
```

POSIX 표준에서 멀티쓰레드 애플리케이션에서 안전하지 못하다고 명시되어있는 함수들은 여러 쓰레드에서 동시 호출되지 않도록 신경써서 뮤텍스 설정을 해주도록하자!

## 참고

[Unix Systems Programing 책]([http://www.yes24.com/Product/Goods/2117890](http://www.yes24.com/Product/Goods/2117890))

---

7. 학습 내용에 대한 개인적인 총평

뮤텍스에 대해서 좀 더 제대로 학습하고 싶어서 [Unix Systems Programing 책]([http://www.yes24.com/Product/Goods/2117890](http://www.yes24.com/Product/Goods/2117890))을 빌려보았습니다.
인터넷에 pthread_join 예제들이 맞게 적혀있지 않아서 고생했기 때문에 좀 근본있는 지식을 얻고 싶은 마음이 컸습니다(..)
확실히 책은 목차가 있다보니 내가 원하는 지식이 지식체계의 어디에 위치하는지 확인하고, 더 자세하게 확인하는데 특화되어있는 것 같습니다.
프로그램 구현이 조금 늦어진만큼 내일부터는 속도를 내야겠습니다.

---

다음 학습 계획

- philosopher one 구현